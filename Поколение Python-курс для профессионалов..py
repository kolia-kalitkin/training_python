

# Функция hide_card()
# 1 084
# Реализуйте функцию hide_card(), которая принимает один аргумент:
#     card_number — строка, представляющая собой корректный номер банковской карты из 1616 цифр, между которыми могут присутствовать символы пробела
# Функция должна заменять первые 1212 цифр в строке card_number на символ * и возвращать полученный результат. Если между цифрами в номере имелись символы пробела, их следует удалить.
# ---------------------------------------------------------------------------
import keyword
import re
from typing import Iterator
import itertools as it
import pandas as pd
from typing import Iterable, Generator, Any
from typing import Generator
from typing import Iterable
import random
import builtins
import functools
from typing import Callable
from collections import Counter
from collections import OrderedDict
from collections import defaultdict
from collections import namedtuple
import string
from string import ascii_letters
import os.path
import operator
import sys
import csv
import json
import pickle
from sys import exc_info
from csv import DictReader
from zipfile import ZipFile
import zipfile
from datetime import datetime, date, timedelta
from datetime import date, time, timedelta, datetime
from datetime import datetime, timedelta
from datetime import datetime
from datetime import date, timedelta
from datetime import date
import calendar
import locale


def hide_card(card_number):
    card_number = list(filter(lambda x: x.isdigit(), card_number))
    return '*' * 12 + ''.join(card_number[12:])

# card = '1234567890123456'
# print(hide_card(card))
# ---------------------------------------------------------------------------


def hide_card(card):
    return '*' * 12 + card.replace(' ', '')[-4:]
# ===========================================================================


# Функция same_parity()
#  1 017
# # Реализуйте функцию same_parity(), которая принимает один аргумент:
#     numbers — список целых чисел
# Функция должна возвращать новый список, элементами которого являются числа из списка numbers, имеющие ту же четность, что и первый элемент этого списка.
# ---------------------------------------------------------------------------
def same_parity(numbers):
    return list(filter(lambda x: x % 2 == numbers[0] % 2, numbers))

# print(same_parity([]))
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция is_valid()
# 954
# Будем считать, что PIN-код является корректным, если он удовлетворяет следующим условиям:

#     состоит из 44, 55 или 66 символов
#     состоит только из цифр (0−90−9)
#     не содержит пробелов
# Реализуйте функцию is_valid(), которая принимает один аргумент:
#     string — произвольная строка
# Функция должна возвращать значение True, если строка string представляет собой корректный PIN-код, или False в противном случае.
# ---------------------------------------------------------------------------
def is_valid(string):
    return 4 <= len(string) <= 6 and string.isdigit()

# ---------------------------------------------------------------------------


def is_valid(pin):
    return pin.isdigit() and len(pin) in (4, 5, 6)
# ===========================================================================


# Функция print_given()
# 880
# Реализуйте функцию print_given(), которая принимает произвольное количество позиционных и именованных аргументов и выводит все переданные аргументы, указывая тип каждого. Пары аргумент-тип должны выводиться каждая на отдельной строке, в следующем формате:
#     для позиционных аргументов:
#     <значение аргумента> <тип аргумента>
#     для именованных аргументов:
#     <имя переменной> <значение аргумента> <тип аргумента>
# Примечание 1. При выводе позиционные аргументы должны быть расположены в порядке их передачи, именованные — в лексикографическом порядке имен переменных.
# Примечание 2. При выводе сначала должны следовать все позиционные аргументы, затем — все именованные.
# ---------------------------------------------------------------------------
def print_given(*args, **kwargs):
    for i in args:
        s = (i, type(i))

    for key, value in sorted(kwargs.items()):
        s = (key, value, type(value))
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция convert()
# 913
# Реализуйте функцию convert(), которая принимает один аргумент:
#     string — произвольная строка
# Функция должна возвращать строку string:
#     полностью в нижнем регистре, если букв в нижнем регистре в этой строке больше
#     полностью в верхнем регистре, если букв в верхнем регистре в этой строке больше
#     полностью в нижнем регистре, если количество букв в верхнем и нижнем регистрах в этой строке совпадает
# Примечание 1. Символы строки, не являющиеся буквами, следует игнорировать.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию convert(), но не код, вызывающий ее.
# Примечание 3. Тестовые данные доступны по ссылкам:
#     Архив с тестами
#     GitHub
# ---------------------------------------------------------------------------
def convert(string):
    l1 = list(filter(lambda x: x == x.lower(), string))
    l2 = list(filter(lambda x: x == x.upper(), string))
    # l3 = list(filter(lambda x: x == x.lower() , string))
    n1 = len(l1)
    n2 = len(l2)

    if n1 >= n2:
        return string.lower()
    else:
        return string.upper()

# ---------------------------------------------------------------------------


def convert(string):
    if sum(1 if c.isupper() else -1 for c in string if c.isalpha()) > 0:
        return string.upper()
    return string.lower()


# ---------------------------------------------------------------------------
def convert(text):
    lower_count = len(list(filter(str.islower, text)))
    upper_count = len(list(filter(str.isupper, text)))
    if lower_count >= upper_count:
        return text.lower()
    return text.upper()
# ===========================================================================


# Функция filter_anagrams()
# 901
# Анаграммы — это слова, которые состоят из одинаковых букв. Например:
#     адаптер — петарда
#     адресочек — середочка
#     азбука — базука
#     аистенок — осетинка
# Реализуйте функцию filter_anagrams(), которая принимает два аргумента в следующем порядке:
#     word — слово в нижнем регистре
#     words — список слов в нижнем регистре
# Функция должна возвращать список, элементами которого являются слова из списка words, которые представляют анаграмму слова word. Если список words пуст или не содержит анаграмм, функция должна вернуть пустой список.
# Примечание 1. Слова в возвращаемом функцией списке должны располагаться в своем исходном порядке.
# Примечание 2. Считайте, что слово является анаграммой самого себя.
# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию filter_anagrams(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
def filter_anagrams(word, words):
    anagrams = []
    w_sort = ''.join(sorted(list(word)))
    for i in words:
        if w_sort == ''.join(sorted(list(i))):
            anagrams.append(i)
    return anagrams

# --------------------от препода-------------------------------------------


def filter_anagrams(word, anagrams):
    return [anagram for anagram in anagrams if sorted(anagram) == sorted(word)]
# ======================комменты==============================================


def filter_anagrams(word, words):
    return list(filter(lambda w: sorted(word) == sorted(w), words))
# ===========================================================================

# Функция likes()
# 879
# В различных социальных сетях существуют системы лайков, которые в зависимости от количества людей, оценивших запись, показывают соответствующую информацию.
# Реализуйте функцию likes(), которая принимает один аргумент:
#     names — список имён
# Функция должна возвращать строку в соответствии с примерами ниже, содержание которой зависит от количества имён в списке names.
# ---------------------------------------------------------------------------


def likes(names):

    if len(names) == 0:
        s = ('Никто не оценил данную запись')
    elif len(names) == 1:
        s = (f'{names[0]} оценил(а) данную запись')
    elif len(names) == 2:
        s = (f'{names[0]} и {names[1]} оценили данную запись')
    elif len(names) == 3:
        s = (f'{names[0]}, {names[1]} и {names[2]} оценили данную запись')
    elif len(names) > 3:
        s = (
            f'{names[0]}, {names[1]} и {len(names) - 2} других оценили данную запись')

    return s


# ---------------------------------------------------------------------------

# ===========================================================================


# Функция index_of_nearest()
# 852
# Реализуйте функцию index_of_nearest(), которая принимает два аргумента в следующем порядке:
#     numbers — список целых чисел
#     number — целое число
# Функция должна находить в списке numbers ближайшее по значению число к числу number и возвращать его индекс. Если список numbers пуст, функция должна вернуть число −1−1.
# ---------------------------------------------------------------------------
def index_of_nearest(numbers, number):
    if numbers:
        return -1

    dif = []
    for i in range(len(numbers)):
        dif.append((abs(numbers[i] - number), i))

    dif.sort()

    return dif[0][1]
# ---------------------------------------------------------------------------


def index_of_nearest(nums, n):
    if nums:
        minimum = min(nums, key=lambda num: abs(num - n))
        return nums.index(minimum)
    return -1


# ===========================================================================


# Функция spell()
# 823
# Реализуйте функцию spell(), которая принимает произвольное количество позиционных аргументов-слов и возвращает словарь, ключи которого — первые буквы слов, а значения — максимальные длины слов на эту букву.
# Примечание 1. Если в функцию не передается ни одного аргумента, функция должна возвращать пустой словарь.
# Примечание 2. Функция должна игнорировать регистр слов, при этом в результирующий словарь должны попасть именно буквы в нижнем регистре.
# ---------------------------------------------------------------------------
def spell(*args):
    l1 = list(map(lambda x: (x[0].lower(), len(x)), args))

    dict1 = {}

    for key, value in sorted(l1):
        dict1[key] = value

    return dict1

# words = ['россия', 'Австрия', 'австралия', 'РумыниЯ', 'Украина', 'КИТай', 'УЗБЕКИСТАН']
# print(spell(*words))
# ---------------------------------------------------------------------------


def spell(*args):
    result = {}
    for word in args:
        if result.get(word[0].lower(), 0) < len(word):
            result[word[0].lower()] = len(word)
    return result
# ===========================================================================


def spell(*args):
    return {i[0].lower(): len(i) for i in sorted(args, key=len)}
# ===========================================================================

# Функция choose_plural() 🌶️🌶️
# 793
# Реализуйте функцию choose_plural(), которая принимает два аргумента в следующем порядке:
# ОКОНЧАНИЯ ЧИСЛИТЕЛЬНЫХ
#     amount — натуральное число, количество
#     declensions — кортеж из трех вариантов склонения существительного
# Функция должна возвращать строку, полученную путем объединения подходящего существительного из кортежа declensions и количества amount, в следующем формате:
# <количество> <существительное>
# ---------------------------------------------------------------------------


def choose_plural(amount, declensions):

    d1 = amount % 10
    d2 = amount % 100

    if d1 >= 5 or d1 == 0 or 10 < d2 < 20:
        return f"{amount} {declensions[2]}"
    elif d1 == 1:
        return f"{amount} {declensions[0]}"
    else:
        return f"{amount} {declensions[1]}"

# print(choose_plural(92, ('гвоздь', 'гвоздя', 'гвоздей')))
# -------------от препода---------------------------------------------- ОКОНЧАНИЯ ЧИСЛИТЕЛЬНЫХ


def choose_plural(amount, variants):
    variant = 2
    if amount % 10 == 1 and amount % 100 != 11:
        variant = 0
    elif amount % 10 >= 2 and amount % 10 <= 4 and (amount % 100 < 10 or amount % 100 >= 20):
        variant = 1
    return '{} {}'.format(amount, variants[variant])
# ===========================================================================


def choose_plural(amount, declensions):
    if amount % 100 in (11, 12, 13, 14):
        ind = 2
    elif amount % 10 in (5, 6, 7, 8, 9, 0):
        ind = 2
    elif amount % 10 in (2, 3, 4):
        ind = 1
    elif amount % 10 == 1:
        ind = 0
    return f'{amount} {declensions[ind]}'
# ===========================================================================


def choose_plural(num, declensions):
    xlat_table = [2, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    new_num = num % 100
    if new_num >= 20:
        new_num %= 10
    return f'{num} {declensions[xlat_table[new_num]]}'
# Про то, что табличку можно сократить до 14 значений, я понял несколько позже. Так что пусть остается,, как есть

# Функция get_biggest() 🌶️🌶️
#
#
# ---------------------------------------------------------------------------


def get_biggest(numbers):
    if not numbers:
        return -1

    # l1 = list(map(str, numbers))
    l1 = [str(n) for n in numbers]

    len_mx = len(str(max(numbers)))
    # print(len_mx)

    l2 = sorted(l1, key=lambda x: (x * len_mx), reverse=True)
    # print(l2)

    return int(''.join(l2))

# ------------препод-------------------------------------------


def get_biggest(numbers):
    if not numbers:
        return -1

    li = [str(i) for i in numbers]
    lenght = len(li)

    for i in range(lenght):
        index = i
        for j in range(i + 1, lenght):
            if li[j] + li[index] > li[index] + li[j]:
                index = j
        li[i], li[index] = li[index], li[i]

    return int(''.join(li))
# ===========================================================================


def get_biggest(numbers):
    if numbers:
        ln = len(max(map(str, numbers), key=len))
        return int(''.join(map(str, sorted(numbers, key=lambda x: str(x)*ln,  reverse=True))))
    else:
        return -1
# ===========================================================================


# Тимур, Артур и новый курс
# 717
# Сегодня Тимур ждёт в гости своего друга Артура, чтобы спланировать работу по новому курсу "ООП на Python". Чтобы подготовиться к встрече, Тимуру необходимо посетить два магазина, расположенных рядом с его домом. От дома до первого магазина ведёт дорожка длиной d1d1​ метров, а до второго магазина ведёт дорожка длиной d2d2​ метров. Также существует дорожка, соединяющая два магазина друг с другом, длиной d3d3​ метров.
# Напишите программу, которая вычисляет минимальное расстояние, которое потребуется пройти Тимуру, чтобы посетить оба магазина и вернуться домой. Тимур всегда стартует из дома. Он должен посетить оба магазина, перемещаясь только по имеющимся трём дорожкам, и вернуться назад домой. При этом его совершенно не смутит, если ему придётся посетить один и тот же магазин или пройти по одной и той же дорожке более одного раза. Единственная его задача — минимизировать суммарное пройденное расстояние.
# ---------------------------------------------------------------------------
d1, d2, d3 = [int(input()) for _ in range(3)]
print(min(d1 + d3 + d2, d1 + d1 + d2 + d2, d2 + d3 + d3 + d2, d1 + d3 + d3 + d1))
# ---------------------------------------------------------------------------

# ===========================================================================

# Схожие буквы
# 895
# В русском и английском языках есть буквы, которые выглядят одинаково. Вот список английских букв "AaBCcEeHKMOoPpTXxy",
# а вот их русские аналоги "АаВСсЕеНКМОоРрТХху". Напишите программу, которая для трёх букв из данных списков букв определяет, русские они,
# английские или и те и другие (смесь русских и английских букв).
# ---------------------------------------------------------------------------
lst_en = "AaBCcEeHKMOoPpTXxy"
lst_ru = "АаВСсЕеНКМОоРрТХху"

count = 0
for _ in range(3):
    letter = input()
    if letter in lst_en:
        count += 1
    elif letter in lst_ru:
        count -= 1

if count == -3:
    print('ru')
elif count == 3:
    print('en')
else:
    print('mix')
# ---------------------препод-------------------------------------------
langs = ['ru', 'mix', 'mix', 'en']
eng = 'AaBCcEeHKMOoPpTXxy'
ind = sum(input() in eng for _ in range(3))
print(langs[ind])
# ===========================================================================


# Переворатор
# 790
# Дана последовательность натуральных чисел от 11 до nn включительно. Напишите программу, которая сначала располагает в обратном порядке часть элементов этой последовательности от элемента с номером XX до элемента с номером YY, а затем от элемента с номером AA до элемента с номером BB.
# ---------------------------------------------------------------------------
res = []
# lst = ['n', 'x', 'y', 'a', 'b']
lst = [int(i) for i in input().split()]

range_start = list(range(1, lst[0] + 1))

r2 = range_start[:lst[1]-1] + \
    range_start[(lst[1]-1):(lst[2])][::-1] + range_start[lst[2]:]
r3 = r2[:lst[3]-1] + r2[(lst[3]-1):(lst[4])][::-1] + r2[lst[4]:]
print(*r3)
# ---------------------------------------------------------------------------
n, x, y, a, b = [int(i) for i in input().split()]
nums = list(range(1, n + 1))

# перевернуть список в Python с помощью функции reversed()
nums[x - 1:y] = reversed(nums[x - 1:y])
nums[a - 1:b] = reversed(nums[a - 1:b])

print(*nums)
# ===========================================================================


# Более одного
# 915
# Дана последовательность неотрицательных целых чисел. Напишите программу, которая выводит те числа, которые встречаются в данной последовательности более одного раза.
# ---------------------------------------------------------------------------
nums = [int(i) for i in input().split()]
dict1 = {}

for num in nums:
    dict1[num] = dict1.get(num, 0) + 1

for key, value in sorted(dict1.items()):
    if value > 1:
        print(key, end=' ')


# -----------------препод------------------------------------------------

# Метод count() возвращает количество раз, когда указанный элемент появляется в списке.

nums = [int(i) for i in input().split()]
print(*sorted(filter(lambda i: nums.count(i) > 1, set(nums))))
# ===========================================================================


# Максимальная группа
# 858
# Назовем набор различных натуральных чисел группой. Например: (13,4,22,40)(13,4,22,40). Тогда длиной группы будем считать количество чисел в группе. Например, длина группы (13,4,22,40)(13,4,22,40) равна 44.
# Дана последовательность натуральных чисел от 11 до nn включительно.
# Напишите программу, которая группирует все числа данной последовательности по сумме их цифр и определяет длину группы, содержащей наибольшее количество чисел.
# ---------------------------------------------------------------------------

def sum_of_digits(x):
    result = []
    while x > 0:
        result.append(x % 10)
        x //= 10

    return sum(result)


# ============================================================
numbers_range = list(range(1, int(input()) + 1))

result = {}

for el in numbers_range:
    result.setdefault(sum_of_digits(el), []).append(el)


print(len(max(result.values(), key=len)))
# ---------------------------------------------------------------------------

# ===========================================================================


# Трудности перевода
# 893
# Зачастую переводить сериалы, не теряя изначальный смысл, невозможно, особенно за счет игр слов. Сумасшедший режиссер хочет снять сериал, в котором бы в целях эксперимента задействовал как можно больше языков, чтобы пользоваться красотой каждого из них. Тем не менее если задействовать слишком много языков, то сериал станет непонятен абсолютно всем, поэтому режиссер достает случайных людей на улице и спрашивает их, какие языки они знают, таким образом он будет использовать языки которые знают все из них.
# Напишите программу, которая определяет, какие языки будут использоваться в сериале.
# ---------------------------------------------------------------------------

dict1 = {}
set1 = set()

for i in range(int(input())):
    dict1.setdefault(i, set()).update(input().split(', '))
    set1.update(dict1[i])

for value in dict1.values():
    set1.intersection_update(value)

if set1:
    print(*sorted(set1), sep=', ')
else:
    print('Сериал снять не удастся')
# -----------------препод-------------------------------------------------
n = int(input())  # чтобы не нарушать порядок ввода
langs = set(input().split(', '))

for _ in range(n - 1):
    langs &= set(input().split(', '))  # intersection_update

if langs:
    print(*sorted(langs), sep=', ')
else:
    print('Фильм снять не удастся')
# ===========================================================================
com_langs = set.intersection(*(set(input().split(', '))
                             for _ in range(int(input()))))
# при пустом множестве в левой части будет пустая строка, эквивалентная False в условии, и отработает правая часть or
print(', '.join(sorted(com_langs)) or 'Сериал снять не удастся')

# ===========================================================================
lang = [set(input().split(', ')) for _ in range(int(input()))]
print(', '.join(sorted(reduce(lambda a, b: a & b, lang)))
      or 'Сериал снять не удастся')

# ===========================================================================
print(*sorted(set.intersection(*[set(input().strip().split(', '))
      for _ in range(int(input()))])) or ['Сериал снять не удастся'], sep=', ')
# ===========================================================================
# Использование * и ** для передачи аргументов в функцию;
# Использование * и **   для сбора переданных в функцию аргументов;
# Использование ** для принятия только именованных аргументов;
# Использование * при распаковке кортежей;
# Использование * для распаковки итерируемых объектов в список/кортеж;
# Использование ** для распаковки словарей в другие словари.
d = [set(input().split(', ')) for i in range(int(input()))]
res = sorted(set.intersection(*d))
if res == []:
    print('Сериал снять не удастся')
else:
    print(*res, sep=', ')


# Схожие слова
# Напишите программу, которая находит все схожие слова для заданного слова. Слова называются схожими, если имеют одинаковое количество и расположение гласных букв. При этом сами гласные могут различаться.
# 825
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------

# ===========================================================================


#
# 964
# Ураган Эндрю, обрушившийся на Флориду 2424 августа 19921992 года, был одним из самых дорогостоящих и смертоносных ураганов в истории США. Дополните приведенный ниже код, чтобы он вывел день недели (начиная с 00), в который ураган Эндрю достиг берегов США.
# ---------------------------------------------------------------------------
# импортируем тип date из модуля datetime
# from datetime import date

# создаем объект, соответсвующий дате урагана
hurricane_andrew = date(1992, 8, 24)

# выводим день недели
print(hurricane_andrew.weekday())

# ---------------------------------------------------------------------------

# ===========================================================================


#
# 952
# На Флориду с 19501950 по 20172017 год всего обрушилось 235235 ураганов. В переменной florida_hurricane_dates хранится список дат, в которые произошел ураган. Сезон ураганов в Атлантике официально начинается 11 июня. Дополните приведенный ниже код, чтобы он вывел количество ураганов с 19501950 года, которые обрушились на Флориду до официального начала сезона ураганов.
# ---------------------------------------------------------------------------
# from datetime import date

# счетчик для нужного количества ураганов
early_hurricanes = 0

# цикл по датам в которые был ураган
for hurricane in florida_hurricane_dates:
    # если месяц урагана меньше чем июнь (порядковый номер 6)
    if hurricane.month < 6:
        early_hurricanes += 1

print(early_hurricanes)

# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен список dates, содержащий даты. Дополните приведенный ниже код, чтобы он вывел год и номер квартала каждой даты из данного списка. Компоненты дат должны быть расположены в исходном порядке, каждые на отдельной строке, в следующем формате:
# <год>-Q<номер квартала>
#
# 958
# ---------------------------------------------------------------------------

dates = [date(2010, 9, 28), date(2017, 1, 13), date(2009, 12, 25), date(2010, 2, 27), date(2021, 10, 11), date(
    2020, 3, 13), date(2000, 7, 7), date(1999, 4, 14), date(1789, 11, 19), date(2013, 8, 21), date(1666, 6, 6), date(1968, 5, 26)]

dict1 = {(1, 2, 3): 1,
         (4, 5, 6): 2,
         (7, 8, 9): 3,
         (10, 11, 12): 4}

for i in dates:
    for key, value in dict1.items():
        if i.month in key:
            print(f'{i.year}-Q{value}')

# -----------препод--------------------------------------------------------
# from datetime import date

dates = [date(2010, 9, 28), date(2017, 1, 13), date(2009, 12, 25), date(2010, 2, 27), date(2021, 10, 11), date(
    2020, 3, 13), date(2000, 7, 7), date(1999, 4, 14), date(1789, 11, 19), date(2013, 8, 21), date(1666, 6, 6), date(1968, 5, 26)]

for d in dates:
    print(f'{d.year}-Q{(d.month - 1) // 3 + 1}')
# ===========================================================================


# Функция get_min_max()
# 956
# Реализуйте функцию get_min_max(), которая принимает один аргумент:
#     dates — список дат (тип date)
# Функция должна возвращать кортеж, первым элементом которого является минимальная дата из списка dates, вторым — максимальная дата из списка dates. Если список dates пуст, функция должна вернуть пустой кортеж.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию get_min_max(), но не код, вызывающий ее.
# Примечание 2. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------
# from datetime import date

def get_min_max(dates):
    if dates:
        return (min(dates), max(dates))
    return tuple()
# ---------------------------------------------------------------------------


def get_min_max(dates):
    if dates:
        return min(dates), max(dates)
    return ()
# ===========================================================================


def get_min_max(dates):
    return (min(dates), max(dates)) if dates else tuple()
# ===========================================================================


# Функция get_date_range()
# 939
# Реализуйте функцию get_date_range(), которая принимает два аргумента в следующем порядке:

    # start — начальная дата, тип date
    # end — конечная дата, тип date

# Функция get_date_range() должна возвращать список, состоящий из дат(тип date) от start до end включительно. Если start > end, функция должна вернуть пустой список.
# ---------------------------------------------------------------------------


def get_date_range(start, end):
    if start <= end:
        return list(map(lambda x: date.fromordinal(x), range(start.toordinal(), end.toordinal() + 1)))
    return []


date1 = date(2021, 10, 1)
date2 = date(2021, 10, 5)

print(*get_date_range(date1, date2), sep='\n')
# ---------------------------------------------------------------------------


def get_date_range(start, end):
    return [date.fromordinal(i) for i in range(start.toordinal(), end.toordinal() + 1)]
# ===========================================================================


# Функция saturdays_between_two_dates()
# 922
# # Реализуйте функцию saturdays_between_two_dates(), которая принимает два аргумента в следующем порядке:
#     start — начальная дата, тип date
#     end — конечная дата, тип date
# Функция должна возвращать количество суббот между датами start и end включительно.
# ---------------------------------------------------------------------------

# from datetime import date

def saturdays_between_two_dates(start, end):
    if start > end:
        start, end = end, start

    return sum([1 for i in range(start.toordinal(), end.toordinal() + 1) if date.fromordinal(i).weekday() == 5])


date1 = date(2021, 11, 1)
date2 = date(2021, 11, 22)

print(saturdays_between_two_dates(date1, date2))
# ---------------------------------------------------------------------------

# ===========================================================================


# 976
# В переменной florida_hurricane_dates хранится список дат (тип date), в которые произошел ураган во Флориде с 19501950 по 20172017 год.

# Дополните приведенный ниже код, чтобы он вывел самую раннюю дату из списка florida_hurricane_dates в трех различных форматах:
#     в стандарте ISO (YYYY-MM-DD)
#     в типичном для России стиле (DD.MM.YYYY)
#     в типичном для Америки стиле (MM/DD/YYYY)
# Примечание 1. Считайте, что переменная florida_hurricane_dates объявлена и доступна вашей программе.
# Примечание 2. Считайте, что тип date уже импортирован в программу.
# ---------------------------------------------------------------------------

# from datetime import date

# присваиваем самую раннюю дату урагана в переменную first_date
first_date = min(florida_hurricane_dates)

# конвертируем дату в ISO и RU формат
iso = 'Дата первого урагана в ISO формате: ' + first_date.isoformat()
ru = 'Дата первого урагана в RU формате: ' + first_date.strftime('%d.%m.%Y')
us = 'Дата первого урагана в US формате: ' + first_date.strftime('%m/%d/%Y')

print(iso)
print(ru)
print(us)

# ---------------------------------------------------------------------------

# ===========================================================================


# Ураган Эндрю, который обрушился на Флориду 2424 августа 19921992 года, был одним из самых дорогостоящих и смертоносных ураганов в истории США. Дополните приведенный ниже код, чтобы он вывел дату 2424 августа 19921992 года в трех различных форматах:
# в формате YYYY-MM
# в формате month_name (YYYY), где month_name – полное название месяца на английском
# в формате YYYY-day_number, где day_number – день года
# 976
#
# ---------------------------------------------------------------------------

# from datetime import date

andrew = date(1992, 8, 24)

print(andrew.strftime('%Y-%m'))   # выводим дату в формате YYYY-MM
print(andrew.strftime('%B (%Y)'))   # выводим дату в формате month_name (YYYY)
print(andrew.strftime('%Y-%j'))   # выводим дату в формате YYYY-day_number

# ---------------------------------------------------------------------------

# ===========================================================================


# Две даты
# 977
# # Напишите программу, которая принимает на вход две даты и выводит ту, что меньше.
# Формат входных данных
# На вход программе подаются две корректные даты в ISO формате (YYYY-MM-DD), каждая на отдельной строке.

# Формат выходных данных
# Программа должна выбрать из двух введенных дат меньшую и вывести ее в формате DD-MM (YYYY).
# ---------------------------------------------------------------------------

lst = [date.fromisoformat(f'{input()}') for _ in range(2)]

print(min(lst).strftime('%d-%m (%Y)'))

# ---------------------------------------------------------------------------

# ===========================================================================


# Отсортированные даты
# 975
# Напишите программу, которая принимает на вход последовательность дат и выводит их в порядке неубывания.
# Формат входных данных
# На вход программе подается натуральное число nn, а затем nn корректных дат в ISO формате (YYYY-MM-DD), каждая на отдельной строке.
# Формат выходных данных
# Программа должна вывести введенные даты в порядке неубывания, каждую на отдельной строке, в формате DD/MM/YYYY.
# Примечание 1. Последовательность называется неубывающей, если каждый ее следующий член не меньше предыдущего, например:
# 1,1,2,3,4,4,4,5,6,...
# Обратите внимание, что такая последовательность не является возрастающей.
# Примечание 2. Считайте, что при форматировании даты с помощью %Y год выводится без ведущих нулей, так как на серверах Stepik установлен Linux.
# Примечание 3. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------

# from datetime import date

n = int(input())
date_lst = [date.fromisoformat(input()).toordinal() for i in range(n)]
date_lst1 = sorted(date_lst)
date_lst2 = [date.fromordinal(i).strftime('%d/%m/%Y') for i in date_lst1]

print(*date_lst2, sep='\n')
# ========================препод===========================================
# from datetime import date
dates = [date.fromisoformat(input()) for _ in range(int(input()))]

for d in sorted(dates):
    print(d.strftime('%d/%m/%Y'))
# ---------------------------------------------------------------------------


# Функция print_good_dates()
# 971
# # имур считает дату «интересной», если её год совпадает с годом его рождения, а сумма номера месяца и номера дня равна его возрасту. Год рождения Тимура — 19921992, возраст — 2929 лет.
# Реализуйте функцию print_good_dates(), которая принимает один аргумент:
#     dates — список дат (тип date)
# Функция должна выводить «интересные» даты в порядке возрастания, каждую на отдельной строке, в формате  month_name DD, YYYY, где month_name — полное название месяца на английском.
# Примечание 1. Если в функцию передается пустой список или список без интересных дат, функция ничего не должна выводить.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию print_good_dates(), но не код, вызывающий ее.
# Примечание 3. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------

# from datetime import date

def print_good_dates(dates):
    lst = []
    for el in dates:
        if el.year == 1992 and el.month + el.day == 29:
            lst.append(el)

    for el in sorted(lst):
        print(el.strftime('%B %d, %Y'))


# dates = [date(1992, 10, 19), date(1991, 12, 6), date(1992, 9, 20)]
# print_good_dates(dates)
# -------------------------препод-----------------------------------------
def print_good_dates(dates):
    for d in sorted(filter(lambda d: d.year == 1992 and d.month + d.day == 29, dates)):
        print(d.strftime('%B %d, %Y'))
# ===========================================================================


# Функция is_correct()
# 984
# Реализуйте функцию is_correct(), которая принимает три аргумента в следующем порядке:
#     day — натуральное число, день
#     month — натуральное число, месяц
#     year — натуральное число, год
# Функция должна возвращать True, если дата с компонентами day, month и year является корректной, или False в противном случае.
# Примечание 1. Вспомните про конструкцию try-except.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_correct(), но не код, вызывающий ее.
# Примечание 3. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------

# from datetime import date

def is_correct(day, month, year):
    try:
        if (date(year, month, day)):
            return True

    except ValueError:
        return False

# print(is_correct(31, 12, 2021))
# ---------------препод-----------------------------------------------


def is_correct(day, month, year):
    try:
        date(year, month, day)
        return True
    except:
        return False
# ===========================================================================


# Корректные даты
# 966
# Напишите программу, которая принимает на вход последовательность дат и проверяет каждую из них на корректность.
# Формат входных данных
# На вход программе подается последовательность дат в формате DD.MM.YYYY, каждая на отдельной строке. Концом последовательности является слово end.
# Формат выходных данных
# Программа должна для каждой введенной даты вывести текст Корректная или Некорректная в зависимости от того, является ли дата корректной, а затем вывести количество корректных дат.
# Примечание 1. Для анализа даты на корректность можете использовать уже реализованную функцию is_correct() из предыдущей задачи.
# ---------------------------------------------------------------------------

# from datetime import date

def is_correct(day, month, year):
    try:
        date(year, month, day)
        return True
    except:
        return False


lst = []

c = input()
cnt = 0
while c != 'end':
    l1 = c .split('.')
    if is_correct(int(l1[0]), int(l1[1]), int(l1[2])):
        print('Корректная')
        cnt += 1
    else:
        print('Некорректная')
    c = input()

print(cnt)
# ---------------------препод---------------------------------------


def is_correct(day, month, year):
    try:
        date(year, month, day)
        return True
    except ValueError:
        return False


counter = 0
some_date = input()

while some_date != 'end':
    if is_correct(*map(int, some_date.split('.'))):
        print('Корректная')
        counter += 1
    else:
        print('Некорректная')
    some_date = input()

print(counter)
# ===========================================================================

#
# 982
# Дополните приведенный ниже код, чтобы в переменной dt содержался объект типа datetime с датой и временем, которые указаны в строке text.
# ---------------------------------------------------------------------------
# from datetime import datetime

text = 'Уважаемый пациент, доктор готов принять Вас 15.07.2022 в 08:30'

dt = datetime.strptime(
    text, 'Уважаемый пациент, доктор готов принять Вас %d.%m.%Y в %H:%M')

print(dt)

# ---------------------------------------------------------------------------

# ===========================================================================

# Дополните приведенный ниже код, чтобы он преобразовал секунды seconds (прошедшие от начала эпохи) в объект datetime и, наоборот, объект datetime в секунды (прошедшие от начала эпохи).
# 997
#
# ---------------------------------------------------------------------------
# from datetime import datetime

seconds = 2483228800
dt = datetime(2011, 11, 4)

print(datetime.fromtimestamp(seconds))
print(dt.timestamp())

# ---------------------------------------------------------------------------

# ===========================================================================


# 982
# ам доступен список times_of_purchases, содержащий даты (тип datetime), в которые были совершены покупки в некотором интернет-магазине. Дополните приведенный ниже код, чтобы он вывел текст До полудня, если большее число покупок было совершено до полудня, или текст После полудня в противном случае.
# Примечание 1. Гарантируется, что ни одна покупка не была совершена ровно в 12:00:00.
# Примечание 2. Гарантируется, что до полудня и после полудня совершено различное количество покупок.
#
# ---------------------------------------------------------------------------
# from datetime import datetime, time

times_of_purchases = [datetime(2017, 10, 1, 12, 23, 25), datetime(2017, 10, 1, 15, 26, 26),
                      datetime(2017, 10, 1, 15, 42, 57), datetime(
                          2017, 10, 1, 17, 49, 59),
                      datetime(2017, 10, 2, 6, 37, 10), datetime(
                          2017, 10, 2, 6, 42, 53),
                      datetime(2017, 10, 2, 8, 56, 45), datetime(
                          2017, 10, 2, 9, 18, 3),
                      datetime(2017, 10, 2, 12, 23, 48), datetime(
                          2017, 10, 2, 12, 45, 5),
                      datetime(2017, 10, 2, 12, 48, 8), datetime(
                          2017, 10, 2, 12, 10, 54),
                      datetime(2017, 10, 2, 19, 18, 10), datetime(
                          2017, 10, 2, 12, 31, 45),
                      datetime(2017, 10, 3, 20, 57, 10), datetime(
                          2017, 10, 4, 7, 4, 57),
                      datetime(2017, 10, 4, 7, 13, 31), datetime(
                          2017, 10, 4, 7, 13, 42),
                      datetime(2017, 10, 4, 7, 21, 54), datetime(
                          2017, 10, 4, 14, 22, 12),
                      datetime(2017, 10, 4, 14, 50), datetime(
                          2017, 10, 4, 15, 7, 27),
                      datetime(2017, 10, 4, 12, 44, 49), datetime(
                          2017, 10, 4, 12, 46, 41),
                      datetime(2017, 10, 4, 16, 32, 33), datetime(
                          2017, 10, 4, 16, 34, 44),
                      datetime(2017, 10, 4, 16, 46, 59), datetime(2017, 10, 4, 12, 26, 6)]

l1 = list(filter(lambda x: x.time() < time(12, 0, 0), times_of_purchases))

l2 = list(filter(lambda x: x.time() > time(12, 0, 0), times_of_purchases))

if len(l1) > len(l2):
    print('До полудня')
else:
    print('После полудня')
# ---------------------------------------------------------------------------
dts = [d.strftime('%p') for d in times_of_purchases]
print(['До полудня', 'После полудня'][dts.count('PM') > dts.count('AM')])
# ===========================================================================

print('До полудня'
      if len(list(filter(lambda x: x.hour < 12, times_of_purchases)))/len(times_of_purchases) > 0.5
      else 'После полудня')

# 973
# Вам доступны список dates, содержащий даты, и список times, содержащий времена. Количество элементов в этих списках одинаковое. Дополните приведенный ниже код, чтобы он вывел datetime объекты, полученные путем объединения элементов списков dates и times, находящихся на одинаковых позициях. Полученные объекты должны быть расположены в порядке возрастания секунд, каждый на отдельной строке.
#
# ---------------------------------------------------------------------------
# from datetime import date, time, datetime

dates = [date(1793, 8, 23), date(1410, 3, 11), date(804, 11, 12), date(632, 6, 4),
         date(295, 1, 23), date(327, 8, 24), date(
             167, 4, 16), date(229, 1, 24),
         date(1239, 2, 5), date(1957, 7, 14), date(197, 8, 24), date(479, 9, 6)]

times = [time(7, 33, 27), time(21, 2, 10), time(17, 20, 47), time(20, 8, 59),
         time(12, 42, 56), time(15, 9, 57), time(17, 47, 9), time(9, 40, 2),
         time(11, 47, 1), time(17, 27, 10), time(17, 55, 40), time(9, 14, 9)]

datetimes = [datetime.combine(d, t) for d, t in zip(dates, times)]

print(*sorted(new_datetime, key=lambda x: x.second), sep='\n')


# ---------------------------------------------------------------------------
datetimes = list(map(datetime.combine, dates, times))
print(*sorted(datetimes, key=lambda x: x.second), sep='\n')
# ===========================================================================


# 959
# Ученики онлайн-школы BEEGEEK решили выяснить, кто из них быстрее всех решит домашнее задание по математике. Для этого каждый ученик зафиксировал время начала и окончания решения своей домашней работы.
# Вам доступен словарь data, содержащий результаты учеников. Ключом в словаре является имя ученика, а значением — кортеж, первый элемент которого — время начала решения, второй элемент — время окончания решения. Дополните приведенный ниже код, чтобы он вывел имя ученика, который затратил на решение домашнего задания меньше всего времени.
# Примечание 1. Гарантируется, что искомый ученик единственный.
# Примечание 2. Дата-времена в кортежах представлены в виде строк в формате DD.MM.YYYY HH:MM:SS.
# ---------------------------------------------------------------------------
# from datetime import datetime

data = {'Дима': ('03.11.2021 09:31:18', '03.11.2021 11:41:28'),
        'Геор': ('01.11.2021 09:03:04', '01.11.2021 12:40:35'),
        'Анна': ('02.11.2021 04:41:54', '02.11.2021 05:39:40'),
        'Илина': ('02.11.2021 01:36:40', '02.11.2021 04:48:27'),
        'Герман': ('04.11.2021 07:51:19', '04.11.2021 09:53:53'),
        'Руслан': ('01.11.2021 11:26:06', '01.11.2021 12:56:24'),
        'Лера': ('03.11.2021 11:09:41', '03.11.2021 14:37:41'),
        'Егор': ('03.11.2021 05:29:38', '03.11.2021 06:01:59'),
        'Максим': ('05.11.2021 13:05:03', '05.11.2021 14:27:41'),
        'Саша': ('03.11.2021 04:14:26', '03.11.2021 05:10:58'),
        'Марина': ('05.11.2021 15:21:06', '05.11.2021 18:33:46')}

for key1, value in sorted(data.items(), key=lambda x: datetime.strptime(x[1][1], '%d.%m.%Y %H:%M:%S').timestamp() - datetime.strptime(x[1][0], '%d.%m.%Y %H:%M:%S').timestamp()):
    print(key1)
    break
# ---------------------------------------------------------------------------
# from datetime import datetime

data = {'Дима': ('03.11.2021 09:31:18', '03.11.2021 11:41:28'),
        'Геор': ('01.11.2021 09:03:04', '01.11.2021 12:40:35'),
        'Анна': ('02.11.2021 04:41:54', '02.11.2021 05:39:40'),
        'Илина': ('02.11.2021 01:36:40', '02.11.2021 04:48:27'),
        'Герман': ('04.11.2021 07:51:19', '04.11.2021 09:53:53'),
        'Руслан': ('01.11.2021 11:26:06', '01.11.2021 12:56:24'),
        'Лера': ('03.11.2021 11:09:41', '03.11.2021 14:37:41'),
        'Егор': ('03.11.2021 05:29:38', '03.11.2021 06:01:59'),
        'Максим': ('05.11.2021 13:05:03', '05.11.2021 14:27:41'),
        'Саша': ('03.11.2021 04:14:26', '03.11.2021 05:10:58'),
        'Марина': ('05.11.2021 15:21:06', '05.11.2021 18:33:46')}


def transform_data(tuple):
    first = datetime.strptime(tuple[0], '%d.%m.%Y %H:%M:%S')
    second = datetime.strptime(tuple[1], '%d.%m.%Y %H:%M:%S')
    return (second - first).seconds


print(min(data, key=lambda x: transform_data(data[x])))
# ===========================================================================


# Дневник космонавта 🌶️
# 795
# Вам доступен текстовый файл diary.txt, в который космонавт записывал небольшие отчёты за день. Каждый новый отчёт он мог записать либо в начало файла, либо в середину, либо в конец. Все отчеты разделены между собой пустой строкой. Каждый новый отчёт начинается со строки с датой и временем в формате DD.MM.YYYY; HH:MM, после которой следуют события, произошедшие за указанный день:
# Напишите программу, которая расставляет все записи космонавта в хронологическом порядке и выводит полученный результат.
# ---------------------------------------------------------------------------

# from datetime import datetime

with open('diary.txt', 'rt') as file1:
    diary = file1.read().split('\n\n')


l1 = sorted(diary, key=lambda x: datetime.strptime(x[:17], '%d.%m.%Y; %H:%M'))
print(*l1, sep='\n\n')
# ------------------ПРЕПОД---------------------------------------------------------
# from datetime import datetime

notes = {}
pattern = '%d.%m.%Y; %H:%M'

with open('diary.txt', encoding='utf-8') as file:
    diary = file.read().split('\n\n')

for note in diary:
    dt, text = note.split('\n', 1)
    dt = datetime.strptime(dt, pattern)
    notes[dt] = text

for dt, text in sorted(notes.items()):
    print(dt.strftime(pattern))
    print(text)
    print()
# ===========================================================================
# from datetime import datetime

with open('diary.txt', 'r', encoding='utf-8') as f:
    text = f.read().split('\n\n')
dct = {}
for line in text:
    key, *val = line.split('\n')
    dct[datetime.strptime(key, '%d.%m.%Y; %H:%M')] = '\n'.join(val)
for key, val in sorted(dct.items()):
    print(datetime.strftime(key, '%d.%m.%Y; %H:%M'))
    print(val)
    print()
# ===========================================================================


#  Функция is_available_date() 🌶️
# 789
# Во время визита очередного гостя сотрудникам отеля приходится проверять, доступна ли та или иная дата для бронирования номера.
# Реализуйте функцию is_available_date(), которая принимает два аргумента в следующем порядке:
#     booked_dates — список строковых дат, недоступных для бронирования. Элементом списка является либо одиночная дата, либо период (две даты через дефис). Например:
#     ['04.11.2021', '05.11.2021-09.11.2021']
#     date_for_booking — одиночная строковая дата или период (две даты через дефис), на которую гость желает забронировать номер. Например:
#     '01.11.2021' или '01.11.2021-04.11.2021'
# Функция is_available_date() должна возвращать True, если дата или период date_for_booking полностью доступна для бронирования. В противном случае функция должна возвращать False.
# Примечание 1. Гарантируется, что в периоде левая дата всегда меньше правой.
# Примечание 2. В периоде (две даты через дефис) граничные даты включены.
# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_available_date(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
# from datetime import date, datetime, timedelta

def is_available_date(booked_dates, date_for_booking):

    pattern = '%d.%m.%Y'
# ====================список уже забронированных дат=========================================
    l1 = []
    for el in booked_dates:

        if len(el) == 10:
            l1.append(datetime.strptime(el, pattern))

        elif len(el) != 10:
            lst1 = [datetime.strptime(i, pattern) for i in el.split('-')]
            date1 = lst1[0]
            while date1 != lst1[1] + timedelta(days=1):
                l1.append(date1)
                date1 += timedelta(days=1)

# =======================список желаемых для бронирования=====================================
    l2 = []

    if len(date_for_booking) == 10:
        l2.append(datetime.strptime(date_for_booking, pattern))

    elif len(date_for_booking) != 10:
        lst2 = [datetime.strptime(i, pattern)
                for i in date_for_booking.split('-')]
        date2 = lst2[0]
        while date2 != lst2[1] + timedelta(days=1):
            l2.append(date2)
            date2 += timedelta(days=1)

    # ===============возвращаем проверку занятости желаемых для бронирования дат=====
    return len(list(filter(lambda x: x not in l1, l2))) == len(l2)

# ------------комменты-------------------------------------------------------
# from datetime import datetime


def is_available_date(booked_dates, date_for_booking):
    date1 = [[datetime.strptime(j, '%d.%m.%Y')
              for j in i.split('-')]for i in booked_dates]
    date2 = [(datetime.strptime(i, '%d.%m.%Y'))
             for i in date_for_booking.split('-')]
    f = True
    for d in date1:
        if max(date2) < min(d) or min(date2) > max(d):
            continue
        else:
            f = False
            break
    return f
# ===========================================================================


#
# 985
# Дополните приведенный ниже код, чтобы он прибавил к объекту datetime(2021, 11, 4, 13, 6) одну неделю и 1212 часов и вывел результат в формате DD.MM.YYYY HH:MM:SS.
# ---------------------------------------------------------------------------
# from datetime import datetime, timedelta

dt = datetime(2021, 11, 4, 13, 6) + timedelta(weeks=1, hours=12)

print(dt.strftime('%d.%m.%Y %H:%M:%S'))

# ---------------------------------------------------------------------------

# ===========================================================================


#
# 990
# ополните приведенный ниже код, чтобы он вывел количество дней (целое число) между датами today и birthday.
# ---------------------------------------------------------------------------
# from datetime import datetime, date, timedelta

today = date(2021, 11, 4)
birthday = date(2022, 10, 6)

days = birthday - today
print(days)
print(days.total_seconds() // (3600 * 24))

# ---------------------------------------------------------------------------
# from datetime import date, timedelta

today = date(2021, 11, 4)
birthday = date(2022, 10, 6)

days = abs(today - birthday).days

print(days)
# ===========================================================================


# Предыдущая и следующая даты
# 974
# Напишите программу, которая принимает на вход дату и выводит предыдущую и следующую даты.
# Формат входных данных
# На вход программе подается дата в формате DD.MM.YYYY.
# Формат выходных данных
# Программа должна вывести предыдущую и следующую даты относительно введенной даты, каждую на отдельной строке, в формате DD.MM.YYYY.
# Примечание 1. Гарантируется, что у подаваемой даты есть предыдущая и следующая даты.
# ---------------------------------------------------------------------------
# from datetime import datetime, timedelta


pattern = '%d.%m.%Y'

dt2 = datetime.strptime(input(), pattern)

dt3 = dt2 - timedelta(days=1)
dt4 = dt2 + timedelta(days=1)

print(dt3.strftime(pattern))
print(dt4.strftime(pattern))


# ---------------------------------------------------------------------------
# from datetime import datetime, timedelta

pattern, td = '%d.%m.%Y', timedelta(days=1)

dt = datetime.strptime(input(), pattern)

print((dt - td).strftime(pattern))
print((dt + td).strftime(pattern))
# ===========================================================================


# Количество секунд
# 980
# Напишите программу, которая принимает на вход время и выводит целое количество секунд, прошедшее с начала суток.
# Формат входных данных
# На вход программе подается время в формате HH:MM:SS.
# Формат выходных данных
# Программа должна вывести целое количество секунд, прошедшее с начала суток.
# Примечание 1. Началом суток считается момент времени, соответствующий 00:00:00.
# ---------------------------------------------------------------------------
# from datetime import datetime

tm = datetime.strptime(input(), '%H:%M:%S')
start_time = tm.replace(hour=0, minute=0, second=0)

print((tm - start_time).seconds)

# -----------------ПРЕПОД--------------------------------------------------
# from datetime import datetime, timedelta

h, m, s = map(int, input().split(':'))
td = timedelta(hours=h, minutes=m, seconds=s)

dt1 = datetime.strptime(input(), '%H:%M:%S')
time2 = (dt1 + td).time()

print(time2)
# ===========================================================================


# Таймер
# 974
# Часы показывают время в формате HH:MM:SS. На этих часах запустили таймер, который прозвенит через nn секунд. Напишите программу, которое определит, какое время будет на часах, когда прозвенит таймер.
# Формат входных данных
# На вход программе в первой строке подается текущее время на часах в формате HH:MM:SS. В следующей строке вводится целое неотрицательное число nn — количество секунд, через которое должен прозвенеть таймер.
# Формат выходных данных
# Программа должна вывести время в формате HH:MM:SS, которое будет на часах, когда прозвенит таймер.
# ---------------------------------------------------------------------------
# from datetime import datetime, timedelta

dt1 = datetime.strptime(input(), '%H:%M:%S')
td = timedelta(seconds=int(input()))

time2 = (dt1 + td).time()
print(time2)
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция num_of_sundays()
# 928
# Реализуйте функцию num_of_sundays(), которая принимает на вход один аргумент:
#     year — натуральное число, год
# Функция должна возвращать количество воскресений в году year.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию num_of_sundays(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
# from datetime import date, timedelta

def num_of_sundays(year1):
    d1 = date(year1, 1, 1)
    d2 = d1
    td = timedelta(days=7)

    while d2.weekday() != 6:
        d2 += timedelta(days=1)

    cnt = 1
    d3 = d2 + td
    #
    while d3.year == year1:
        d3 += td
        if d3.weekday() == 6:
            cnt += 1

    return cnt
# --------------------ПРЕПОД-------------------------------------------


def num_of_sundays(year):
    counter, td = 0, timedelta(days=7)
    d = date(year, 1, 1)
    d += timedelta(days=6 - d.weekday())
    while d.year == year:
        d += td
        counter += 1
    return counter
# ===========================================================================


# Продуктивность
# 954
# Артуру нужно подготовить 1010 задач для нового курса "ООП на Python". Чтобы занятие не оказалось утомительным, он придумал правило:
#     если сегодня он подготовил первую задачу, то вторую он должен подготовить через один день
#     если сегодня он подготовил вторую задачу, то третью он должен подготовить через два дня
#     если сегодня он подготовил третью задачу, то четвертую он должен подготовить через три дня
#     и так далее
# Напишите программу, которая определяет даты, в которые Артуру нужно подготовить задачи.
# Формат входных данных
# На вход программе подается дата подготовки первой задачи в формате DD.MM.YYYY.
# Формат выходных данных
# Программа должна вывести 1010 дат, удовлетворяющих условию задачи, каждую на отдельной строке, в формате DD.MM.YYYY.
# ---------------------------------------------------------------------------
# from datetime import date, datetime, timedelta

d, m, y = input().split('.')

date1 = date(int(y), int(m), int(d))
td1 = timedelta(days=1)
print(date1.strftime('%d.%m.%Y'))

for i in range(2, 11):
    td2 = td1 * i
    date1 = date1 + td2
    print(date1.strftime('%d.%m.%Y'))

# ---------------ПРЕПОД--------------------------------------------------
# from datetime import datetime, timedelta

pattern = '%d.%m.%Y'
dt = datetime.strptime(input(), pattern) - timedelta(days=1)

for i in range(1, 11):
    dt += timedelta(days=i)
    print(dt.strftime(pattern))
# ===========================================================================
s = 'Python'
dict1 = {}
for i, dict1[i] in enumerate(s, 1):
    i = 10

print(dict1)
# ---------------------------------------------------------------------------


# Соседние даты
# 937
# Дана последовательность дат. Напишите программу, которая создает и выводит список, элементами которого являются неотрицательные целые числа — количество дней между двумя соседними датами последовательности.

# Формат входных данных
# На вход программе подается последовательность дат, разделенных пробелом, в формате DD.MM.YYYY.

# Формат выходных данных
# Программа должна вывести список, содержащий неотрицательные целые числа, каждое из которых — количество дней между двумя соседними датами последовательности.

# Примечание 1. Даты в последовательности могут располагаться в произвольном порядке, то есть не гарантируется, что следующая дата больше предыдущей.

# Примечание 2. Если последовательность состоит из одной даты, то программа должна вывести пустой список.

# Примечание 3. Рассмотрим второй тест, в котором подается последовательность из пяти дат. Определим элементы результирующего списка:

#     первый элемент — 11, количество дней между датами 06.10.2021 и 05.10.2021
#     второй элемент — 33, количество дней между датами 05.10.2021 и 08.10.2021
#     третий элемент — 11, количество дней между датами 08.10.2021 и 09.10.2021
#     четвертый элемент — 22, количество дней между датами 09.10.2021 и 07.10.2021

# ---------------------------------------------------------------------------

# from datetime import date, timedelta

ds = []
for el in input().split():
    dd, mm, yy = list(map(int, (el.split('.'))))
    ds.append(date(yy, mm, dd))

tds = []
for i in range(len(ds) - 1):
    tds.append(abs(ds[i] - ds[i + 1]).days)

print(tds)
# ---------------------------------------------------------------------------

pattern = "%d.%m.%Y"
l = list(map(lambda x: datetime.strptime(x, pattern), input().split()))

dif = [abs(x - l[i]).days for i, x in enumerate(l[1:])]

print(dif)
# ====================ПРЕПОД=============================================

dates = [datetime.strptime(dt, '%d.%m.%Y') for dt in input().split()]
diffs = [abs(dates[i] - dates[i-1]).days for i in range(1, len(dates))]

print(diffs)
# ====================ПРЕПОД=============================================

# Функция fill_up_missing_dates()
# 929
# Реализуйте функцию fill_up_missing_dates(), которая принимает на вход один аргумент:
#     dates — список строковых дат в формате DD.MM.YYYY
# Функция должна возвращать список, в котором содержатся все даты из списка dates, расположенные в порядке возрастания, а также все недостающие промежуточные даты.
# Примечание 1. Рассмотрим первый тест. Список dates содержит период с 01.11.2021 по 07.11.2021:
# dates = ['01.11.2021', '07.11.2021', '04.11.2021', '03.11.2021']
# в котором отсутствуют даты 02.11.2021, 05.11.2021, 06.11.2021. Тогда вызов функции:
# fill_up_missing_dates(dates)
# должен вернуть список:
# ['01.11.2021', '02.11.2021', '03.11.2021', '04.11.2021', '05.11.2021', '06.11.2021', '07.11.2021']
# Примечание 2. Функция должна создавать и возвращать новый список, а не изменять переданный.
# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию fill_up_missing_dates(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------


def fill_up_missing_dates(dates):
    days_set = {datetime.strptime(i, '%d.%m.%Y') for i in dates}

    td = timedelta(days=1)
    (el, el_last) = min(days_set), max(days_set)

    while el != el_last:
        days_set.add(el)
        el += td

    return [i.strftime('%d.%m.%Y') for i in sorted(days_set)]


# dates = ['01.11.2021', '07.11.2021', '04.11.2021', '03.11.2021']
# print(fill_up_missing_dates(dates))

# -----------------------ПРЕПОД----------------------------------------
def fill_up_missing_dates(dates):
    pattern = '%d.%m.%Y'
    dates = [datetime.strptime(d, pattern) for d in dates]
    start, end = min(dates), max(dates)
    days = (end - start).days
    return [(start + timedelta(days=i)).strftime(pattern) for i in range(days + 1)]
# ===========================================================================


# Реп по матеше
# 898
# Репетитор по математике проводит занятия по 4545 минут с перерывами по 1010 минут. Репетитор обозначает время начала рабочего дня и время окончания рабочего дня. Напишите программу, которая генерирует и выводит расписание занятий.
# Формат входных данных
# На вход программе в первой строке подается время начала рабочего дня в формате HH:MM. В следующей строке вводится время окончания рабочего дня в том же формате.
# Формат выходных данных
# Программа должна сгенерировать и вывести расписание занятий. На первой строке выводится время начала и окончания первого занятия в формате HH:MM - HH:MM, на второй строке — время начала и окончания второго занятия в том же формате, и так далее.
# Примечание 1. Если занятие обрывается временем окончания работы, то добавлять его в расписание не нужно.
# Примечание 2. Если разница между временем начала и окончания рабочего дня меньше 4545 минут, программа ничего не должна выводить.
# ---------------------------------------------------------------------------

# from datetime import datetime, timedelta

start = datetime.strptime(input(), '%H:%M')
end = datetime.strptime(input(), '%H:%M')

td = timedelta(minutes=45)

while end - start >= td:
    end_lesson = start + td
    print(f'{start.strftime("%H:%M")} - {end_lesson.strftime("%H:%M")}')
    start = end_lesson + timedelta(minutes=10)
# ---------------------------------------------------------------------------
# Для f-строки НЕОБЯЗАТЕЛЬНО ИСПОЛЬЗОВАТЬ STRFTIME
# from datetime import datetime, timedelta, time

start_time = datetime.strptime(input(), '%H:%M')
end_time = datetime.strptime(input(), '%H:%M')
lesson_time, rest_time = timedelta(minutes=45), timedelta(minutes=10)

while (new_time := start_time + lesson_time) <= end_time:
    print(f'{start_time:%H:%M} - {new_time:%H:%M}')
    start_time += lesson_time + rest_time
# ===========================================================================


# Во время решения очередной задачи программист фиксирует время начала и окончания ее решения и добавляет полученные результаты в список data.
# Каждый результат представляет собой кортеж, первым элементом которого является время начала решения в виде строки в формате HH:MM,
# вторым элементом — время окончания решения в виде строки в том же формате. Дополните приведенный ниже код, чтобы он вывел общее целое количество минут,
# которое программист затратил на решение всех задач.
# 842
#
# ---------------------------------------------------------------------------
# from datetime import date, time, datetime, timedelta

data = [('07:14', '08:46'),
        ('09:01', '09:37'),
        ('10:00', '11:43'),
        ('12:13', '13:49'),
        ('15:00', '15:19'),
        ('15:58', '17:24'),
        ('17:57', '19:21'),
        ('19:30', '19:59')]
td = 0
for el in data:
    td += (datetime.strptime(el[1], '%H:%M') -
           datetime.strptime(el[0], '%H:%M'))

print(int(td/60))
#  ---------------------------------------------------------------------------

# ===========================================================================


# Пятница, 13-е
# 923
# Число 1313 считалось дьявольским издавна. Это имеет свое объяснение, и не одно: тут есть трактовки, связанные с Тайной вечерей — где были Христос и 1212 апостолов, один из которых стал предателем. Есть поверье, что для шабаша нужны 1212 ведьм и сатана. В истории число 1313 в связке с пятницей стало «несчастливым» в 13071307 году, когда король Франции Филипп Красивый отдал приказ схватить всех тамплиеров — членов рыцарского ордена крестоносцев. Все они были сожжены на кострах инквизиции, и произошло это в пятницу, 1313 апреля.
# Докажите, что 1313-е число месяца чаще всего приходится на пятницу. Напишите программу, которая вычисляет, сколько тринадцатых чисел приходится на каждый день недели в период с 01.01.0001 по 31.12.9999.
# Формат входных данных
# На вход программе ничего не подается.
# Формат выходных данных
# Программа должна вывести 77 чисел — количество тринадцатых чисел, которые приходятся на понедельник, вторник, среду, четверг, пятницу, субботу и воскресенье в период с 01.01.0001 по 31.12.9999. Числа должны быть расположены каждое на отдельной строке.
# ---------------------------------------------------------------------------
# from datetime import date, datetime, timedelta

dict1 = {}
# достаточно пробежаться двумя циклами по всем месяцам и посчитать все 13-ые числа.
# Время выполнения программы --- 0.03218412399291992 seconds ---
for yy in range(1, 10000):
    for mm in range(1, 13):
        d = datetime(day=13, month=mm, year=yy)
        dict1[d.isoweekday()] = dict1.setdefault(d.isoweekday(), 0) + 1


for key, value in sorted(dict1.items()):
    print(value)

# ---------------------------------------------------------------------------
# from datetime import datetime

day_weeks = {num: 0 for num in range(1, 8)}
# достаточно пробежаться двумя циклами по всем месяцам и посчитать все 13-ые числа.
# Время выполнения программы --- 0.03218412399291992 seconds ---
for year in range(1, 10_000):
    for month in range(1, 13):
        day_weeks[datetime(day=13, month=month, year=year).isoweekday()] += 1

print(*day_weeks.values(), sep='\n')
# ===========================================================================


# Снова не успел
# 913
# Дан режим работы магазина:
# Понедельник 	9:00 - 21:00
# Вторник 	9:00 - 21:00
# Среда 	9:00 - 21:00
# Четверг 	9:00 - 21:00
# Пятница 	9:00 - 21:00
# Суббота 	10:00 - 18:00
# Воскресенье 	10:00 - 18:00
# Напишите программу, которая принимает на вход текущие дату и время и определяет количество минут, оставшееся до закрытия магазина.
# Формат входных данных
# На вход программе подаются текущие дата и время в формате DD.MM.YYYY HH:MM.
# Формат выходных данных
# Программа должна вывести количество минут, которое осталось до закрытия магазина, или текст Магазин не работает, если он закрыт.
# ---------------------------------------------------------------------------

# from datetime import date, datetime, timedelta

dt = datetime.strptime(input(), '%d.%m.%Y %H:%M')
date1 = dt.date()
dict1 = {1: ('09:00', '21:00'),
         2: ('09:00', '21:00'),
         3: ('09:00', '21:00'),
         4: ('09:00', '21:00'),
         5: ('09:00', '21:00'),
         6: ('10:00', '18:00'),
         7: ('10:00', '18:00')
         }

day1 = dt.isoweekday()
opened = datetime.combine(
    date1, (datetime.strptime(dict1[day1][0], '%H:%M').time()))
closed = datetime.combine(
    date1, (datetime.strptime(dict1[day1][1], '%H:%M').time()))

if opened <= dt < closed:
    delta = closed - dt
    print(delta.seconds // 60)
else:
    print('Магазин не работает')
# ---------------------------------------------------------------------------

# from datetime import datetime, timedelta

dt = datetime.strptime(input(), '%d.%m.%Y %H:%M')
td = timedelta(hours=dt.hour, minutes=dt.minute)

if dt.weekday() < 5 and timedelta(hours=9) <= td < timedelta(hours=21):
    print(int((timedelta(hours=21) - td).total_seconds() // 60))
elif dt.weekday() > 4 and timedelta(hours=10) <= td < timedelta(hours=18):
    print(int((timedelta(hours=18) - td).total_seconds() // 60))
else:
    print('Магазин не работает')
# ===========================================================================


# Самое понятное условие
# 855
# Даны две даты — левая и правая границы диапазона соответственно. Напишите программу, которая из этого диапазона, включая границы, выводит, начиная с даты, у которой сумма дня и месяца нечетная, каждую третью дату, только если она не понедельник и не четверг.
# Формат входных данных
# На вход программе подаются две даты в формате DD.MM.YYYY — левая и правая границы диапазона соответственно, каждая на отдельной строке. Гарантируется, что первая дата не больше второй.
# Формат выходных данных
# Программа должна из указанного диапазона, включая концы, вывести, начиная с даты, у которой сумма дня и месяца нечетная, каждую третью дату, только если она не понедельник и не четверг. Даты должны быть расположены каждая на отдельной строке, в формате DD.MM.YYYY.
# Примечание 1. Если дат, удовлетворяющих условию, нет, программа ничего не должна выводить.
# Примечание 2. Рассмотрим второй тест. Левая граница диапазона 07.03.2021 не является начальной датой, так как имеет четную сумму дня и месяца, поэтому в качестве начальной берем следующую дату 08.03.2021. Дата 08.03.2021 не выводится, так как является понедельником, поэтому двигаемся к следующей дате с шагом три: 11.03.2021. Дата 11.03.2021 не выводится, так как является четвергом.
# ---------------------------------------------------------------------------


# from datetime import date, datetime, timedelta

d1 = datetime.strptime(input(), '%d.%m.%Y').date()
d2 = datetime.strptime(input(), '%d.%m.%Y').date()
lst = []
# =========заполняем множество дат==============
d = d1
while d <= d2:
    lst.append(d)
    d += timedelta(days=1)

# =========ищем первую нечетную==========================
lst = sorted(lst)
# print(*lst, sep='\n')

for el in lst:
    if (el.day + el.month) % 2 == 1:
        d = el
#        print('d=', d)
        break
# =======начинаем с первой нечетной выводить неПН или неЧТ==========
ind = lst.index(d)
# print('ind=', ind)

# print(list(range(ind, len(lst), 3)))

for i in range(ind, len(lst), 3):
    # print(lst[i].isoweekday())
    if lst[i].isoweekday() not in (1, 4):
        print(lst[i].strftime('%d.%m.%Y'))

# ------------------ПРЕПОД-------------------------------------------------
# from datetime import datetime, timedelta

pattern = '%d.%m.%Y'
start = datetime.strptime(input(), pattern)
end = datetime.strptime(input(), pattern)

while not (start.month + start.day) % 2:
    start += timedelta(days=1)

while start <= end:
    week = start.isoweekday()
    if week in (2, 3, 5, 6, 7):
        print(start.strftime(pattern))
    start += timedelta(days=3)
# ---------------------------------------------------------------------------


# Сотрудники организации 😄
# 911
# Дан список сотрудников организации, в котором указаны их фамилии, имена и даты рождения. Напишите программу, которая определяет самого старшего сотрудника из данного списка.
# Формат входных данных
# На вход программе в первой строке подается натуральное число nn — количество сотрудников, работающих в организации. В последующих nn строках вводятся данные о каждом сотруднике: имя, фамилия и дата рождения, разделённые пробелом. Дата рождения указывается в формате DD.MM.YYYY.
# Формат выходных данных
# Программа должна определить самого старшего сотрудника и вывести его дату рождения, имя и фамилию, разделив пробелом. Если таких сотрудников несколько, программа должна вывести их дату рождения, а также их количество, разделив пробелом.
# Примечание 1. Гарантируется, что у всех сотрудников имена и фамилии различны.
# ---------------------------------------------------------------------------

# from datetime import date, timedelta, datetime

lst1 = []
dict1 = {}

for i in range(int(input())):
    lst1.append(input().split())
    lst1[i][2] = datetime.strptime(lst1[i][2], '%d.%m.%Y')

    str1 = f'{lst1[i][0]} {lst1[i][1]}'
    dict1.setdefault(lst1[i][2], []).append(str1)

for key, value in sorted(dict1.items(), key=lambda x: x[0]):
    if len(value) == 1:
        print(datetime.strftime(key, '%d.%m.%Y'), *value)
    else:
        print(datetime.strftime(key, '%d.%m.%Y'), len(value))
    break
# ---------------------------------------------------------------------------
# from datetime import datetime, timedelta

data = {}
youngest = datetime.max
pattern = '%d.%m.%Y'

for _ in range(int(input())):
    *name, birthday = input().split()
    name, birthday = ' '.join(name), datetime.strptime(birthday, pattern)
    if birthday < youngest:
        youngest = birthday
    data[name] = birthday

oldest = [name for name, bd in data.items() if bd == youngest]

if len(oldest) > 1:
    print(youngest.strftime(pattern), len(oldest))
else:
    print(youngest.strftime(pattern), oldest[0])
# ===========================================================================


# Сотрудники организации 🙂
# 890
# Дан список сотрудников организации, в котором указаны их фамилии, имена и даты рождения. Напишите программу, которая определяет, в какую из дат родилось больше всего сотрудников.
# Формат входных данных
# На вход программе в первой строке подается натуральное число nn — количество сотрудников, работающих в организации. В последующих nn строках вводятся данные о каждом сотруднике: имя, фамилия и дата рождения, разделённые пробелом. Дата рождения указывается в формате DD.MM.YYYY.
# Формат выходных данных
# Программа должна вывести дату, в которую наибольшее количество сотрудников отмечает день рождения, в формате DD.MM.YYYY. Если таких дат несколько, программа должна вывести их все в порядке возрастания, каждую на отдельной строке, в том же формате.
# ---------------------------------------------------------------------------

# from datetime import datetime

pattern = '%d.%m.%Y'
dict1 = {}

for _ in range(int(input())):
    *name, birthday = input().split()
    bd = datetime.strptime(birthday, pattern)
    dict1[bd] = dict1.setdefault(bd, 0) + 1

lst1 = []
for key, value in sorted(dict1.items(), key=lambda x: x[1], reverse=True):
    if value == max(dict1.values()):
        lst1.append(key)
    else:
        break

for el in sorted(lst1):
    print(datetime.strftime(el, pattern), sep='\n')
# ---------------------ПРЕПОД----------------------------------------------
# from datetime import datetime, timedelta

dates = {}
pattern = '%d.%m.%Y'
counter = 0

for _ in range(int(input())):
    *_, birthday = input().split()  # т.к. имя и фамилия не используются
    # birthday = input().split()[-1]
    birthday = datetime.strptime(birthday, pattern)
    dates[birthday] = dates.get(birthday, 0) + 1
    if dates[birthday] > counter:
        counter = dates[birthday]

frequent_dates = [dt for dt, amount in dates.items() if amount == counter]

for dt in sorted(frequent_dates):
    print(dt.strftime(pattern))
# ===========================================================================


# Сотрудники организации 😔
# 823
# Дан список сотрудников организации, в котором указаны их фамилии, имена и даты рождения. Напишите программу, которая определяет самого молодого сотрудника,
#  празднующего свой день рождения в течение ближайших семи дней от текущей даты.
# Формат входных данных
# На вход программе в первой строке подается текущая дата в формате DD.MM.YYYY, в следующей строке вводится натуральное число nn — количество сотрудников, работающих в организации. В последующих nn строках вводятся данные о каждом сотруднике: имя, фамилия и дата рождения, разделённые пробелом. Дата рождения указывается в формате DD.MM.YYYY.
# Формат выходных данных
# Программа должна определить самого молодого сотрудника, празднующего свой день рождения в течение ближайших семи дней, и вывести его имя и фамилию, разделив пробелом. Если таких сотрудников нет, программа должна вывести текст:
# Дни рождения не планируются
# ---------------------------------------------------------------------------

# from datetime import date, datetime, timedelta

pattern = '%d.%m.%Y'
today = datetime.strptime(input(), pattern).date()

n = int(input())

dict1 = {}
lst1 = []

for _ in range(n):
    *name, bd = input().split()
    bd = datetime.strptime(bd, pattern).date()
    td_age = (today - bd).days

    lst1.append((name[0] + ' ' + name[1], bd, td_age))

lst1 = sorted(lst1, key=lambda x: x[2])

today1 = datetime(day=today.day, month=today.month,
                  year=lst1[0][1].year).date()

seven_days = [(today1 + timedelta(days=(1 + i))) for i in range(7)]
# print(seven_days)

# for el in lst1:
#     a, b, c = el
#     print(str(a).ljust(15), '|', str(b.strftime(pattern)).ljust(12), '|', str(c).ljust(5))
#     print('-' * 38)

res = ''
flag = False
for el in lst1:
    for i in seven_days:
        if el[1].day == i.day and el[1].month == i.month:
            res = el[0]
            print(res)
            flag = True
            break
    if flag:
        break

if not res:
    print('Дни рождения не планируются')
# ---------------------------------------------------------------------------

# ===========================================================================

# FAKE NEWS 🌶️
# 759
# Команда BEEGEEK планирует выпустить свой новый курс 08.11.2022 ровно в 12:00. Напишите программу, которая принимает на вход текущие дату и время и определяет, сколько времени осталось до выхода курса.

# Формат входных данных
# На вход программе подаются текущие дата и время в формате DD.MM.YYYY HH:MM.
# Формат выходных данных
# Программа должна вывести текст с указанием количества дней и часов, оставшихся до выхода курса, в следующем формате:
# До выхода курса осталось: <кол-во дней> дней и <кол-во часов> часов
# Если в данном случае количество часов равно нулю, то вывести нужно только дни.
# Если количество дней равно нулю, то вывести нужно только часы и минуты в следующем формате:
# До выхода курса осталось: <кол-во часов> часов и <кол-во минут> минут
# Если в данном случае количество минут равно нулю, то вывести нужно только часы. Аналогично, если количество часов равно нулю, то вывести нужно только минуты.
# Если введенные дата и время больше либо равны 08.11.2022 12:00, программа должна вывести текст:
# Курc уже вышел!
# Примечание 1. Программа должна подбирать правильную форму для существительных «день» и «минута». Для этого можете смело взять свою функцию choose_plural() из этой задачи.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------тгь 0
# ===========================================================================

# Функция calculate_it()
# 936
# Реализуйте функцию calculate_it(), которая принимает один или более аргументов в следующем порядке:
#     func — произвольная функция
#     *args — переменное количество позиционных аргументов, каждый из которых является произвольным объектом
# Функция должна возвращать кортеж, первым элементом которого является возвращаемое значение функции func при вызове с аргументами *args, а вторым — примерное время (в секундах), затраченное на вычисление этого значения.
# Примечание 1. Например, если функция add() определена так:
# def add(a, b, c):
#     time.sleep(3)
#     return a + b + c
# то вызов
# calculate_it(add, 1, 2, 3)
# должен вернуть кортеж (6, 3.000720262527466), где 6 — результат вызова add(1, 2, 3), а 3.000720262527466 — примерное время работы функции add() в секундах.
# ---------------------------------------------------------------------------
# import time


def calculate_it(func, *args):
    start_time = time.perf_counter()

    res = func(*args)

    end_time = time.perf_counter()
    elapsed_time = end_time - start_time

    return res, elapsed_time


# start_time = time.perf_counter()

# for i in range(5):
#     print(i)
#     time.sleep(1)

# end_time = time.perf_counter()

# elapsed_time = end_time - start_time
# print(f'Время работы программы = {elapsed_time}')
# ---------------ПРЕПОД--------------------------------------------------
def calculate_it(func, *args):
    start = time.perf_counter()
    value = func(*args)
    end = time.perf_counter()
    return value, end - start
# ===========================================================================

# Функция get_the_fastest_func()
# 919
# Реализуйте функцию get_the_fastest_func(), которая принимает два аргумента в следующем порядке:
#     funcs — список произвольных функций
#     arg — произвольный объект
# Функция get_the_fastest_func() должна возвращать функцию из списка funcs, которая затратила на вычисление значения при вызове с аргументом arg наименьшее количество времени.
# ---------------------------------------------------------------------------
# import time


def get_the_fastest_func(funcs, arg):

    res = []
    for el in funcs:
        start = time.perf_counter()
        value = el(arg)
        end = time.perf_counter()

        res.append((el, end - start))

    res = sorted(res, key=lambda x: x[1])

    return res[0][0]
# ---------------------------------------------------------------------------


def calculate_it(func, arg):
    start = time.perf_counter()
    value = func(arg)
    end = time.perf_counter()
    return end - start


def get_the_fastest_func(funcs, arg):
    times = {}
    for func in funcs:
        times[func] = calculate_it(func, arg)
    return min(times, key=lambda time: times[time])
# ===========================================================================

# dам доступны три реализации функции, которая вычисляет факториал числа nn:
#     встроенная из модуля math
#     рекурсивная
#     итеративная
# Выясните, какая функция быстрее вычислит факториал числа 900900.
# 982#
# ==================================================
# ==================================================

# ВЕРНО, ТАК КАК ВСТРОЕННАЯ ФУНКЦИЯ FACTORIAL() РЕАЛИЗОВАНА НА ЯЗЫКЕ c,
# ОНА ПРЕВОСХОДИТ ПО БЫСТРОДЕЙСТВИЮ ЛЮБУЮ СОБСТВЕННУЮ РЕАЛИЗАЦИЮ.

# ==================================================
# ==================================================
#
# # ---------------------------------------------------------------------------
# import math               # функция из модуля math
# import time


def factorial_math(n):
    return math.factorial(n)


def factorial_recurrent(n):                  # рекурсивная функция
    if n == 0:
        return 1
    return n * factorial_recurrent(n - 1)


def factorial_classic(n):                    # итеративная функция
    f = 1
    for i in range(2, n + 1):
        f *= i
    return f

# ===========


def get_the_fastest_func(funcs_lst, number):

    res = []
    for el in funcs_lst:
        start = time.perf_counter()
        value = el(number)
        end = time.perf_counter()

        res.append((el, end - start))

    res = sorted(res, key=lambda x: x[1])

    return res


# ===============================================
num = 900
funcs1 = [factorial_recurrent, factorial_classic, factorial_math]

# вызов нашей функции подсчета времени выполнения
print(*get_the_fastest_func(funcs1, num), sep='\n')
# ---------------------------------------------------------------------------

# ===========================================================================

# Вам доступны две реализации функции, которая создает и возвращает список из чисел от 11 до 10 000 00010000000 включительно:
#     с использованием цикла for и метода append()
#     с использованием списочного выражения
# Определите, какая функция быстрее создаст и вернет требуемый список.
# 982
# ==================================================
# ==================================================

# кАК УЖЕ УПОМИНАЛОСЬ В ПРЕДЫДУЩИХ КУРСАХ,
# СПИСОЧНЫЕ ВЫРАЖЕНИЯ ЯВЛЯЮТСЯ ПРЕДПОЧТИТЕЛЬНЫМ СПОСОБОМ СОЗДАНИЯ СПИСКОВ, НЕЖЕЛИ ИСПОЛЬЗОВАНИЕ ЦИКЛА FOR И МЕТОДА APPEND().

# ==================================================
# ==================================================
#
# ---------------------------------------------------------------------------

# import time


def for_and_append():                            # с использованием цикла for и метода append()
    iterations = 10_000_000
    result = []
    for i in range(iterations):
        result.append(i + 1)
    return result


def list_comprehension():                        # с использованием списочного выражения
    iterations = 10_000_000
    return [i + 1 for i in range(iterations)]
# ---------------------------------------------------------------------------


def get_the_fastest_func(funcs_lst, number):

    res = []
    for el in funcs_lst:
        start = time.perf_counter()
        value = el(number)
        end = time.perf_counter()

        res.append((el, end - start))

    res = sorted(res, key=lambda x: x[1])

    return res


# =========ВЫЗОВ+=================================================
funcs1 = [for_and_append, list_comprehension]
print(*get_the_fastest_func(funcs1), sep='\n')
# ===========================================================================

# Вам доступны три реализации функции, которая принимает в качестве аргумента итерируемый объект и возвращает список, элементами которого являются элементы переданного итерируемого объекта:
#     с использованием цикла for и метода append()
#     с использованием списочного выражения
#     с использованием встроенной функции list()
# Определите, какая функция быстрее создаст и вернет список на основе итерируемого объекта range(100_000).
#
# 982
# ==================================================
# ==================================================

# в СЛУЧАЕ ЕСЛИ ТРЕБУЕТСЯ СОЗДАТЬ СПИСОК НА ОСНОВЕ ИТЕРИРУЕМОГО ОБЪЕКТА ИЛИ КОЛЛЕКЦИИ БЕЗ КАКОГО-ЛИБО ИЗМЕНЕНИЯ ЭЛЕМЕНТОВ,
# ТО ЛУЧШИМ ВАРИАНТОМ БУДЕТ ФУНКЦИЯ LIST().

# ==================================================
# ==================================================

# ---------------------------------------------------------------------------
# import time


def for_and_append(iterable):             # с использованием цикла for и метода append()
    result = []
    for elem in iterable:
        result.append(elem)
    return result


def list_comprehension(iterable):         # с использованием списочного выражения
    return [elem for elem in iterable]


def list_function(iterable):              # с использованием встроенной функции list()
    return list(iterable)
# ---------------------------------------------------------------------------


def get_the_fastest_func(funcs_lst, num):

    res = []
    for el in funcs_lst:
        start = time.perf_counter()
        value = el(num)
        end = time.perf_counter()

        res.append((el, end - start))

    res = sorted(res, key=lambda x: x[1])

    return res


# =========ВЫЗОВ+=================================================
funcs1 = [for_and_append, list_comprehension, list_function]
print(*get_the_fastest_func(funcs1, range(100_000)), sep='\n')
# ---------------------------------------------------------------------------

# ===========================================================================

# Високосный год
# Напишите программу, которая определяет, является ли год високосным.

# Формат входных данных
# На вход программе в первой строке подается целое число nn, в последующих nn строках вводятся натуральные числа, представляющие года.

# Формат выходных данных
# Программа должна для каждого введенного года вывести True, если он является високосным, или False в противном случае.

# ---------------------------------------------------------------------------
# import calendar

for _ in range(int(input())):
    print(calendar.isleap(int(input())))
# ---------------------------------------------------------------------------

# ===========================================================================

# Календарь на месяц
# Напишите программу, которая выводит календарь на заданные год и месяц.

# Формат входных данных
# На вход программе подаются год и сокращенное название месяца на английском, разделенные пробелом.

# Формат выходных данных
# Программа должна вывести календарь на введенные год и месяц.
# #
# ---------------------------------------------------------------------------
# import calendar
y, m = input().split()

l1 = list(calendar.month_abbr)
ind = l1.index(m)
print(calendar.month(int(y), ind))
# ---------------------------------------------------------------------------
# from calendar import prmonth
# from datetime import datetime

dt = datetime.strptime(input(), '%Y %b')
prmonth(dt.year, dt.month)


# ===========================================================================
# import calendar

lst, month = list(calendar.month_abbr), input().split()
data = {i: lst.index(i) for i in lst}

print(calendar.month(int(month[0]), data[month[1]]))
# ===========================================================================

# 968
# День недели
# Напишите программу, которая определяет день недели, соответствующий заданной дате.
# Формат входных данных
# На вход программе подается дата в формате YYYY-MM-DD.
# Формат выходных данных
# Программа должна вывести полное название дня недели на английском, который соответствует введенной дате.
# ---------------------------------------------------------------------------
# import calendar
# from datetime import datetime

dt = datetime.strptime(input(), '%Y-%m-%d')
num_week_day = calendar.weekday(dt.year, dt.month, dt.day)

print(num_week_day.day_name)

# # ---------------------------------------------------------------------------
# import calendar
# from datetime import datetime
dt = datetime.fromisoformat(input())
print(list(calendar.day_name)[dt.weekday()])
# ===========================================================================

# Количество дней 😉
# Напишите программу, которая определяет количество дней в заданном месяце.
# 965
# ---------------------------------------------------------------------------
# from datetime import datetime
# import calendar

today = datetime.strptime(input(), '%Y %m')
days = calendar.monthrange(today.year, today.month)[1]
print(days)
# ---------------------------------------------------------------------------

year, number = map(int, input().split())
days = calendar.monthrange(year, number)[1]

print(days)
# ===========================================================================

# Количество дней 😎
# 969
# Напишите программу, которая определяет количество дней в заданном месяце.
# Формат входных данных
# На вход программе подаются год и полное название месяца на английском, разделенные пробелом.
# Формат выходных данных
# Программа должна вывести единственное число — количество дней в введенном месяце.
# ---------------------------------------------------------------------------
# from datetime import datetime
# import calendar

dt = datetime.strptime(input(), '%Y %B')
days = calendar.monthrange(dt.year, dt.month)[1]

print(days)
# ---------------------------------------------------------------------------
# from datetime import datetime
# import calendar

year, month = input().split()
month = list(calendar.month_name).index(month)

print(calendar.monthrange(int(year), int(month))[1])
# ===========================================================================

# Функция get_days_in_month()
# 934
# Реализуйте функцию get_days_in_month(), которая принимает два аргумента в следующем порядке:
#     year — натуральное число
#     month — полное название месяца на английском
# Функция должна возвращать отсортированный по возрастанию список всех дат (тип date) месяца month и года year.
# ---------------------------------------------------------------------------
# from datetime import datetime
# import calendar


def get_days_in_month(year, month):
    dt = datetime.strptime(f'{year} {month}', '%Y %B')
    amount_days = calendar.monthrange(dt.year, dt.month)[1]

    return [(dt.replace(day=i)).date() for i in range(1, amount_days + 1)]
# ------------------------ПРЕПОД--------------------------------------------


def get_days_in_month(year, month):
    month = list(calendar.month_name).index(month)
    return [date(year, month, day) for day in range(1, calendar.monthrange(year, month)[1] + 1)]
# ===========================================================================


# Функция get_all_mondays()
#  899
# Реализуйте функцию get_all_mondays(), которая принимает один аргумент:
#     year — натуральное число
# Функция должна возвращать отсортированный по возрастанию список всех дат (тип date) года year, выпадающих на понедельник.
# ---------------------------------------------------------------------------


def get_all_mondays(year):
    dt = datetime(year, 1, 1)

    if calendar.isleap(year):
        num = 366
    else:
        num = 365

    lst1 = []
    for i in range(num):
        dt1 = dt + timedelta(days=i)

        if calendar.weekday(dt1.year, dt1.month, dt1.day) == 0:
            lst1.append(dt1.date())

    return lst1
# print(get_all_mondays(2021))
# ---------------------------------------------------------------------------


def get_all_mondays(year):
    mondays = []
    for month in range(1, 13):
        for week in calendar.monthcalendar(year, month):
            monday = week[0]
            if monday:
                mondays.append(date(year, month, monday))
    return mondays
# ===========================================================================

# ТЧМ
# 870
# Во многих музеях существует один день месяца, когда посещение музея для всех лиц или отдельных категорий граждан происходит без взимания платы. Например, в Эрмитаже это третий четверг месяца.
# Напишите программу, которая определяет даты бесплатных дней посещения Эрмитажа в заданном году.
# Формат входных данных
# На вход программе подается натуральное число, представляющее год.
# Формат выходных данных
# Программа должна определить все даты бесплатных дней посещения Эрмитажа в введенном году и вывести их. Даты должны быть расположены в порядке возрастания, каждая на отдельной строке, в формате DD.MM.YYYY.
# ---------------------------------------------------------------------------
# from datetime import datetime, date, timedelta
# import calendar


def get_all_tchm(year):

    t_ch_m = []

    count = 0

    for month in range(1, 13):
        for week in calendar.monthcalendar(year, month):
            thu = week[3]
            if thu:
                count += 1
                if count == 3:
                    t_ch_m.append(date(year, month, thu).strftime('%d.%m.%Y'))
                    count = 0
                    break
    return t_ch_m


print(*get_all_tchm(int(input())), sep='\n')
# ---------препод----------------------------------------------------------

free_days = []
year = int(input())

for i in range(1, 13):
    c = calendar.monthcalendar(year, i)
    first_week = c[0]
    third_week = c[2]
    fourth_week = c[3]
    if first_week[calendar.THURSDAY]:
        free_day = third_week[calendar.THURSDAY]
    else:
        free_day = fourth_week[calendar.THURSDAY]
    free_days.append(datetime(year, i, free_day))

for day in free_days:
    print(day.strftime('%d.%m.%Y'))

# ==============без calendar================
# from datetime import datetime
year = int(input())
for month in range(1, 13):
    day = datetime(year, month, 1)
    print(datetime(year, month, (3 - day.weekday()) %
          7 + 15).strftime('%d.%m.%Y'))
#
# ---------------------------------------------------------------------------
# from datetime import date
# from dateutil.relativedelta import relativedelta, TH


def get_third_th(y):
    return list(map(lambda w: w.strftime('%d.%m.%Y'), [date(y, m, 1) + relativedelta(weekday=TH(3)) for m in range(1, 13)]))


# Обратный порядок
# 904
# Напишите программу, которая принимает произвольное количество строк и в каждой введенной строке располагает все символы в обратном порядке.
# Формат входных данных
# На вход программе подается произвольное количество строк.
# Формат выходных данных
# Программа должна вывести все введенные строки, предварительно расположив в каждой строке все символы в обратном порядке.
# Примечание 1. Порядок вывода строк должен совпадать с порядком их ввода.
# Примечание 2. Если на вход программе ничего не подается, то она ничего не должна выводить.
# ---------------------------------------------------------------------------
# import sys
data = list(map(str.strip, sys.stdin))
for el in data:
    print(el[::-1])
# ---------------------------------------------------------------------------
# from sys import stdin

[print(i.strip('\n')[::-1]) for i in stdin]
# ---------------------------------------------------------------------------
# sys.stdin и sys.stdout — это файловые объекты для ввода и вывода информации. Потоки нужны, когда мы не знаем, сколько информации поступит от пользователя. Можно ввести одну строку, а можно 501. Если мы точно не знаем, сколько их будет, тогда и нужно использовать потоки. А затем уже можно работать с полученой информацией так, как это будет необходимо.
# print() и input() — это функции, которые так же используют потоковый вывод и ввод соответственно, по сути являясь удобной обёрткой для работы с ним. Их можно использовать тогда, когда нам изв
# ===========================================================================

# Размах данных
# 900
# Дана последовательность дат. Напишите программу, которая выводит количество дней между максимальной и минимальной датами данной последовательности.
# Формат входных данных
# На вход программе подается произвольное количество строк, в каждой строке записана дата в ISO формате (YYYY-MM-DD).
# Формат выходных данных
# Программа должна вывести единственное число — количество дней между максимальной и минимальной датами введенной последовательности.
# ---------------------------------------------------------------------------
# import sys
# from datetime import datetime, timedelta

data = list(map(str.strip, sys.stdin))

date = list(map(lambda x: datetime.strptime(x, '%Y-%m-%d'), data))

td = max(date) - min(date)
print(td.days)
# ---------------------------------------------------------------------------
# from sys import stdin
# from datetime import datetime

lst = list(map(lambda x: datetime.strptime(
    x.strip(), '%Y-%m-%d'), stdin.readlines()))

print((max(lst) - min(lst)).days)
# ===========================================================================

# Лемма о трёх носках
# 916
# Анри и Дима, имея на руках ящик с бесконечным количеством носков, решили сыграть в игру. Ребята по очереди достают из ящика произвольное количество носков, и после неопределенного числа ходов игра заканчивается. Если тот, кто сделал последний ход, вытащил четное количество носков — он побеждает, в противном случае проигрывает.
# Напишите программу, которая определяет победителя в данной игре, если первый ход делает Анри.
# Формат входных данных
# На вход программе подается произвольное количество строк, в каждой строке записано натуральное число — количество носков, которые вытащил один из игроков.
# Формат выходных данных
# Программа должна определить победителя в игре, правила которой представлены в условии задачи, и вывести его имя.
# Примечание 1. Рассмотрим первый тест. Распишем ходы игроков:
#     Анри — 11
#     Дима — 33
#     Анри — 55
#     Дима — 1010
#     Анри — 33
#     Дима — 22
#     Анри — 1212
# Побеждает Анри, так как он делает последний ход и при этом достает четное количество носков. Причем общее количество не важно, важно лишь количество в последнем ходе.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================

# Урок статистики
# 951
# Дан список чисел, каждое из которых — рост очередного ученика онлайн-школы BEEGEEK. Напишите программу, которая определяет рост самого низкого и самого высокого учеников, а также средний рост среди всех учеников.
# Формат входных данных
# На вход программе подается произвольное количество строк, в каждой строке записано натуральное число — рост очередного ученика онлайн-школы BEEGEEK.
# Формат выходных данных
# Программа должна определить рост самого низкого и самого высокого учеников, а также средний рост среди всех учеников.
# Полученные результаты должны быть выведены в следующем формате:
# Рост самого низкого ученика: <рост самого низкого ученика>
# Рост самого высокого ученика: <рост самого высокого ученика>
# Средний рост: <средний рост среди всех учеников>
# ---------------------------------------------------------------------------


# С помощью потока ввода (sys.stdin) можно в одну строчку кода прочитать весь пользовательский ввод в список.
# data = list(map(str.strip, sys.stdin))

data = list(map(int, sys.stdin))
# data = [int(i) for i in sys.stdin]
if data:
    print(f'Рост самого низкого ученика: {min(data)}')
    print(f'Рост самого высокого ученика: {max(data)}')
    print(f'Средний рост: {sum(data) / len(data)}')
else:
    print('нет учеников')


# ---------------------------------------------------------------------------

data = [int(line.strip()) for line in sys.stdin]

if data:
    print(f'Рост самого низкого ученика: {min(data)}\n'
          f'Рост самого высокого ученика: {max(data)}\n'
          f'Средний рост: {sum(data) / len(data)}')
else:
    print('нет учеников')
# ===========================================================================


# Комментатор
# 955
# Дан блок кода на языке Python. Напишите программу, которая определяет количество строк в данном коде, которые содержат в себе только комментарии. Если в строке помимо комментария имеется что-то еще, то такую строку учитывать не нужно.

# Формат входных данных
# На вход программе подается произвольное количество строк, в совокупности представляющих блок кода на языке Python.

# Формат выходных данных
# Программа должна вывести единственное число — количество строк в введенном коде, которые содержат в себе только комментарии.
# ---------------------------------------------------------------------------

# import sys

# data = list(map(str, sys.stdin))
data = [line.strip() for line in sys.stdin if line.strip()[0] == '#']

print(len(data))

# -----------------ПРЕПОД-----------------------------------------------

# import sys
print(sum(line.lstrip().startswith('#') for line in sys.stdin))
# ===========================================================================

# Без комментариев
# 944
# Дан блок кода на языке Python. Напишите программу, которая удаляет все строки в данном коде, которые содержат в себе только комментарии. Если в строке помимо комментария имеется что-то еще, то такую строку учитывать не нужно.
# Формат входных данных
# На вход программе подается произвольное количество строк, в совокупности представляющих блок кода на языке Python.
# Формат выходных данных
# Программа должна вывести введенный блок кода, предварительно удалив из него все строки которые содержат в себе только комментарии.
# Примечание 1. Порядок вывода строк кода должен совпадать с порядком их ввода.
# Примечание 2. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------
# import sys

data = [line for line in sys.stdin if not line.strip().startswith('#')]

print(*data, sep='')
# ------------------ПРЕПОД----------------------------------------------

for line in sys.stdin:
    if not line.lstrip().startswith('#'):
        print(line.rstrip())
# ===========================================================================

# Панорамное агентство
# 894
# По чатам одного немалоизвестного мессенджера начали появляться новости сомнительного содержания. Оказалось, что некий молодежный клуб решил подшутить, распространяя всякие глупости. Однако подобное хулиганство мешает доверчивым людям, особенно пенсионного возраста, поэтому группа независимых программистов решила разработать бота, который мог бы оценить степень достоверности новости, а также отнести её к какой-либо категории.

# Напишите программу, которая выводит все новости заданной категории, располагая их по возрастанию степени достоверности.

# Формат входных данных
# На вход программе подается произвольное количество строк, в каждой строке, кроме последней, записана новость, категория, к которой она относится, и ее достоверность в следующем формате:

# <новость> / <категория> / <достоверность>

# В последней строке подается одиночная категория.

# Формат выходных данных
# Программа должна вывести все новости, которые относятся к введенной категории. Новости должны быть расположены в порядке возрастания степени достоверности, а при совпадении степеней достоверности — в лексикографическом порядке самих новостей.
# ---------------------------------------------------------------------------
# import sys

lst = []
for line in sys.stdin:
    lst.append(line.strip().split(' / '))

word = lst.pop()

# отсортируем список по алфавиту
lst.sort()
# затем отсортируем по значению рейтинга
for el in sorted(lst, key=lambda x: x[2]):
    if el[1] == word[0]:
        print(el[0])


# -------------------препод--------------------------------------------
# import sys
# СОРТИРОВКА КОРТЕжЕЙ
events, priority_tag = {}, None

for line in sys.stdin:
    line = line.strip().split(' / ')
    if len(line) > 1:
        event, tag, score = line
        events.setdefault(tag, []).append((score, event))
    else:
        priority_tag = line[0]

for _, event in sorted(events[priority_tag]):
    print(event)
# ===========================================================================

# Это точно Python?
# 893
# Дана последовательность дат. Напишите программу, которая определяет, в каком порядке расположены даты в данной последовательности.

# Формат входных данных
# На вход программе подается произвольное количество строк (две или более), в каждой строке записана дата в формате DD.MM.YYYY.

# Формат выходных данных
# Программа должны вывести текст:

#     ASC, если даты в введенной последовательности расположены строго в порядке возрастания
#     DESC, если даты в введенной последовательности расположены строго в порядке убывания
#     MIX, если даты в введенной последовательности расположены ни в порядке возрастания, ни в порядке убывания

#     Параметры ASC и DESC используются в языке SQL для сортировки по возрастанию и по убыванию соответственно.
# ---------------------------------------------------------------------------


# from datetime import datetime
# import sys
content = map(str.strip, sys.stdin)

date_lst = [datetime.strptime(i, '%d.%m.%Y') for i in content]

# короче, это написали в условии, но косвенно, невнимательный человек может не заметить, но если у вас значения повторяются - то это MIX, даже если вроде бы всё стоит в поряд
if date_lst == sorted(set(date_lst)):
    print('ASC')
elif date_lst == sorted(set(date_lst), reverse=True):
    print('DESC')
else:
    print('MIX')


# ---------------------------------------------------------------------------

# ===========================================================================

# Гуру прогрессий
# 852
# Дана последовательность целых чисел. Напишите программу, которая определяет, является ли данная последовательность прогрессией, и если да, то определяет её вид.

# Формат входных данных
# На вход программе подается произвольное количество строк (не менее трёх), в каждой строке записано натуральное число — очередной член последовательности.

# Формат выходных данных
# Программа должна вывести текст:

#     Арифметическая прогрессия, если введенная последовательность чисел является арифметической прогрессией
#     Геометрическая прогрессия, если введенная последовательность чисел является геометрической прогрессией
#     Не прогрессия, если введенная последовательность чисел не является прогрессией

# Примечание 1. Гарантируется, что вид прогрессии определяется однозначно.

# Примечание 2. Подробнее об арифметичес
# ---------------------------------------------------------------------------

data = list(map(int, sys.stdin))


# ---------------------------------------------------------------------------
# тема CSV csv
# ===========================================================================

#
# 959
# Вам доступен csv файл grades.csv, имеющий следующее содержание:

# name;grade
# Timur;100
# Ruslan;97

# Найдите и исправьте ее, чтобы результатом работы программы были строки:
# ---------------------------------------------------------------------------

# import csv

with open('grades.csv', encoding='utf-8') as csv_file:
    # создаем reader объект и указываем в качестве разделителя символ ;
    rows = csv.reader(csv_file, delimiter=';')
    # выводим каждую строку
    for row in rows:
        print(row)
# ---------------------------------------------------------------------------

# ===========================================================================

#
#
# При попытке выполнить приведенную ниже программу возникает ошибка. Найдите и исправьте ее, чтобы программа создала файл writing_test.csv, имеющий следующее содержание:
# first_col,second_col
# value1,value2
# ---------------------------------------------------------------------------
# import csv

with open('writing_test.csv', 'w', encoding='utf-8') as csv_file:
    # создаем writer объект и указываем названия столбцов
    writer = csv.DictWriter(csv_file, fieldnames=['first_col', 'second_col'])
    # записываем первую строку с названиями столбцов
    writer.writeheader()
    # записываем строку с данными
    writer.writerow({'first_col': 'value1', 'second_col': 'value2'})
# ---------------------------------------------------------------------------

# ===========================================================================

# Скидки
# 960
# Наступил ноябрь, и во многих магазинах начались распродажи, но как многим известно, зачастую товары со скидкой оказываются дороже, чем без нее. Вам доступен файл sales.csv, который содержит данные о ценообразовании различной бытовой техники. В первом столбце записано название товара, во втором — старая цена, в третьем — новая цена со скидкой:

# name;old_price;new_price
# Встраиваемая посудомоечная машина De'Longhi DDW 06S;23089;31862
# Вытяжка Falmec Afrodite 60/600;27694;18001
# ...

# Напишите программу, которая выводит названия тех товаров, цена на которые уменьшилась. Товары должны быть расположены в своем исходном порядке, каждый на отдельной строке.

# Примечание 1. Разделителем в файле sales.csv является точка с запятой, при этом кавычки не используются.

# Примечание 2. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.

# Примечание 3. Начальная часть ответа выглядит так:

# Вытяжка Falmec Afrodite 60/600
# Духовой шкаф AEG BS 5836600
# Вытяжка MAUNFELD PLYM 60
# ...
# ---------------------------------------------------------------------------
# import csv

with open('sales.csv', encoding='utf-8') as file:
    rows = csv.DictReader(file, delimiter=';')

    for record in rows:
        if int(record['old_price']) > int(record['new_price']):
            print(record['name'])
# ---------------------------------------------------------------------------

# ===========================================================================

# Средняя зарплата
# 932
# Вам доступен файл salary_data.csv, который содержит анонимную информацию о зарплатах сотрудников в различных компаниях. В первом столбце записано название компании, а во втором — зарплата очередного сотрудника:

# company_name;salary
# Atos;135000
# ХайТэк;24400
# Philax;128600
# Инлайн Груп;43900
# IBS;70600
# Oracle;131600
# Atos;91000
# ...

# Напишите программу, которая упорядочивает компании по возрастанию средней зарплаты ее сотрудников и выводит их названия, каждое на отдельной строке. Если две компании имеют одинаковые средние зарплаты, они должны быть расположены в лексикографическом порядке их названий.

# Примечание 1. Средняя зарплата компании определяется как отношение суммы всех зарплат к их количеству.

# Примечание 2. Разделителем в файле salary_data.csv является точка с запятой, при этом кавычки не используются.

# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.

# Примечание 4. Начальная часть ответа выглядит так:

# Информзащита
# Форс
# OFT group
# ...

# Примечание 5. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------
# import csv

dict1 = {}
dict2 = {}
dict3 = {}

with open('salary_data.csv', encoding='utf-8') as file:
    rows = csv.DictReader(file, delimiter=';')

    for record in rows:

        key = record['company_name']
        value = record['salary']

        # считаем все зарплаты и отдельно считаем всех сотрудников
        dict1[key] = dict1.setdefault(key, 0) + int(value)
        dict2[key] = dict2.setdefault(key, 0) + 1

        # третий словарь == Ситроникс : [26042100, 315]
        dict3[key] = [dict1[key], dict2[key]]

# вычисляем среднюю зарплату
for key, value in dict3.items():
    dict3[key] = value[0] / value[1]
    # print(f'{key} : {dict3[key]}')

# сортируем по средней зарплпте
for key, value in sorted(dict3.items(), key=lambda x: x[1]):
    print(key)

# ================DictReader==================================================
# import csv

with open('salary_data.csv', encoding='utf-8') as file:
    f = csv.DictReader(file, delimiter=';')
    answer = {}
    for dct in f:
        company, salary = dct.values()
        answer[company] = answer.get(company, []) + [int(salary)]

for k, v in sorted(answer.items(), key=lambda x: sum(x[1])/len(x[1])):
    print(k)
# ---------------------------------------------------------------------------

# import csv

with open('salary_data.csv', 'r', encoding='UTF-8') as salary_file:
    d = {}
    salary_file.readline()
    reader = csv.reader(salary_file, delimiter=';')
    for i in reader:
        d[i[0]] = d.get(i[0], [])
        d[i[0]].append(int(i[1]))

print(*sorted(d, key=lambda x: sum(d[x])/len(d[x])), sep='\n')

# ---------------------------------------------------------------------------

# import csv

with open('salary_data.csv', encoding='utf-8') as csv_file:
    d = {}
    for n, s in list(csv.reader(csv_file, delimiter=';'))[1:]:
        d.setdefault(n, []).append(int(s))
    [print(i) for i in sorted(d, key=lambda x: (sum(d[x]) // len(d[x]), x))]
# ===========================================================================


# Сортировка по столбцу
# 899
# Вам доступен файл deniro.csv, каждый столбец которого содержит либо только числа, либо строковые значения:
# Machete,2010,72
# Marvin's Room,1996,80
# Raging Bull,1980,97
# ...
# Напишите программу, которая сортирует содержимое данного файла по указанному столбцу. Причем данные должны быть отсортированы в порядке возрастания чисел, если столбец содержит числа, и в лексикографическом порядке слов, если столбец содержит слова.
# Формат входных данных
# На вход программе подается натуральное число — номер столбца файла deniro.csv.
# Формат выходных данных
# Программа должна отсортировать содержимое файла deniro.csv по введенному столбцу и вывести полученный результат в исходном формате.
# Примечание 1. Нумерация столбцов начинается с единицы.
# Примечание 2. Например, если бы файл deniro.csv имел вид:
# red,4
# blue,3
# green,28
# purple,1
# и его требовалось отсортировать по второму столбцу (в порядке возрастания чисел), то программа должна была бы вывести:
# purple,1
# blue,3
# red,4
# green,28
# Примечание 3. Если две какие-либо строки имеют одинаковые значения в столбцах, то следует сохранить их исходный порядок следования.
# Примечание 4. Разделителем в файле deniro.csv является запятая, при этом кавычки не используются.
# ---------------------------------------------------------------------------

# import csv

num = int(input()) - 1

with open('deniro.csv', encoding='utf-8') as file:
    rows = csv.reader(file)

    for record in sorted(rows, key=lambda x: int(x[num]) if x[num].isdigit() else x[num]):
        print(*record, sep=',')
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция csv_columns()
# 905
# еализуйте функцию csv_columns(), которая принимает один аргумент:
#     filename — название csv файла, например, data.csv
# Функция должна возвращать словарь, в котором ключом является название столбца файла filename, а значением — список элементов этого столбца.

# Примечание 1. Гарантируется, что в передаваемом в функцию файле разделителем является запятая, при этом кавычки не используются.
# Примечание 2. Гарантируется, что у передаваемого в функцию файла первая строка содержит названия столбцов.
# Примечание 3. Например, если бы файл exam.csv имел вид:
# name,grade
# Timur,5
# Arthur,4
# Anri,5
# то следующий вызов функции csv_columns():
# csv_columns('exam.csv')
# должен был бы вернуть:
# {'name': ['Timur', 'Arthur', 'Anri'], 'grade': ['5', '4', '5']}
# Примечание 4. Ключи в словаре, а также элементы в списках должны располагаться в своем исходном порядке.
# Примечание 5. В тестирующую систему сдайте программу, содержащую только необходимую функцию csv_columns(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

# import csv


def csv_columns(filename):

    dict1 = {}

    with open(filename, encoding='utf-8') as file:
        rows = csv.DictReader(file)

        for row in rows:
            for el in row:
                dict1.setdefault(el, []).append(row[el])

    return dict1

# ------------------ПРЕПОД---------------------------------------
# import csv


def csv_columns(filename):

    with open(filename, encoding="utf-8") as file_in:
        rows = list(csv.reader(file_in))
        return {key: value for key, *value in zip(*rows)}

        # получается в результате выполнения zip(*rows)объединит элементы с одинаковыми индексами в кортежи
        # [['movie', 'year', 'rating'], ['Machete', '2010', '72'], ["Marvin's Room", '1996', '80'],...]
        # на выходе zip объект содержащий
        # ('movie', 'Machete', "Marvin's Room", ...), ('year', '2010', '1996', ...), ('rating', '72', '80', ...)
# ================import pandas as pd===========================================================
# import pandas as pd


def csv_columns(filename):
    return pd.read_csv(filename).astype(str).to_dict(orient='list')
# ===========================================================================

# Популярные домены
# 926
# Вам доступен файл data.csv, который содержит неповторяющиеся данные о пользователях некоторого ресурса. В первом столбце записано имя пользователя, во втором — фамилия, в третьем — адрес электронной почты:

# first_name,surname,email
# John,Wilson,johnwilson@outlook.com
# Mary,Wilson,marywilson@list.ru
# ...
# Напишите программу, которая создает файл domain_usage.csv, имеющий следующее содержание:
# domain,count
# rambler.ru,24
# iCloud.com,29
# ...
# где в первом столбце записано название почтового домена, а во втором — количество пользователей, использующих данный домен. Домены в файле должны быть расположены в порядке возрастания количества их использований, при совпадении количества использований — в лексикографическом порядке.
# Примечание 1. Разделителем в файле data.csv является запятая, при этом кавычки не используются.
# Примечание 2. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 3. Начальная часть файла domain_usage.csv выглядит так:
# domain,count
# rambler.ru,24
# iCloud.com,29
# ...
# Примечание 4. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------
# import csv


with open('data.csv', encoding="utf-8") as file_in:
    rows = list(csv.reader(file_in))

    rows.pop(0)
    for row in rows:
        l1 = list(map(lambda x: (x[2].split('@'))[1], rows))

    dict1 = {}

    for el in l1:
        dict1[el] = dict1.setdefault(el, 0) + 1


l2 = sorted(dict1.items())
l1 = []
for k, v in sorted(l2, key=lambda x: x[1]):
    l1.append([k, v])


with open('domain_usage.csv', 'w', encoding='utf-8', newline='') as file:
    writer11 = csv.writer(file, quoting=csv.QUOTE_NONE)

    writer11.writerow(['domain', 'count'])                 # запись заголовков
    for row in l1:                                        # запись строк
        writer11.writerow(row)

# ---------------------------------------------------------------------------
# import csv

with open('data.csv') as file, open('domain_usage.csv', 'w', newline='') as out:
    d = {}
    for i in csv.DictReader(file):
        m = i['email'].rsplit('@')[-1]
        d[m] = d.get(m, 0) + 1
    writer = csv.writer(out)
    writer.writerow(['domain', 'count'])
    writer.writerows(sorted(list(d.items()), key=lambda x: (x[1], x[0])))

# ===========================================================================
# ==================через import pandas as pd=============================================
# ===========================================================================
# import pandas as pd

df = pd.read_csv('data.csv')
df['email'] = df['email'].apply(lambda x: x[x.index('@')+1:])
df['NS'] = df['first_name'] + df['surname']
df_new = df.groupby('email', as_index=False).\
    agg({'NS': 'count'}).\
    rename(columns={'email': 'domain', 'NS': 'count'}).\
    sort_values(by=['count', 'domain'])
df_new.to_csv('domain_usage.csv', index=False)
# ===========================================================================


# Wi-Fi Москвы
# 920
# Вам доступен файл wifi.csv, который содержит данные о городском Wi-Fi Москвы. В первом столбце записано название округа, во втором — название района, в третьем — адрес, в четвертом — количество точек доступа по этому адресу:
# adm_area;district;location;number_of_access_points
# Центральный административный округ;район Якиманка;город Москва, улица Серафимовича, дом 5/16;5
# Центральный административный округ;район Якиманка;город Москва, Болотная набережная, дом 11, строение 1;2
# ...
# Напишите программу, которая определяет количество точек доступа в каждом районе Москвы и выводит названия всех районов, для каждого указывая соответствующее количество точек доступа, каждое на отдельной строке, в следующем формате:
# <название района>: <количество точек доступа>
# Названия районов должны быть расположены в порядке убывания количества точек доступа, при совпадении количества точек доступа — в лексикографическом порядке.
# Примечание 1. Разделителем в файле wifi.csv является точка с запятой, при этом кавычки не используются.
# Примечание 2. При сортировке названия районов должны быть использованы именно в том виде, в котором они указаны в исходном файле. Выполнять какие-либо дополнительные преобразования не нужно.
# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. Начальная часть ответа выглядит так:
# Тверской район: 480
# район Хамовники: 386
# Пресненский район: 349
# ...
# Примечание 5. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import csv

with open('wifi.csv', encoding='utf-8') as file_in:
    rows = csv.DictReader(file_in, delimiter=';', quotechar='"')

    l2 = rows.fieldnames
    dict1 = {}
    for row in rows:
        dict1[row[l2[1]]] = dict1.setdefault(row[l2[1]], 0) + int(row[l2[-1]])

    l1 = sorted(dict1.items())

    for key, value in sorted(l1, key=lambda x: x[1], reverse=True):
        print(f'{key}: {value}')
# ---------------------------------------------------------------------------
# import csv

with open('wifi.csv', encoding='UTF-8') as f:
    d = {}
    for r in [*csv.reader(f, delimiter=';')][1:]:
        d[r[1]] = d.get(r[1], 0) + int(r[3])
# , так и знал что такую вещь не могли не продумать и способ не сортировать 2 раза существует)
# тоже прочитал про запись (-d[x], x)), так что при сортировке по 2 критериям, если один нужен по возрастанию, а второй по убыванию очень удобная штука)))
for i in sorted(d, key=lambda x: (-d[x], x)):
    print(f'{i}: {d[i]}')
# ===========================================================================
# import csv
with open('wifi.csv', encoding='utf-8') as file:
    d = {}
    for row in csv.DictReader(file, delimiter=';'):
        d[row['district']] = d.get(
            row['district'], 0) + int(row['number_of_access_points'])
#  Для сортировки используйте sorted по двум ключам: sorted(my_dict.items(), key=lambda x: (x[1], x[0]))
    for k, v in sorted(d.items(), key=lambda x: (-x[1], x[0])):
        print(f'{k}: {v}')
# ===========================================================================


# Последний день на Титанике
# 912
# Вам доступен файл titanic.csv, который содержит данные о пассажирах, присутствовавших на борту парохода Титаник. В первом столбце указана единица, если пассажир выжил, и ноль в противном случае, во втором столбце записано полное имя пассажира, в третьем — пол, в четвертом — возраст:
# survived;name;sex;age
# 0;Mr. Owen Harris Braund;male;22
# 1;Mrs. John Bradley (Florence Briggs Thayer) Cumings;female;38
# ...
# Напишите программу, которая выводит имена выживших пассажиров, которым было менее 1818 лет, каждое на отдельной строке. Причем сначала должны быть расположены имена всех пассажиров мужского пола, а затем — женского, имена же непосредственно в мужском и женском списках должны быть расположены в своем исходном порядке.
# Примечание 1. Разделителем в файле titanic.csv является точка с запятой, при этом кавычки не используются.
# Примечание 2. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 3. Часть ответа выглядит так:
# Master. Gerios Moubarek
# Master. Alden Gates Caldwell
# ...
# Master. Harold Theodor Johnson
# Mrs. Nicholas (Adele Achem) Nasser
# Miss. Marguerite Rut Sandstrom
# ...
# Примечание 4. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import csv

with open('titanic.csv', encoding='UTF-8') as f_in:
    rows = csv.reader(f_in, delimiter=';')

    # список выживших, которым было менее 18 лет
    l1 = list(filter(lambda x: (x[0] == '1' and float(x[3]) < 18), rows))

    l2 = list(filter(lambda x: (x[2] == 'male'), l1))
    l3 = list(filter(lambda x: (x[2] == 'female'), l1))

    l4 = l2 + l3

    for el in l4:
        print(f'{el[1]}')


# ---------------------------------------------------------------------------

with open('titanic.csv', 'r', encoding='utf-8') as file:
    reader = csv.reader(file)
    male = []
    female = []

    for i in reader:
        if i[0].split(';')[0] == '0':
            continue
        if i[0].split(';')[-2] == 'male' and float(i[0].split(';')[-1]) < 18:
            male.append(i[0].split(';')[1])
        if i[0].split(';')[-2] == 'female' and float(i[0].split(';')[-1]) < 18:
            female.append(i[0].split(';')[1])

print(*male, sep='\n')
print(*female, sep='\n')
# ===========================================================================

# Лог-файл
# 866
# Вам доступен файл name_log.csv, в котором находятся логи изменения имени пользователя. В первом столбце записано измененное имя пользователя, во втором — адрес электронной почты, в третьем — дата и время изменения. При этом email пользователь менять не может, только имя:
# username,email,dtime
# rare_charles6,charlesthompson@inbox.ru,15/11/2021 08:15
# busy_patricia5,patriciasmith@bk.ru,07/11/2021 08:07
# ...
# Напишите программу, которая отбирает из файла name_log.csv только самые свежие записи для каждого пользователя и записывает их в файл new_name_log.csv. В файле new_name_log.csv первой строкой должны быть заголовки столбцов такие же, как в файле name_log.csv. Логи в итоговом файле должны быть расположены в лексикографическом порядке названий электронных ящиков пользователей.
# Примечание 1. Для части пользователей в исходном файле запись только одна, и тогда в итоговый файл следует записать только ее, для некоторых пользователей есть несколько записей с разными именами.
# Например, пользователь с электронной почтой c3po@gmail.com несколько раз менял имя:
# C=3PO,c3po@gmail.com,16/11/2021 17:10
# C3PO,c3po@gmail.com,16/11/2021 17:15
# C-3PO,c3po@gmail.com,16/11/2021 17:24
# Из этих трех записей в итоговый файл должна быть записана только одна — самая свежая:
# C-3PO,c3po@gmail.com,16/11/2021 17:24
# Примечание 2. Разделителем в файле name_log.csv является запятая, при этом кавычки не используются.
# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. Начальная часть файла new_name_log.csv выглядит так:
# username,email,dtime
# angry-barbara2,barbaraanderson@bk.ru,17/11/2021 01:17
# dead-barbara6,barbarabrown@rambler.ru,27/11/2021 08:27
# busy_barbara7,barbaradavis@aol.com,24/11/2021 08:24
# ...
# Примечание 5. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import csv
# from datetime import datetime

with open('name_log.csv', encoding='utf-8') as file:
    rows = list(csv.reader(file))  # читаем csv, и  преобразуем в Python

    headers = rows.pop(0)

    # словарь по имени почты
    dict1 = {}
    for row in rows:
        dict1.setdefault(row[1], []).append(
            (row[0], datetime.strptime(row[2], "%d/%m/%Y %H:%M")))

    # список из словаря для записи в файл
    lst2 = []
    for key, value in sorted(dict1.items()):
        value.sort(key=lambda x: x[1])
        a = value[-1][0]
        b = key
        c = datetime.strftime(value[-1][1], "%d/%m/%Y %H:%M")
        lst2.append([a, b, c])
        # print(f'{value[-1][0]},{key},{datetime.strftime(value[-1][1], "%d/%m/%Y %H:%M")}')


with open('new_name_log.csv', 'w', encoding='utf-8', newline='') as file:
    writer11 = csv.writer(file, quoting=csv.QUOTE_NONE)

    writer11.writerow(headers)                 # запись заголовков
    for row in lst2:                        # запись строк
        writer11.writerow(row)
# ---------------------------------------------------------------------------
# import csv
# from datetime import datetime

with open('name_log.csv', encoding='UTF-8') as f:
    header, *rows = csv.reader(f)

d = {i[1]: i for i in sorted(
    rows, key=lambda x: datetime.strptime(x[2], '%d/%m/%Y %H:%M'))}

with open('new_name_log.csv', 'w', encoding='UTF-8', newline='') as f:
    w = csv.writer(f)
    w.writerow(header)
    w.writerows(sorted(d.values(), key=lambda x: x[1]))
# ===========================================================================


# Проще, чем кажется 🌶️
# Рассмотрим следующий текстовый фрагмент:

# ball,color,purple
# ball,size,4
# ball,notes,it's round
# cup,color,blue
# cup,size,1
# cup,notes,none

# Каждая строка этого фрагмента содержит три значения через запятую: имя объекта, свойство этого объекта, значение свойства. Например, в первой строке указан объект ball, имеющий свойство color, значение которого равно purple. Также у объекта ball есть свойства size и notes, имеющие значения 4 и it's round соответственно. Помимо объекта ball имеется объект cup, имеющий те же свойства и в том же количестве. Дадим этим объектам общее название object и сгруппируем строки данного текстового фрагмента по первому столбцу:

# object,color,size,notes
# ball,purple,4,it's round
# cup,blue,1,none

# Мы получили запись в привычном CSV формате, в котором в первом столбце указывается имя объекта, а в последующих — значения соответствующих свойств этого объекта.

# Реализуйте функцию condense_csv(), которая принимает два аргумента в следующем формате:

#     filename — название csv файла, например, data.csv; формат содержимого файла аналогичен формату текстового фрагмента, рассмотренного в условии задачи: каждая строка файла содержит три значения через запятую, а именно имя объекта, свойство этого объекта, значение свойства; все объекты имеют равные свойства и в равных количествах
#     id_name — общее название для объектов

# Функция должна привести содержимое файла в привычный CSV формат, сгруппировав строки по первому столбцу и назвав первый столбец id_name. Полученный результат функция должна записать в файл condensed.csv.

# Примечание 1. Например, если бы файл data.csv имел следующий вид:

# 01,Title,Ran So Hard the Sun Went Down
# 02,Title,Honky Tonk Heroes (Like Me)

# то вызов функции condense_csv():

# condense_csv('data.csv', id_name='ID')

# должен был бы создать файл condensed.csv со следующим содержанием:

# ID,Title
# 01,Ran So Hard the Sun Went Down
# 02,Honky Tonk Heroes (Like Me)

# Примечание 2. Гарантируется, что в передаваемом в функцию csv файле разделителем является запятая, при этом кавычки не используются.

# Примечание 3. При открытии файла используйте явное указание кодировки UTF-8.

# Примечание 4. В тестирующую систему сдайте программу, содержащую только необходимую функцию condense_csv(), но не код, вызывающий ее.
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Напишите простой калькулятор, который считывает с пользовательского ввода три строки: первое число, второе число и операцию, после чего применяет операцию к введённым числам ("первое число" "операция" "второе число") и выводит результат на экран.
#
#
# ---------------------------------------------------------------------------
# import math
# import operator


action = {
    "+": operator.add,
    "-": operator.sub,
    "/": operator.truediv,
    "*": operator.mul,
    "mod": operator.mod,
    "pow": operator.pow,
    "div": operator.floordiv
}

a = float(input())
b = float(input())

try:
    print(action[input()](a, b))

except ZeroDivisionError:
    print("Деление на 0!")
# ---------------------------------------------------------------------------

# ===========================================================================

# Дополните приведенный ниже код, чтобы он вывел содержимое словаря countries, расположив его элементы в лексикографическом порядке ключей, указав в качестве разделителя пар ключ-значение строку   -  (пробел дефис пробел), а в качестве отступов — три пробела.
# Примечание 1. Начальная часть ответа выглядит так:
# {
#    "Angola" - "Luanda",
#    "Australia" - "Canberra",
#    ...
# 864
# ---------------------------------------------------------------------------
# import json

countries = {'Monaco': 'Monaco', 'Iceland': 'Reykjavik', 'Kenya': 'Nairobi', 'Kazakhstan': 'Nur-Sultan',
             'Mali': 'Bamako', 'Colombia': 'Bogota', 'Finland': 'Helsinki', 'Costa Rica': 'San Jose',
             'Cuba': 'Havana', 'France': 'Paris', 'Gabon': 'Libreville', 'Liberia': 'Monrovia',
             'Angola': 'Luanda', 'India': 'New Delhi', 'Canada': 'Ottawa', 'Australia': 'Canberra'}

json_data = json.dumps(countries, indent=3,
                       sort_keys=True, separators=(',', ' - '))
print(json_data)
# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступны словари club1, club2 и club3, содержащие данные о различных футбольных клубах. Дополните приведенный ниже код, чтобы он объединил данные словари в список и записал полученную структуру данных в файл data.json, указав в качестве отступов три символа пробела.
# Примечание 1. Словари в списке должны располагаться в своем исходном порядке.
# Примечание 2. Начальная часть файла data.json выглядит так:

# [
#    {
#       "name": "FC Byern Munchen",
#       "country": "Germany",
#       ...
#    },
#    ...
# ]
#
# 967
# ---------------------------------------------------------------------------
# import json

club1 = {"name": "FC Byern Munchen", "country": "Germany", "founded": 1900,
         "trainer": "Julian Nagelsmann", "goalkeeper": "M. Neuer", "league_position": 1}

club2 = {"name": "FC Barcelona", "country": "Spain", "founded": 1899,
         "trainer": "Xavier Creus", "goalkeeper": "M. Ter Stegen", "league_position": 7}

club3 = {"name": "FC Manchester United", "country": "England", "founded": 1878,
         "trainer": "Michael Carrick", "goalkeeper": "D. De Gea", "league_position": 8}

with open('data.json', 'w') as file:
    json.dump([club1, club2, club3], file, indent=3)
# ---------------------------------------------------------------------------

# ===========================================================================


#

# Ниже представлена программа, которая должна преобразовать словарь specs в строку в формате JSON и вывести ее с отступами в три пробела, не заменяя кириллические символы на их коды. В программе допущена ошибка, поэтому она выводит:

# {"\u041c\u043e\u0434\u0435\u043b\u044c": "AMD Ryzen 5 5600G", "\u0413\u043e\u0434 \u0440\u0435\u043b\u0438\u0437\u0430": 2021, "\u0421\u043e\u043a\u0435\u0442": "AM4", "\u0422\u0435\u0445\u043f\u0440\u043e\u0446\u0435\u0441\u0441": "7 \u043d\u043c", "\u042f\u0434\u0440\u043e": "Cezanne", "\u041e\u0431\u044a\u0435\u043c \u043a\u044d\u0448\u0430 L2": "3 \u041c\u0411", "\u041e\u0431\u044a\u0435\u043c \u043a\u044d\u0448\u0430 L3": "16 \u041c\u0411", "\u0411\u0430\u0437\u043e\u0432\u0430\u044f \u0447\u0430\u0441\u0442\u043e\u0442\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430": "3900 \u041c\u0413\u0446"}

# Найдите и исправьте ее, чтобы программа преобразовала словарь specs в строку в формате JSON и вывела ее с отступами в три пробела, не заменяя кириллические символы на их коды.

# Примечание 1. Начальная часть ответа выглядит так:

# {
#    "Модель": "AMD Ryzen 5 5600G",
#    "Год релиза": 2021,
#    ...

# Примечание 2. Используйте необязательный аргумент ensure_ascii.

#
# 982
# ---------------------------------------------------------------------------
# import json

specs = {
    'Модель': 'AMD Ryzen 5 5600G',
    'Год релиза': 2021,
    'Сокет': 'AM4',
    'Техпроцесс': '7 нм',
    'Ядро': 'Cezanne',
    'Объем кэша L2': '3 МБ',
    'Объем кэша L3': '16 МБ',
    'Базовая частота': '3900 МГц'
}

specs_json = json.dumps(specs, indent=3, ensure_ascii=False)

print(specs_json)
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция is_correct_json()
# 977
# Реализуйте функцию is_correct_json(), которая принимает один аргумент:

#     string — произвольная строка

# Функция должна возвращать True, если строка string удовлетворяет формату JSON, или False в противном случае.

# Примечание 1. Вспомните про конструкцию try-except из урока.

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_correct_json(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

# import json

def is_correct_json(string):

    try:
        data = json.loads(string)
        return True
    except:      # перехватываем любую ошибку # json.decoder.JSONDecodeError
        return False
# ---------------------------------------------------------------------------


def is_correct_json(string):
    try:
        return bool(__import__('json').loads(string))
    except:
        return False
# ===========================================================================


#  Элементы JSON
# 945
# Напишите программу, которая принимает на вход описание одного объекта в формате JSON и выводит все пары ключ-значение этого объекта.
# Формат входных данных
# На вход программе подается корректное описание одного объекта в формате JSON.
# Формат выходных данных
# Программа должна вывести все пары ключ-значение введенного объекта, разделяя ключ и значение двоеточием, каждую на отдельной строке. Если значением ключа является список, то все его элементы должны быть выведены через запятую.
# Примечание 1. Пары ключ-значение при выводе должны располагаться в своем исходном порядке.
# Примечание 2. Для считывания произвольного числа строк используйте потоковый ввод sys.stdin.
# ---------------------------------------------------------------------------
# import sys
# import json

content_input_json = sys.stdin.read()

data_dict = json.loads(content_input_json)

for key, value in data_dict.items():
    if type(value) == list:
        print(f'{key}: {", ".join(map(str,value))}')
    else:
        print(f'{key}: {value}')
# -------------------препод---------------------------------------------

# import sys
# import json
data = json.loads(sys.stdin.read())

for key, value in data.items():
    if isinstance(value, list):
        print(f'{key}: {", ".join(map(str, value))}')
    else:
        print(f'{key}: {value}')
# ===========================================================================

# Разные типы
# 901
# Вам доступен файл data.json, содержащий список различных объектов:
# [
#    "nwkWXma",
#    null,
#    {
#       "ISgHT": "dIUbf"
#    },
#    "Pzt",
#    "BXcbGVTE",
#    ...
# ]
# Напишите программу, которая создает список, элементами которого являются объекты из списка, содержащегося в файле data.json, измененные по следующим правилам:
#     если объект является строкой, в его конец добавляется восклицательный знак
#     если объект является числом, он увеличивается на единицу
#     если объект является логическим значением, он инвертируется
#     если объект является списком, он удваивается
#     если объект является JSON-объектом (словарем), в него добавляется новая пара "newkey": null
#     если объект является пустым значением (null), он не добавляется
# Полученный список программа должна записать в файл updated_data.json.
# Примечание 1. Например, если бы файл data.json имел вид:
# ["Hello", 179, true, null, [1, 2, 3], {"key": "value"}]
# то программа должна была бы создать файл updated_data.json со следующим содержанием:
# ["Hello!", 180, false, [1, 2, 3, 1, 2, 3], {"key": "value", "newkey": null}]
# Примечание 2. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 3. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

#  import json

with open('c:/Users/User/PYTHON1/data.json') as file:
    # читаем json, и  преобразуем в Python
    data = json.load(file)

    lst1 = []
    for el in data:
        if isinstance(el, str):
            lst1.append(el + '!')

        elif el == True:
            lst1.append(False)
        elif el == False:
            lst1.append(True)

        elif type(el) == int:
            lst1.append(el + 1)

        elif isinstance(el, list):
            lst1.append(el + el)

        elif type(el) == dict:
            # d.update({"newkey": None}) возвращает None. это тоже самое если написать lst = lst.sort(). lst , будет None.
            # Чтобы добавить ключ значение в словарь нужно писать отдельной строчкой
            #  d.update({"newkey": None}) , а вы наверное это делали так lst.append(d.update({"newkey": None}))

            # lst.append(el | {"newkey": None})  -------- аналогично
            el.update({"newkey": None})
            lst1.append(el)

        elif el is None:
            continue
            # или pass

with open('c:/Users/User/PYTHON1/updated_data.json', 'w') as file:
    json.dump(lst1, file, indent=3)  # записываем
# ---------------------------------------------------------------------------
# import json

opers = {'str': lambda x: x + '!',
         'int': lambda x: x + 1,
         'float': lambda x: x + 1,
         'bool': lambda x: not x,
         'list': lambda x: x * 2,
         'dict': lambda x: x | {'newkey': None}}

with open('data.json', encoding='utf8') as fi, open('updated_data.json', 'w', encoding='utf8') as fo:
    json.dump([opers[type(i).__name__](i)
              for i in json.load(fi) if type(i).__name__ in opers], fo, indent=3)
# ===========================================================================

# with open('data.json', encoding='utf-8') as file:
#     data_json = json.load(file)

# updated_data = []
# for value in data_json:
#     match value:
#         case str(): value += '!'
#         case bool(): value = not value
#         case int(): value += 1
#         case list(): value *= 2
#         case dict(): value["newkey"] = None
#         case None: continue
#     updated_data.append(value)

# with open('updated_data.json', 'w', encoding='utf-8') as file:
#     json.dump(updated_data, file)
# ===========================================================================
# ===========================================================================
# ===========================================================================
# ===========================================================================

with open('data.json', encoding='UTF-8') as file:
    l = []
    d = {type(''): lambda x: f'{x}!',
         type(1): lambda x: x + 1,
         type(1.1): lambda x: x + 1,
         type(True): lambda x: bool(abs(x - 1)),
         type([]): lambda x: x + x,
         type({}): lambda x: x | {"newkey": None}}

    for obj in json.load(file):
        if type(obj) in d:
            l.append(d[type(obj)](obj))

with open('updated_data.json', 'w', encoding='UTF-8') as file:
    json.dump(l, file)
# ===========================================================================


# Объединение объектов
# 942
# Вам доступны два файла data1.json и data2.json, каждый из которых содержит по единственному JSON-объекту:
# Напишите программу, которая объединяет два данных JSON-объекта в один JSON-объект, причем если пары из первого и второго объектов имеют совпадающие ключи, то значение следует взять из второго объекта. Полученный JSON-объект программа должна записать в файл data_merge.json.
# Примечание 1. Например, если бы файлы data1.json и data2.json имели вид:
# Примечание 2. Элементы в результирующем JSON-объекте могут располагаться в произвольном порядке.
# Примечание 3. Указанные файлы доступны по ссылке и ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import json

with open('data1.json', 'r', encoding='utf-8') as f_in:
    # передаем(считываем) 1й файловый объект в переменную
    inf1 = json.load(f_in)

with open('data2.json', 'r', encoding='utf-8') as f_in:
    # передаем(считываем) 2 файловый объект в переменную
    inf2 = json.load(f_in)

dict3 = {}
dict3.update(inf1)
dict3.update(inf2)  # объединяем словари
# dict3 = inf1 | inf2   # в версии python 3.9

with open('data_merge.json', 'w', encoding='UTF-8') as file:
    json.dump(dict3, file)   # запись в файл формат-json
# ===========================================================================
# import json
data = []
for i in [1, 2]:
    with open(f"data{i}.json", "r", encoding="utf-8") as file:
        data.append(json.load(file))

with open("data_merge.json", "w", encoding="utf-8") as file:
    json.dump(data[0] | data[1], file, indent=3)
# ===========================================================================


# Восстановление недостающих ключей
# 926
# Вам доступен файл people.json, содержащий список JSON-объектов. Причем у различных объектов может быть различное количество ключей:
# Напишите программу, которая добавляет в каждый JSON-объект из данного списка все недостающие ключи, присваивая этим ключам значение null. Ключ считается недостающим, если он присутствует в каком-либо другом объекте, но отсутствует в данном. Программа должна создать список с обновленными JSON-объектами и записать его в файл updated_people.json.
# Примечание 1. JSON-объекты в создаваемом программой списке должны располагаться в своем исходном порядке. Порядок ключей в JSON-объектах не важен.
# Примечание 2. Например, если бы файл people.json имел вид:
# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------


# import json

with open('people.json', 'r', encoding='utf-8') as file:
    # ДЕСЕРИАЛИЗАЦИЯ load(из json в Python) передаем файловый объект в переменную
    data = json.load(file)

dict1 = {}
for el in data:
    dict1.update(el)

for el in data:
    # dict.keys(), dict.values() и dict.items() являются объектами-представлениями. Метод dict.keys() возвращает новый список-представление всех ключей dict_keys, содержащихся в словаре dict.
    d1 = dict1.keys() - el.keys()
    for elem in d1:
        el.update({elem: None})


with open('updated_people.json', 'w', encoding='utf-8') as file:
    # СЕРИАЛИЗАЦИЯ. функция dump() записывает переданный Python объект в файл.
    json.dump(data, file, indent=4)

# ---------------------------------------------------------------------------
# import json


with open('people.json', encoding='utf-8') as js:
    content = json.load(js)  # читаем json, и  преобразуем в Python


keys = set()
for data in content:
    keys |= data.keys()

for data in content:
    data |= dict.fromkeys(keys - data.keys())

with open('updated_people.json', 'w') as js:
    json.dump(content, js, indent=3)
# ===========================================================================


# Я исповедую Python, а ты?
# 936
# Вам доступен файл countries.json, содержащий список JSON-объектов c информацией о странах и исповедуемых в них религиях:

# Каждый объект из этого списка содержит два атрибута:

#     country — страна
#     religion — исповедуемая религия

# Напишите программу, которая создает единственный JSON-объект, имеющий в качестве ключа название религии, а в качестве значения — список стран, в которых исповедуется данная религия. Полученный JSON-объект программа должна записать в файл religion.json.
# Примечание 1. Страны в списках должны располагаться в своем исходном порядке.
# Примечание 2. Начальная часть файла religion.json выглядит так:
# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import json

with open('c:/Users/User/PYTHON1/countries.json', 'r', encoding='utf-8') as file:
    data = json.load(file)  # читаем json, и  преобразуем в Python


# print(*data, sep='\n')
dict1 = {}
for el in data:
    dict1.setdefault(el['religion'], []).append(el['country'])

# for key, value in dict1.items():
#      print(key, ': ', value)

with open('c:/Users/User/PYTHON1/religion.json', 'w', encoding='utf-8') as file:
    json.dump(dict1, file, indent=4)  # записываем


# ---------------------------------------------------------------------------

# ===========================================================================


# Спортивные площадки
# 866
# Вам доступен файл playgrounds.csv с информацией о спортивных площадках Москвы. В первом столбце записан тип площадки,  во втором — административный округ, в третьем — название района, в четвертом — адрес:

# ObjectName;AdmArea;District;Address
# Парк, озелененная городская территория «Лианозовский парк культуры и отдыха»;Северо-Восточный административный округ;район Лианозово;Угличская улица, дом 13
# ...
# Напишите программу, создающую JSON-объект, ключом в котором является административный округ, а значением — JSON-объект, в котором, в свою очередь, ключом является название района, относящийся к этому административному округу, а значением — список адресов всех площадок в этом районе. Полученный JSON-объект программа должна записать в файл addresses.json.
# Примечание 1. Адреса в списках должны располагаться в своем исходном порядке.
# Примечание 2. Разделителем в файле playgrounds.csv является точка с запятой, при этом кавычки не используются.
# Примечание 3. Начальная часть файла addresses.json выглядит так:
# Примечание 4. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 5. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import json
# import csv

with open('playgrounds.csv', 'r', encoding='utf-8') as file:
    rows = csv.DictReader(file, delimiter=';',
                          quotechar='"')  # считываем csv-файл

# конструкция для вложенных словарей
    dict1 = {}
    for row in rows:
        dict1.setdefault(row['AdmArea'], {}).setdefault(
            row['District'], []).append(row['Address'])


with open('addresses.json', 'w', encoding='utf-8') as file:
    json.dump(dict1, file, indent=4, ensure_ascii=False)  # записываем
# ---------------------------------------------------------------------------
# import csv, json

with open('playgrounds.csv', encoding='UTF-8') as file_in:
    reader = csv.DictReader(file_in, delimiter=';')
    result = {}
    for row in reader:
        result[row['AdmArea']] = result.get(row['AdmArea'], {})
        adm_area = result[row['AdmArea']]
        adm_area[row['District']] = adm_area.get(
            row['District'], []) + [row['Address']]
with open('addresses.json', 'w', encoding='UTF-8') as file_out:
    json.dump(result, file_out, indent=3, ensure_ascii=False)


# =================РАБОТА С ВЛОЖЕННЫЕ СЛОВАРИ==========================================================
# import csv, json

with open('playgrounds.csv', encoding='UTF-8') as file_in:
    reader = csv.DictReader(file_in, delimiter=';')
    result = {}
    for row in reader:
        result[row['AdmArea']] = result.get(row['AdmArea'], {})
        adm_area = result[row['AdmArea']]
        adm_area[row['District']] = adm_area.get(
            row['District'], []) + [row['Address']]
with open('addresses.json', 'w', encoding='UTF-8') as file_out:
    json.dump(result, file_out, indent=3, ensure_ascii=False)
# ===========================================================================

# Студенты курса
# 902
# Вам доступен файл students.json, содержащий список JSON-объектов, которые представляют данные о студентах некоторого курса:
# Под «студентом» мы будем подразумевать один JSON-объект из этого списка. У студента имеются следующие атрибуты:
# Программа должна создать файл data.csv с двумя столбцами — name (имя) и phone (номер), и записать в него данные выбранных студентов, расположив их в лексикографическом порядке имён. В качестве разделителя в файле data.csv должна быть использована запятая.
# Примечание 1. Гарантируется, что все студенты имеют различные имена.
# Примечание 2. Начальная часть файла data.csv выглядит так:
# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------
# import json
# import csv

with open('students.json', 'r', encoding='utf-8') as file:
    data = json.load(file)  # читаем json, и  преобразуем в Python

    l1 = []
    for stud in data:
        if stud['age'] >= 18 and stud['progress'] >= 75:
            l1.append((stud['name'], stud['phone']))

with open('data.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file)  # записываем в файл csv
    writer.writerow(['name', 'phone'])             # запись заголовков
    # запись строк, отсортированы по имени
    for row in sorted(l1, key=lambda x: x[0]):
        writer.writerow(row)
# ---------------------------------------------------------------------------
# csv — это стандартный модуль, но не встроенный, т.к. его нужно импортировать. pandas же не относится к стандартным, потому что его ещё нужно устанавливать отдельно. Вероятно, модуль csv удобно использовать на каких-нибудь простых задачах, где не нужны сложные вычисления при работе с данными, которые предоставляет pandas, т.к. pandas по своей сути не отличается производительностью
# import pandas as pd
df = pd.read_json('students.json')
df_1 = df[(df['age'] >= 18) & (df['progress'] >= 75)].sort_values(by='name')
df_1[['name', 'phone']].to_csv('data.csv', index=False)

# ===========================================================================
# import json
# import csv

with open('students.json') as file:
    students = json.load(file)
    result = []
    for student in students:
        if student['age'] >= 18 and student['progress'] >= 75:
            result.append([student['name'], student['phone']])
    result.sort()

with open('data.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['name', 'phone'])
    writer.writerows(result)
# ===========================================================================

# Бассейны
# 859
# Тимур планирует пойти в бассейн. Среди всех бассейнов ему подходят те, которые открыты в понедельник в период с 10:00 до 12:00. Также ему нравится плавать по длинным дорожкам, поэтому из всех работающих в это время бассейнов нужно выбрать бассейн с наибольшей длиной дорожки, при равных значениях — c наибольшей шириной.
# Вам доступен файл pools.json, содержащий список JSON-объектов, которые представляют данные о крытых плавательных бассейнах:
# Под «бассейном» будем подразумевать один JSON-объект из этого списка. У бассейна имеются следующие атрибуты:
# Напишите программу, которая определяет бассейн, подходящий Тимуру. Программа должна вывести его размеры и адрес в следующем формате:
# Примечание 1. Пример вывода:
# Примечание 2. Бассейн должен быть открыт во время всего периода с 10:00 до 12:00. Например, если бассейн работает в 10:00, но не работает в 11:30, он не подходит.
# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import json
# from datetime import datetime, timedelta

with open('c:/Users/User/PYTHON1/pools.json', 'r', encoding='utf-8') as file:
    pools = json.load(file)

l1 = []

for pool in pools:
    time_work2 = [datetime.strptime(
        i, '%H:%M') for i in pool['WorkingHoursSummer']['Понедельник'].split('-')]

    td = time_work2[1] - time_work2[0]

    # eсли время открытия меньше 10.00 и врем.закрытия больше 12.00
    if time_work2[0] <= datetime.strptime('10:00', '%H:%M') and time_work2[1] >= datetime.strptime('10:00', '%H:%M'):
        l1.append((pool['DimensionsSummer']['Length'],
                  pool['DimensionsSummer']['Width'], pool['Address']))

l_max = max(map(lambda x: x[0], l1))
# print(l_max)
l2 = list(filter(lambda x: x[0] == l_max, l1))

w_max = max(map(lambda x: x[1], l2))
# print(w_max)
l3 = list(filter(lambda x: x[1] == w_max, l2))

for el in l3:
    print(f"{el[0]}x{el[1]}\n{el[2]}")
# ---------------------------------------------------------------------------

# ===========================================================================


# Количество файлов
# 941
# Вам доступен архив workbook.zip, содержащий различные папки и файлы. Напишите программу, которая выводит единственное число — количество файлов в этом архиве.
# Примечание 1. Обратите внимание, что папка не считается файлом.
# ---------------------------------------------------------------------------
# from zipfile import ZipFile

with ZipFile('workbook.zip') as zip_file:

    info = zip_file.infolist()

    i = 0
    cnt = 0
    for el in info:
        if not info[i].is_dir():
            cnt += 1
        i += 1

    print(cnt)
# ---------------------------------------------------------------------------
# from zipfile import ZipFile

with ZipFile('workbook.zip') as zip_file:
    print(len(list(filter(lambda x: not x.is_dir(), zip_file.infolist()))))
# ===========================================================================


# Объем файлов
# 947
# Вам доступен архив workbook.zip, содержащий различные папки и файлы. Напишите программу, которая выводит суммарный объем файлов этого архива в сжатом и не сжатом видах в байтах, в следующем формате:
# Объем исходных файлов: <объем до сжатия> байт(а)
# Объем сжатых файлов: <объем после сжатия> байт(а)

# Примечание 1. Вывод на примере архива test.zip из конспекта:

# Объем исходных файлов: 7810260 байт(а)
# Объем сжатых файлов: 7798267 байт(а)
# ---------------------------------------------------------------------------
# from zipfile import ZipFile

with ZipFile('workbook.zip') as zip_file:

    info = zip_file.infolist()

    l1 = list(filter(lambda x: not x.is_dir(), info))
    l2 = list(map(lambda x: x.file_size, l1))
    l3 = list(map(lambda x: x.compress_size, l1))

    print(f'Объем исходных файлов: {sum(l2)} байт(а)')
    print(f'Объем сжатых файлов: {sum(l3)} байт(а)')
# ---------------------------------------------------------------------------

# ===========================================================================


# Наилучший показатель
# 952
# ам доступен архив workbook.zip, содержащий различные папки и файлы. Напишите программу, которая выводит название файла из этого архива, который имеет наилучший показатель степени сжатия.
# Примечание 1. Если файл находится в папке, вывести следует только название без пути.
# Примечание 2. Гарантируется, что в исходном архиве только один файл имеет наилучший показатель степени сжатия.
# Примечание 3. Степень сжатия файла характеризуется коэффициентом KK, определяемым как отношение объема сжатого файла VcVc​ к объему исходного файла VoVo​, выраженным в процентах:
# K=VcVo⋅100%
# ---------------------------------------------------------------------------
# from zipfile import ZipFile

with ZipFile('workbook.zip') as zip_file:

    info = zip_file.infolist()

    l1 = filter(lambda x: not x.is_dir(), info)
    l2 = map(lambda x: (((x.compress_size / x.file_size) * 100), x.filename), l1)

    l2 = sorted(l2, key=lambda x: x[0])

    file_way = l2[0][1]
    file_name = file_way.split('/')[-1]

    print(file_name)
# ---------------------------------------------------------------------------

# ===========================================================================


# Избранные
# 947
# Вам доступен архив workbook.zip, содержащий различные папки и файлы. Напишите программу, которая выводит названия файлов из этого архива, которые были созданы или изменены позднее 2021-11-30 14:22:00. Названия файлов должны быть расположены в лексикографическом порядке, каждое на отдельной строке.
# Примечание 1. Если файл находится в папке, вывести следует только название без пути.
# Примечание 2. Начальная часть ответа выглядит так:
# countries.json
# data_sample.csv
# ---------------------------------------------------------------------------
# from zipfile import ZipFile
# from datetime import datetime

with ZipFile('workbook.zip') as zip_f:
    info = zip_f.infolist()

l1 = filter(lambda x: not x.is_dir(), info)
l2 = map(lambda x: (x.filename, x.date_time), l1)
l3 = map(lambda x: ((x[0].split('/')[-1]), datetime(x[1]
         [0], x[1][1], x[1][2], x[1][3], x[1][4], x[1][5])), l2)
# lambda x: x.date_time > (2021, 11, 30, 14, 22, 0)
l4 = filter(lambda x: x[1] >= datetime(2021, 11, 30, 14, 22, 0), l3)

for el in sorted(l4, key=lambda x: x[0]):
    print(el[0])
# ---------------------------------------------------------------------------
# from zipfile import ZipFile


def is_file(x): return not x.is_dir()   # значение фенкции присвоено переменной
def younger(x): return x.date_time > (2021, 11, 30, 14,
                                      22, 0)  # кортеж можно сравнивать поэлементно


def name(x): return x.filename.split('/')[-1]


with ZipFile('workbook.zip') as file:
    print(*sorted(map(name, filter(younger, filter(is_file, file.infolist())))), sep='\n')
# ===========================================================================


# Форматированный вывод
# 941
# Вам доступен архив workbook.zip, содержащий различные папки и файлы. Напишите программу, которая выводит названия всех файлов из этого архива в лексикографическом порядке, указывая для каждого его дату изменения, а также объем до и после сжатия, в следующем формате:
# <название файла>
#   Дата модификации файла: <дата изменения>
#   Объем исходного файла: <объем до сжатия> байт(а)
#   Объем сжатого файла: <объем после сжатия> байт(а)

# Между данными о двух файлах должна располагаться пустая строка.
# Примечание 1. Если файл находится в папке, вывести следует только название без пути.
# ---------------------------------------------------------------------------
# from zipfile import ZipFile
# from datetime import datetime

def print_file(tuple):
    str_print = f'''{tuple[0]}
  Дата модификации файла: {tuple[1]}
  Объем исходного файла: {tuple[2]} байт(а)
  Объем сжатого файла: {tuple[3]} байт(а)'''

    return str_print


with ZipFile('workbook.zip') as z_file:
    info = z_file.infolist()

l1 = list(filter(lambda x: not x.is_dir(), info))
name_l = map(lambda x: x.filename.split('/')[-1], l1)


def func_1(x): return datetime(x[0], x[1], x[2], x[3], x[4], x[5])


time_l = map(lambda x: func_1(x.date_time), l1)

file_size_l = map(lambda x: x.file_size, l1)
compress_size_l = map(lambda x: x.compress_size, l1)

data = zip(name_l, time_l, file_size_l, compress_size_l)

lst = []
for el in sorted(data, key=lambda x: x[0]):
    lst.append(print_file(el))

print(*lst, sep='\n\n')
# ---------------------------------------------------------------------------

# ===========================================================================


# 963
# Вам доступен набор различных файлов, названия которых представлены в списке file_names. Дополните приведенный ниже код, чтобы он создал архив files.zip и добавил в него все файлы из данного списка.
# Примечание. Считайте, что файлы из списка file_names находятся в папке с программой.
# ---------------------------------------------------------------------------
# --------------------------------------------
# from zipfile import ZipFile

file_names = ['how to prove.pdf', 'fipi_demo_2022.pdf', 'Hollow Knight Silksong.exe',
              'code.jpeg', 'stepik.png', 'readme.txt', 'shopping_list.txt',
              'Alexandra Savior – Crying All the Time.mp3', 'homework.py', 'test.py']

with ZipFile('files.zip', mode='w') as zip_file:

    for file in file_names:
        zip_file.write(file)
# ===========================================================================


# #
# Вам доступен набор различных файлов, названия которых представлены в списке file_names. Также вам доступен архив files.zip. Дополните приведенный ниже код, чтобы он добавил в архив files.zip только те файлы из списка file_names, объем которых не превышает 100100 байт.
# Примечание 1. Получить объем файла в байтах позволяет функция getsize() из модуля os.path. Данная функция принимает в качестве аргумента путь к файлу и возвращает размер указанного файла в байтах.
# Например, вычислить объем архива files.zip в байтах и сохранить его в переменную size можно следующим образом:
# import os.path
# size = os.path.getsize('files.zip')
# Примечание 2. Вычислить объем файла в байтах можно и вручную, не прибегая к использованию сторонних модулей. Подумайте, как 😉.
# Примечание 3. Считайте, что файлы из списка file_names и архив files.zip находятся в папке с программой.
# ---------------------------------------------------------------------------


file_names = ['how to prove.pdf', 'fipi_demo_2022.pdf', 'Hollow Knight Silksong.exe',
              'code.jpeg', 'stepik.png', 'readme.txt', 'shopping_list.txt',
              'Alexandra Savior – Crying All the Time.mp3', 'homework.py', 'test.py']

with ZipFile('files.zip', mode='a') as zip_file:
    # info = zip_file.infolist()

    for file in file_names:
        size = os.path.getsize(file)
        if size <= 100:
            zip_file.write(file)


# ---------------------------------------------------------------------------

# ===========================================================================


# Функция extract_this()
# Реализуйте функцию extract_this(), которая принимает один или более аргументов в следующем порядке:
#     zip_name — название zip архива, например, data.zip
#     *args — переменное количество позиционных аргументов, каждый из которых является названием некоторого файла
# Функция должна извлекать файлы *args из архива zip_name в папку с программой. Если в функцию не передано ни одного названия файла для извлечения, то функция должна извлечь все файлы из архива.
# Примечание 1. Например, следующий вызов функции
# extract_this('workbook.zip', 'earth.jpg', 'exam.txt')
# должен извлечь из архива workbook.zip файлы earth.jpg и exam.txt в папку с программой.
# Вызов функции
# extract_this('workbook.zip')
# должен извлечь из архива workbook.zip все файлы в папку с программой.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию extract_this(), но не код, вызывающий ее.
# 953
# ---------------------------------------------------------------------------

# from zipfile import ZipFile

def extract_this(zip_name, *args):
    with ZipFile(zip_name) as zip_file:
        if len(args):
            for arg in args:
                zip_file.extract(arg)
        else:
            zip_file.extractall()

# ---------------------------------------------------------------------------
# # У метода extractall() есть необязательный аргумент members, по умолчанию имеет значение None. Если ему не передавать никакие другие значения, то он принимает список всех файлов из архива.
# Если же мы передадим в args названия файлов, которые нужно извлечь, то members примет кортеж файлов и извлечет их.
# Если же в args ничего не передавать, тогда members примет пустой кортеж и ничего извлекать вообще не будет. Это отличается от поведения по умолчанию, которое было описано выше. Для этого и нужна проверка на пустой кортеж.
# Если кортеж пуст, присваиваем переменной args значение None, и тогда извлекутся все файлы.


def extract_this(zip_name: str, *args):
    if not args:
        args = None
    with ZipFile(zip_name) as zf:
        zf.extractall(members=args)

# ++++++++++++++


# вариант покороче


def extract_this(zip_name: str, *args):
    with ZipFile(zip_name) as zf:
        zf.extractall(members=args or None)
# ===========================================================================


# Шахматы были лучше 🌶️
# 845
# Вам доступен архив data.zip, содержащий различные папки и файлы. Среди них есть несколько JSON файлов, каждый из которых содержит информацию о каком-либо футболисте:
# {
#    "first_name": "Gary",
#    "last_name": "Cahill",
#    "team": "Chelsea",
#    "position": "Defender"
# }

# У футболиста имеются следующие атрибуты:

#     first_name — имя
#     last_name — фамилия
#     team — название футбольного клуба
#     position — игровая позиция

# Напишите программу, которая обрабатывает только данные JSON файлы и выводит имена и фамилии футболистов, выступающих за футбольный клуб Arsenal. Футболисты должны быть расположены в лексикографическом порядке имен, а при совпадении — в лексикографическом порядке фамилий, каждый на отдельной строке.

# Примечание 1. Обратите внимание, что наличие у файла расширения .json не гарантирует, что он является корректным текстовым файлом в формате JSON. Для того чтобы определить, является ли файл корректным текстовым файлом в формате JSON, воспользуйтесь конструкцией try-except и функцией is_correct_json() из предыдущего урока.
# ---------------------------------------------------------------------------

# import json
# from zipfile import ZipFile


def is_correct_json(name1):

    try:
        with open(name1, 'r', encoding='utf-8') as file:
            content = file.read()  # считываем информацию из файла
            data = json.loads(content)  # возвращаем словарь Python
        return data
    except:      # перехватываем любую ошибку # json.decoder.JSONDecodeError

        return False


l1 = []


# ИЗВЛЕЧЕНИЕ из АРХАВА
with ZipFile('C:/Users/User/PYTHON1/n5678/data.zip') as zip_file:
    # zip_file.printdir()  # просмотр оглавления архива

    # info = zip_file.infolist() # список содержащий объект zipfile.ZipInfo() для каждого члена архива.
    # Метод ZipFile.namelist() возвращает список всех членов архива по имени.
    for name in zip_file.namelist():

        # РАСПАКОВЫВАЕМ ФАЙЛЫ только c расширением json
        if name[-4:] == 'json':
            # распаковать всё в
            zip_file.extract(name, 'C:/Users/User/PYTHON1/n5678/333')

        # открываем файл и проверяем корректность информации. если все ок, функция вернёт десериализованный словарь Python
        if is_correct_json(name):
            data = is_correct_json(name)

            if data['team'] == 'Arsenal':
                l1.append((data['first_name'], data['last_name']))

l2 = sorted(l1, key=lambda x: (x[0], x[1]))
l2 = list(map(lambda x: f"{x[0]} {x[1]}", l2))

print(*l2, sep='\n')


# Одинокая функция
# 913
# Дан pickle файл, содержащий единственную сериализованную функцию. Напишите программу, которая вызывает данную функцию с заданными аргументами и выводит возвращаемое значение функции.

# Формат входных данных
# На вход программе в первой строке подается название pickle файла, в котором содержится единственная сериализованная функция. Далее подается произвольное количество строк, каждая из которых содержит позиционный аргумент для этой функции.
# Формат выходных данных
# Программа должна вызвать функцию из указанного pickle файла со всеми введенными строковыми аргументами, и вывести возвращаемое значение функции. Причем аргументы должны быть переданы в том порядке, в котором они были введены.
# Примечание 1. Аргументы, передаваемые в функцию, должны иметь тип str.
# Примечание 2. Рассмотрим первый тест. Сначала подается название файла — func.pkl, в котором содержится сериализованная функция:

# def func(*args):
#     return ' '.join(args)

# затем аргументы для этой функции: Hello,, how, are, you и today?.
# Программа выводит результат следующего вызова:

# func('Hello,', 'how', 'are', 'you', 'today?')
# Примечание 3. Для считывания произвольного количества строк используйте потоковый ввод sys.stdin.
# Примечание 4. Считайте, что вводимый файл находится в папке с программой.
# Примечание 5. В этой задаче за кулисами реализовано две функции с именами func и add. Не используйте эти имена для именования своих переменных во избежание ошибок.

# import sys
# import pickle

file_name = sys.stdin.readline().strip()
data = [line.strip() for line in sys.stdin]

with open(file_name, 'rb') as file:
    obj = pickle.load(file)

print(obj(*data))
# ----------------ПРЕПОД----------------------------------------------
# import pickle
# import sys

name, *args = [line.strip() for line in sys.stdin]

with open(name, 'rb') as f:
    func = pickle.load(f)

print(func(*args))
# ===========================================================================


# Реализуйте функцию filter_dump(), которая принимает три аргумента в следующем порядке:
# 941
#     filename — название pickle файла, например, data.pkl
#     objects — список произвольных объектов
#     typename — тип данных
# Функция должна создавать pickle файл с названием filename, который содержит сериализованный список только тех объектов из списка objects, тип которых равен typename.
# Примечание 1. Например, вызов функции filter_dump() следующим образом:
# filter_dump('numbers.pkl', [1, '2', 3, 4, '5'], int)
# должен создавать файл numbers.pkl, содержащий сериализованный список [1, 3, 4].
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию filter_dump(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

# import pickle

def filter_dump(filename, objects, typename):

    l1 = list(filter(lambda x: type(x) is typename, objects))

    # создает файл , содержащий бинарное представление объекта obj на основе протокола pickle.
    with open(filename, 'wb') as f:
        pickle.dump(l1, f)
# ==========================================================================

#  Контрольная сумма
# 908
# По каналу связи передаются pickle файл, содержащий сериализованный словарь или список, и целое число — контрольная сумма, которая вычисляется по следующему правилу:
    # для словаря — сумма всех целочисленных ключей (тип int)
    # для списка — произведение минимального и максимального целочисленных элементов (тип int)
# Напишите программу, которая вычисляет контрольную сумму для объекта, содержащегося в pickle файле, и сравнивает ее с данным целым числом.
# Формат входных данных
# На вход программе в первой строке подается название pickle файла, в котором содержится сериализованный словарь или список, в следующей — целое число.
# Формат выходных данных
# Программа должна вычислить контрольную сумму для объекта, который содержится в данном pickle файле, и
#     если она совпадает с введенным числом, вывести текст:
#     Контрольные суммы совпадают
#     если она не совпадает с введенным числом, вывести текст:
#     Контрольные суммы не совпадают
# Примечание 1. Если список (словарь) не содержит целочисленных элементов (ключей), то считайте, что контрольная сумма равна 00.
# Примечание 2. Рассмотрим первый тест. Подается название файла — data.pkl, в котором содержится сериализованный список:
# ['a', 'b', 3, 4, 'f', 'g', 7, 8]
# затем число — 30233023. Контрольная сумма для данного списка равна 3⋅8=243⋅8=24. Так как 3023≠243023=24, программа выводит:
# Контрольные суммы не совпадают
# ==========================================================================

# import pickle
# import sys


f_n = sys.stdin.readline().strip()
num = sys.stdin.readline().strip()

with open(f_n, 'rb') as file:
    obj = pickle.load(file)

if type(obj) == dict:
    l1 = list(filter(lambda x: type(x) == int, obj))

    if len(l1) == 0:
        total_control = 0
    else:
        total_control = sum(l1)

elif type(obj) == list:
    l2 = list(filter(lambda x: type(x) == int, obj))

    if len(l2) == 0:
        total_control = 0
    else:
        total_control = max(l2) * min(l2)

if total_control == int(num):
    print('Контрольные суммы совпадают')
else:
    print('Контрольные суммы не совпадают')
# ---------------------------------------------------------------------------
# import pickle

name, sm = input(), int(input())
with open(name, 'rb') as f:
    obj = pickle.load(f)

    # В list comprehension один фиг у словаря берутся ключи.
    # Переменной lst присваивается то значение, которое первое будет True? То есть если список [i for i in obj if type(i) == int] окажется пустым, то его значение будет False и lst будет присвоено [0] так как не пустой список является True?
    lst = [i for i in obj if type(i) == int] or [0]
    check = sum(lst) if type(obj) == dict else max(lst)*min(lst)
    print(['Контрольные суммы не совпадают',
          'Контрольные суммы совпадают'][sm == check])
# ===========================================================================


# Я и сам своего рода переводчик
#
# Дана строка соответствия латинскому алфавиту: первый символ строки соответствует букве a, второй — b, третий — c, и так далее. Каждый символ соответствует как заглавной, так и строчной буквам. Количество символов в строке совпадает с количеством букв в латинском алфавите.
# Напишите программу, которая с помощью данной строки переводит заданный текст.
# Формат входных данных
# На вход программе в первой строке подается строка соответствия латинскому алфавиту, в следующей — текст, требующий перевода.
# Формат выходных данных
# Программа должна с помощью данной строки соответствия латинскому алфавиту перевести введенный текст и вывести полученный результат.
# Примечание 1. Программа должна игнорировать все символы, не являющиеся латинскими буквами.
# Примечание 2. Составить словарь соответствия можно с помощью строкового метода maketrans(), подробнее о котором рассказывается по ссылке.
# ---------------------------------------------------------------------------

# import string

alphabet1 = input()  # [i.lower() for i in input()]
alphabet2 = string.ascii_lowercase

dict1 = dict(zip(alphabet2, alphabet1))

string1 = input().lower()
s = ''
for el in string1:
    if el in dict1:
        s += dict1[el]
    else:
        s += el
print(s)
# -------------ПРЕПОД-------------------------------------------------
# from string import ascii_letters

translator = str.maketrans(ascii_letters, input() * 2)
print(input().translate(translator))
# ===========================================================================


#
# Дополните приведенный ниже код, чтобы он создал именованный кортеж Fruit с полями name, color и vitamins.
# Примечание. Программа ничего не должна выводить.

# ---------------------------------------------------------------------------
# from collections import namedtuple

Fruit = namedtuple('Fruit', ['name', 'color', 'vitamins'])
fruit = Fruit('1', '2', '3')
# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен именованный кортеж Game. Дополните приведенный ниже код, чтобы он создал именованный кортеж типа ExtendedGame, имеющий те же поля, что и Game, а также два дополнительных поля — release_date и price.
# Примечание. Программа ничего не должна выводить.
# ---------------------------------------------------------------------------
# from collections import namedtuple

Game = namedtuple('Game', 'name developer publisher')

ExtendedGame = namedtuple(
    'ExtendedGame', 'name developer publisher release_date price')
# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен именованный кортеж Animal, который содержит данные о животном. Первым элементом именованного кортежа является имя животного, вторым — семейство, третьим — пол, четвертым — цвет. Также доступен файл data.pkl, содержащий сериализованный список таких кортежей.

# Дополните приведенный ниже код, чтобы для каждого кортежа из этого списка он вывел названия его полей и значения этих полей в следующем формате:

# name: <значение>
# family: <значение>
# sex: <значение>
# color: <значение>

# Между полями и значениями двух разных кортежей должна располагаться пустая строка.
# Примечание 1. Сначала должно следовать содержание первого кортежа из списка, затем второго, и так далее.
# Примечание 2. Например, если бы файл data.pkl содержал следующий сериализованный список:
# [Animal(name='Alex', family='dogs', sex='m', color='brown'), Animal(name='Nancy', family='dogs', sex='w', color='black')]
#
# 872
# ---------------------------------------------------------------------------

# import pickle
# from collections import namedtuple

Animal = namedtuple('Animal', ['name', 'family', 'sex', 'color'])

with open('data.pkl', 'rb') as file:
    # load() принимает файловый объект, читает из него сериализованные данные
    obj = pickle.load(file)

    for el in obj:
        a, b, c, d = el
        print(f'''name: {a}
family: {b}
sex: {c}
color: {d}
''')
# ===========================================================================
# from collections import namedtuple
# import pickle

Animal = namedtuple('Animal', ['name', 'family', 'sex', 'color'])

with open('data.pkl', 'rb') as animals_f:
    for animal in pickle.load(animals_f):
        print('name: {}\nfamily: {}\nsex: {}\ncolor: {}\n'.format(*animal))
# ===========================================================================

Animal = namedtuple('Animal', ['name', 'family', 'sex', 'color'])

with open(r'data.pkl', 'rb') as f:
    a = pickle.load(f)
    for i in a:
        for k, v in i._asdict().items():
            print(f'{k}: {v}')
        print()
# ===========================================================================

Animal = namedtuple('Animal', ('name', 'family', 'sex', 'color'))

with open('data.pkl', 'rb') as fi:
    animals = pickle.load(fi)

for animal in animals:
    for key, value in zip(Animal._fields, animal):
        print(f'{key}: {value}')
    print()

#
# # Вам доступен именованный кортеж User, который содержит данные о пользователе некоторого ресурса. Первым элементом именованного кортежа является имя пользователя, вторым — фамилия, третьим — адрес электронной почты, четвертым — статус оформленной подписки. Также доступен список users, содержащий эти кортежи.
# Дополните приведенный ниже код, чтобы он вывел данные о каждом пользователе из этого списка, предварительно отсортировав их по статусу подписки от дорогой к дешевой, а при совпадении статусов — в лексикографическом порядке адресов электронных почт. Данные о каждом пользователе должны быть указаны в следующем формате:

# <имя> <фамилия>
#   Email: <адрес электронной почты>
#   Plan: <статус подписки>
# Между данными двух разных пользователей должна располагаться пустая строка.
# Примечание 1. Самой дорогой подпиской считается Gold, затем Silver, Bronze и Basic.
# Примечание 2. Начальная часть ответа выглядит так (в качестве отступов используйте два пробела):
# 919
# ---------------------------------------------------------------------------
# from collections import namedtuple

User = namedtuple('User', ['name', 'surname', 'email', 'plan'])

users = [User('Mary', 'Griffin', 'sonnen@yahoo.com', 'Basic'),
         User('Brenda', 'Young', 'retoh@outlook.com', 'Silver'),
         User('Kathleen', 'Lyons', 'balchen@att.net', 'Gold'),
         User('Pamela', 'Hicks', 'corrada@sbcglobal.net', 'Silver'),
         User('William', 'Townsend', 'kosact@verizon.net', 'Gold'),
         User('Clayton', 'Morris', 'berserk@yahoo.com', 'Silver'),
         User('Dorothy', 'Dennis', 'sequin@live.com', 'Gold'),
         User('Tyler', 'Walker', 'noahb@comcast.net', 'Basic'),
         User('Joseph', 'Moore', 'ylchang@sbcglobal.net', 'Silver'),
         User('Kenneth', 'Richardson', 'tbusch@me.com', 'Bronze'),
         User('Stephanie', 'Bush', 'neuffer@live.com', 'Gold'),
         User('Gregory', 'Hughes', 'juliano@att.net', 'Basic'),
         User('Tracy', 'Wallace', 'sblack@me.com', 'Silver'),
         User('Russell', 'Smith', 'isaacson@comcast.net', 'Bronze'),
         User('Megan', 'Patterson', 'hoangle@outlook.com', 'Basic')]

l1 = sorted(filter(lambda x: x.plan == 'Gold', users), key=lambda x: x.email)
l2 = sorted(filter(lambda x: x.plan == 'Silver', users), key=lambda x: x.email)
l3 = sorted(filter(lambda x: x.plan == 'Bronze', users), key=lambda x: x.email)
l4 = sorted(filter(lambda x: x.plan == 'Basic', users), key=lambda x: x.email)
users_sort = l1 + l2 + l3 + l4

for el in users_sort:
    print(f'{el.name} {el.surname}')
    print(f'  Email: {el.email}')
    print(f'  Plan: {el.plan}')
    print()
# ---------------------------------------------------------------------------
# from collections import namedtuple

User = namedtuple('User', ['name', 'surname', 'email', 'plan'])

users = [User('Mary', 'Griffin', 'sonnen@yahoo.com', 'Basic'),
         User('Brenda', 'Young', 'retoh@outlook.com', 'Silver'),
         User('Kathleen', 'Lyons', 'balchen@att.net', 'Gold'),
         User('Pamela', 'Hicks', 'corrada@sbcglobal.net', 'Silver'),
         User('William', 'Townsend', 'kosact@verizon.net', 'Gold'),
         User('Clayton', 'Morris', 'berserk@yahoo.com', 'Silver'),
         User('Dorothy', 'Dennis', 'sequin@live.com', 'Gold'),
         User('Tyler', 'Walker', 'noahb@comcast.net', 'Basic'),
         User('Joseph', 'Moore', 'ylchang@sbcglobal.net', 'Silver'),
         User('Kenneth', 'Richardson', 'tbusch@me.com', 'Bronze'),
         User('Stephanie', 'Bush', 'neuffer@live.com', 'Gold'),
         User('Gregory', 'Hughes', 'juliano@att.net', 'Basic'),
         User('Tracy', 'Wallace', 'sblack@me.com', 'Silver'),
         User('Russell', 'Smith', 'isaacson@comcast.net', 'Bronze'),
         User('Megan', 'Patterson', 'hoangle@outlook.com', 'Basic')]

# key=lambda x: (('Gold', 'Silver', 'Bronze', 'Basic').index(x.plan), x.email)
# index(x.plan) - это индекс элемента из кортежа ('Gold', 'Silver', 'Bronze', 'Basic'). Проще на примере. Допустим, у нас x.plan у данного User'a ,будет 'Gold'. Тогда получаем  ('Gold', 'Silver', 'Bronze', 'Basic').index('Gold'). А какой индекс у элемента 'Gold' в этом кортеже? Ноль. Соответственно,  приоритет у него выше и он выведется раньше.
# Кстати, вместо кортежа я использовал список - суть та же - мы получаем индекс элемента в последовательности. Правда, для наглядности я вывел это в отдельную функцию c самостоятельной переменной:
# def sorting(x):
#     a = ["Gold", 'Silver','Bronze', 'Basic']
#     return a.index(x.plan)

for i in sorted(users, key=lambda x: ('drec'.index(x.plan[-1]), x.email)):
    print(f'{i.name} {i.surname}\n  Email: {i.email}\n  Plan: {i.plan}\n')
# ===========================================================================


# Вы кто такие? Я вас не звал
# 870
# У Тимура имеется немало друзей из других городов или стран, которые часто приезжают к нему в гости с целью увидеться и развлечься. Чтобы не забыть ни об одной встрече, Тимур записывает имена и фамилии друзей в csv файл, дополнительно указывая для каждого дату и время встречи. Вам доступен этот файл, имеющий название meetings.csv, в котором в первом столбце записана фамилия, во втором — имя, в третьем — дата в формате DD.MM.YYYY , в четвертом — время в формате HH:MM:
# surname,name,meeting_date,meeting_time
# Харисов,Артур,15.07.2022,17:00
# Геор,Гагиев,14.12.2022,18:00
# ...
# Напишите программу, которая выводит фамилии и имена друзей Тимура, предварительно отсортировав их по дате и времени встречи от самой ранней до самой поздней. Фамилии и имена должны быть расположены каждые на отдельной строке.
# Примечание 1. Начальная часть ответа выглядит так:
# Гудцев Таймураз
# Харисов Артур
# Базиев Герман
# ...
# Примечание 2. Гарантируется, что никакие две встречи не имеют одновременно одинаковые даты и время.
# Примечание 3. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 4. Разделителем в файле meetings.csv является запятая, при этом кавычки не используются.
# Примечание 5. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# import csv
# from collections import namedtuple
# from datetime import datetime

with open('meetings.csv', 'rt', encoding='utf-8') as file:
    # создаем reader объект и указываем в качестве разделителя символ ','
    rows = list(csv.reader(file, delimiter=','))

headers = rows.pop(0)  # заголовки

Friends = namedtuple('Friends', headers)

l1 = []
for user in rows:
    def func1(x): return (x[0], x[1], datetime.strptime(
        x[2], '%d.%m.%Y'), datetime.strptime(x[3], '%H:%M'))
    friend = Friends(*func1(user))
    l1.append(friend)

l1 = sorted(l1, key=lambda x: (x.meeting_date, x.meeting_time))

for el in l1:
    print(f'{el.surname} {el.name}')
# ---------------------------------------------------------------------------
# import csv
# from collections import namedtuple
# from datetime import datetime

with open('meetings.csv', encoding='u8') as fi:
    rows = csv.DictReader(fi)
    Friend = namedtuple('Friend', rows.fieldnames)
    meetings = [Friend(**row) for row in rows]

meetings.sort(key=lambda item: datetime.strptime(
    f'{item.meeting_date} {item.meeting_time}', '%d.%m.%Y %H:%M'))
for meeting in meetings:
    print(meeting.surname, meeting.name)
# ===========================================================================


#  Вам доступен список кортежей data с данными о доходах некоторого образовательного ресурса. Первым элементом кортежа является название продукта, вторым — прибыль в долларах.
# Дополните приведенный ниже код, чтобы он определил, какой общий доход принес каждый продукт и вывел названия всех продуктов, указав для каждого соответствующую общую прибыль. Продукты должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <продукт>: $<общая прибыль>
# Примечание. Начальная часть ответа выглядит так:
# Books: $7969
# Courses: $2991
#
# 503
# ---------------------------------------------------------------------------

# from collections import defaultdict

data = [('Books', 1343), ('Books', 1166), ('Merch', 616), ('Courses', 966), ('Merch', 1145), ('Courses', 1061), ('Books', 848), ('Courses', 964), ('Tutorials', 832), ('Merch', 642),
        ('Books', 815), ('Tutorials', 1041), ('Books', 1218), ('Tutorials', 880), ('Books', 1003), ('Merch', 951), ('Books', 920), ('Merch', 729), ('Tutorials', 977), ('Books', 656)]

products = defaultdict(int)

for key, value in data:
    products[key] += value

for key, value in sorted(products.items()):
    print(f'{key}: ${value}')
# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен список кортежей staff с данными о сотрудниках некоторой компании. Первым элементом кортежа является название отдела, вторым — имя и фамилия сотрудника, работающего в этом отделе.
# Дополните приведенный ниже код, чтобы он определил, какое число сотрудников работает в каждом отделе и вывел названия всех отделов, указав для каждого соответствующее количество сотрудников. Отделы должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <отдел>: <количество сотрудников>
# Примечание. Начальная часть ответа выглядит так:
# Accounting: 17
# Developing: 7

# 720
# ---------------------------------------------------------------------------
# from collections import defaultdict

staff = [('Sales', 'Robert Barnes'), ('Developing', 'Thomas Porter'), ('Accounting', 'James Wilkins'), ('Sales', 'Connie Reid'), ('Accounting', 'Brenda Davis'), ('Developing', 'Miguel Norris'), ('Accounting', 'Linda Hudson'), ('Developing', 'Deborah George'), ('Developing', 'Nicole Watts'), ('Marketing', 'Billy Lloyd'), ('Sales', 'Charlotte Cox'), ('Marketing', 'Bernice Ramos'), ('Sales', 'Jose Taylor'), ('Sales', 'Katie Warner'), ('Accounting', 'Steven Diaz'), ('Accounting', 'Kimberly Reynolds'), ('Accounting', 'John Watts'), ('Accounting', 'Dale Houston'), ('Developing', 'Arlene Gibson'), ('Marketing', 'Joyce Lawrence'), ('Accounting', 'Rosemary Garcia'), ('Marketing', 'Ralph Morgan'), ('Marketing', 'Sam Davis'), ('Marketing', 'Gail Hill'), ('Accounting',
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  'Michelle Wright'), ('Accounting', 'Casey Jenkins'), ('Sales', 'Evelyn Martin'), ('Accounting', 'Aaron Ferguson'), ('Marketing', 'Andrew Clark'), ('Marketing', 'John Gonzalez'), ('Developing', 'Wilma Woods'), ('Sales', 'Marie Cooper'), ('Accounting', 'Kay Scott'), ('Sales', 'Gladys Taylor'), ('Accounting', 'Ann Bell'), ('Accounting', 'Craig Wood'), ('Accounting', 'Gloria Higgins'), ('Marketing', 'Mario Reynolds'), ('Marketing', 'Helen Taylor'), ('Marketing', 'Mary King'), ('Accounting', 'Jane Jackson'), ('Marketing', 'Carol Peters'), ('Sales', 'Alicia Mendoza'), ('Accounting', 'Edna Cunningham'), ('Developing', 'Joyce Rivera'), ('Sales', 'Joseph Lee'), ('Sales', 'John White'), ('Marketing', 'Charles Bailey'), ('Sales', 'Chester Fernandez'), ('Sales', 'John Washington')]

workers = defaultdict(list)

for key, value in staff:
    workers[key].append(value)

for key, value in sorted(workers.items()):
    print(f'{key}: {len(value)}')
# ---------------------------------------------------------------------------

# ===========================================================================


#
# Вам доступен список кортежей staff_broken с данными о сотрудниках некоторой компании. Первым элементом кортежа является название отдела, вторым — имя и фамилия сотрудника, работающего в этом отделе. Некоторые сотрудники могут встречаться в списке несколько раз.
# Дополните приведенный ниже код, чтобы он сгруппировал сотрудников по соответствующим отделам и вывел названия всех отделов, указав для каждого имена и фамилии его сотрудников. Отделы, а также имена и фамилии сотрудников в этих отделах, должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <отдел>: <имя> <фамилия>, <имя> <фамилия>, ...
# Примечание. Начальная часть ответа выглядит так:
# Accounting: Aaron Ferguson, Ann Bell, Brenda Davis, Casey Jenkins, Craig Wood, Dale Houston, Edna Cunningham, Gloria Higgins, James Wilkins, Jane Jackson, John Watts, Kay Scott, Kimberly Reynolds, Linda Hudson, Michelle Wright, Rosemary Garcia, Steven Diaz
# Developing: Arlene Gibson, Deborah George, Joyce Rivera, Miguel Norris, Nicole Watts, Thomas Porter, Wilma Woods
# ...
# 721
# ---------------------------------------------------------------------------

# from collections import defaultdict

staff_broken = [('Developing', 'Miguel Norris'), ('Sales', 'Connie Reid'), ('Sales', 'Joseph Lee'), ('Marketing', 'Carol Peters'), ('Accounting', 'Linda Hudson'), ('Accounting', 'Ann Bell'), ('Marketing', 'Ralph Morgan'), ('Accounting', 'Gloria Higgins'), ('Developing', 'Wilma Woods'), ('Developing', 'Wilma Woods'), ('Marketing', 'Bernice Ramos'), ('Marketing', 'Joyce Lawrence'), ('Accounting', 'Craig Wood'), ('Developing', 'Nicole Watts'), ('Sales', 'Jose Taylor'), ('Accounting', 'Linda Hudson'), ('Accounting', 'Edna Cunningham'), ('Sales', 'Jose Taylor'), ('Marketing', 'Helen Taylor'), ('Accounting', 'Kimberly Reynolds'), ('Marketing', 'Mary King'), ('Sales', 'Joseph Lee'), ('Accounting', 'Gloria Higgins'), ('Marketing', 'Andrew Clark'), ('Accounting', 'John Watts'), ('Accounting', 'Rosemary Garcia'), ('Accounting', 'Steven Diaz'), ('Marketing', 'Mary King'), ('Sales', 'Gladys Taylor'), ('Developing', 'Thomas Porter'), ('Accounting', 'Brenda Davis'), ('Sales', 'Connie Reid'), ('Sales', 'Alicia Mendoza'), ('Marketing', 'Mario Reynolds'), ('Sales', 'John White'), ('Developing', 'Joyce Rivera'), ('Accounting',
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         'Steven Diaz'), ('Developing', 'Arlene Gibson'), ('Sales', 'Robert Barnes'), ('Sales', 'Charlotte Cox'), ('Accounting', 'Craig Wood'), ('Marketing', 'Carol Peters'), ('Marketing', 'Ralph Morgan'), ('Accounting', 'Kay Scott'), ('Sales', 'Evelyn Martin'), ('Marketing', 'Billy Lloyd'), ('Sales', 'Gladys Taylor'), ('Developing', 'Deborah George'), ('Sales', 'Charlotte Cox'), ('Marketing', 'Sam Davis'), ('Sales', 'John White'), ('Sales', 'Marie Cooper'), ('Marketing', 'John Gonzalez'), ('Sales', 'John Washington'), ('Sales', 'Chester Fernandez'), ('Sales', 'Alicia Mendoza'), ('Sales', 'Katie Warner'), ('Accounting', 'Jane Jackson'), ('Sales', 'Chester Fernandez'), ('Marketing', 'Charles Bailey'), ('Marketing', 'Gail Hill'), ('Accounting', 'Casey Jenkins'), ('Accounting', 'James Wilkins'), ('Accounting', 'Casey Jenkins'), ('Marketing', 'Mario Reynolds'), ('Accounting', 'Aaron Ferguson'), ('Accounting', 'Kimberly Reynolds'), ('Sales', 'Robert Barnes'), ('Accounting', 'Aaron Ferguson'), ('Accounting', 'Jane Jackson'), ('Developing', 'Deborah George'), ('Accounting', 'Michelle Wright'), ('Accounting', 'Dale Houston')]

workers = defaultdict(set)

for key, value in staff_broken:
    workers[key].add(value)

for key, value in sorted(workers.items()):
    print(f'{key}: {", ".join(sorted(value))}')
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция wins()
# 727
# В онлайн-школе BEEGEEK каждое лето проходят соревнования по шахматам, во время которых ведется статистика побед и поражений. Каждая партия описывается кортежем из двух элементов, где первый элемент — имя победившего ученика, второй элемент — имя проигравшего ученика.
# Реализуйте функцию wins(), которая принимает один аргумент:
#     pairs — итерируемый объект, элементами которого являются кортежи, каждый из которых представляет собой пару имён победитель-проигравший
# Функция должна возвращать словарь, в котором ключом служит имя ученика, а значением — множество (тип set) имен учеников, которых он победил.
# Примечание 1. Гарантируется, что каждая партия заканчивается победой одного из учеников, то есть ничьей быть не может.
# Примечание 2. Элементы в возвращаемом функцией словаре могут располагаться в произвольном порядке.
# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию wins(), но не код, вызывающий ее.
# Примечание 4. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------

# from collections import defaultdict

def wins(pairs):
    d_dict = defaultdict(set)

    for key, value in pairs:
        d_dict[key].add(value)

    return d_dict
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция flip_dict()
# 723
# Рассмотрим следующий словарь:
# {'a': [1, 2], 'b': [3, 1], 'c': [2]}
# «Перевернем» его, представив ключи в виде значений, а значения — в виде ключей:
# {1: ['a', 'b'], 2: ['a', 'c'], 3: ['b']}
# Реализуйте функцию flip_dict(), которая принимает один аргумент:
#     dict_of_lists — словарь, в котором ключом является число или строка, а значением — список чисел или строк
# Функция должна возвращать новый словарь (тип defaultdict с типом list в качестве значения по умолчанию), который представляет собой «перевернутый» словарь dict_of_lists.
# Примечание 1. Ключи в возвращаемом функцией словаре, а также элементы в списках должны располагаться в своем исходном порядке.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию flip_dict(), но не код, вызывающий ее.

# from collections import defaultdict

def flip_dict(dict_of_lists):

    d_dict1 = defaultdict(list)

    for a, b in dict_of_lists.items():
        for el in b:
            d_dict1[el].append(a)

    d_dict2 = defaultdict(list)

    for key, value in d_dict1.items():
        for el in value:
            d_dict2[key].append(el)

    return d_dict2
# ------------------НЕ СОЗДАВАЯ ЛИШНИЙ СЛОВАРЬ, как решение выше----------------------------------------------
# from collections import defaultdict


def flip_dict(data):
    fliped_data = defaultdict(list)
    for key, values in data.items():
        for value in values:
            fliped_data[value].append(key)
    return fliped_data
# ===========================================================================


def flip_dict(d_l):
    d_n = __import__('collections').defaultdict(list)
    [d_n[v].append(k) for k in d_l for v in d_l[k]]
    return d_n
# ===========================================================================

# Функция best_sender()
# 648
# # Рассмотрим два списка:
# messages = ['Hi, Linda', 'Hi, Sam', 'How are you doing?']
# senders = ['Sam Fisher', 'Linda', 'Sam Fisher']
# Первый список представляет набор отправленных сообщений в некотором мессенджере, второй список — набор отправителей этих сообщений. Причем сообщение messages[i] отправлено пользователем senders[i]. Каждое сообщение представляет собой последовательность слов, разделенных пробелом (знаки препинания считаются частями слов). Количество слов — это общее число слов, отправленное пользователем. Обратите внимание, что каждый пользователь может отправлять более одного сообщения. Например, пользователь Sam Fisher отправил 22 слова в первом сообщении и 44 слова во втором, следовательно, его количество слов равно 2+4=62+4=6.
# Реализуйте функцию best_sender(), которая принимает два аргумента в следующем порядке:
#     messages — список сообщений
#     senders — список имен отправителей
# Функция должна определять отправителя, имеющего наибольшее количество слов, и возвращать его имя. Если таких отправителей несколько, следует вернуть имя того, чье имя больше в лексикографическом сравнении.
# Примечание 1. Гарантируется, что длины передаваемых в функцию списков совпадают.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию best_sender(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

# from collections import defaultdict


def best_sender(messages, senders):

    d_dict = defaultdict(list)

    for message, sender in zip(messages, senders):
        d_dict[sender].extend(message.split())

    l1 = sorted(d_dict.items(), key=lambda x: len(x[1]), reverse=True)
    mx = len(l1[0][1])

    l1 = list(filter(lambda x: len(x[1]) == mx, l1))
    l1 = sorted(l1, key=lambda x: x[0], reverse=True)

    return l1[0][0]
# ---------------------------------------------------------------------------
# from collections import defaultdict


def best_sender(messages, senders):
    result = defaultdict(int)
    for sender, message in zip(senders, messages):
        result[sender] += len(message.split())
    # сортировка max максимального значения в кортеже
    return max(result, key=lambda p: (result[p], p))
# ===========================================================================
# from collections import defaultdict as _dd


def best_sender(*data):
    res = _dd(int)
    for message, sender in zip(*data):
        # Количество слов в сообщении равно количеству пробелов плюс единица. И в топовых решениях, и в комментариях все сразу кинулись считать длину списка после сплита...
        # Зачем создавать, пусть и временный, но список, потом замерять его длину, если можно не создавая новых объектов уже в существующей строке сразу всё посчитать?
        res[sender] += message.count(' ') + 1
    return max(res, key=lambda sender: (res[sender], sender))
# ===========================================================================

#
#
# Вам доступен словарь data. Дополните приведенный ниже код, чтобы он вывел данный словарь, расположив его элементы в обратном порядке.
# Примечание. Например, если бы словарь data имел вид:
# data = OrderedDict(key1='value1', key2='value2', key3='value3')
# то программа должна была бы вывести:
# OrderedDict([('key3', 'value3'), ('key2', 'value2'), ('key1', 'value1')])
# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------
# from collections import OrderedDict
data = OrderedDict({'Name': 'Брусника', 'IsNetObject': 'да', 'OperatingCompany': 'Брусника', 'TypeObject': 'кафе',
                   'AdmArea': 'Центральный административный округ', 'District': 'район Арбат', 'Address': 'город Москва, переулок Сивцев Вражек, дом 6/2', 'SeatsCount': '10'})

for key in list(data):
    data.move_to_end(key, last=False)

print(data)
# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#  976
# Вам доступен список files, содержащий названия различных файлов. Дополните приведенный ниже код, чтобы он вывел все расширения файлов, присутствующие в списке files, указав для каждого количество файлов с данным расширением. Расширения должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <расширение>: <количество файлов>
#
# from collections import Counter

files = ['emoji_smile.jpeg', 'city-of-the-sun.mp3', 'dhook_hw.json', 'sample.xml',
         'teamspeak3.exe', 'project_module3.py', 'math_lesson3.mp4', 'old_memories.mp4',
         'spiritfarer.exe', 'backups.json', 'python_for_beg1.mp4', 'emoji_angry.jpeg',
         'exam_results.csv', 'project_main.py', 'classes.csv', 'plants.xml',
         'cant-help-myself.mp3', 'microsoft_edge.exe', 'steam.exe', 'math_lesson4.mp4',
         'city.jpeg', 'bad-disease.mp3', 'beauty.jpeg', 'hollow_knight_silksong.exe',
         'whatsapp.exe', 'photoshop.exe', 'telegram.exe', 'yandex_browser.exe',
         'math_lesson7.mp4', 'students.csv', 'emojis.zip', '7z.zip',
         'bones.mp3', 'python3.zip', 'dhook_lsns.json', 'carl_backups.json',
         'forest.jpeg', 'python_for_pro8.mp4', 'yandexdisc.exe', 'but-you.mp3',
         'project_module1.py', 'nothing.xml', 'flowers.jpeg', 'grades.csv',
         'nvidia_gf.exe', 'small_txt.zip', 'project_module2.py', 'tab.csv',
         'note.xml', 'sony_vegas11.exe', 'friends.jpeg', 'data.pkl']

files1 = map(lambda x: x.split('.')[1], files)
cnt1 = Counter(files1)

for key, value in sorted(dict(cnt1).items()):
    print(f'{key}: {value}')
    print(f'{key}: {value}')

# ---------------------------------------------------------------------------

# ===========================================================================


# Функция count_occurences()
# 984
# Реализуйте функцию count_occurences(), которая принимает два аргумента в следующем порядке:
#     word — слово
#     words — последовательность слов, разделенных пробелом
# Функция должна определять, сколько раз слово word встречается в последовательности words, и возвращать полученный результат.
# Примечание 1. Функция должна игнорировать регистр. То есть, например, слова Python и python считаются одинаковыми.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию count_occurences(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
# from collections import Counter

def count_occurences(word1, words1):
    cnt = Counter([i.lower() for i in words1.split()])

    return cnt[word1.lower()]
# ---------------------------------------------------------------------------
# from collections import Counter


def count_occurences(word, words):
    return Counter(words.lower().split())[word.lower()]
# ===========================================================================


# Не поленимся и запишем
# 983
# Тимур составляет список покупок, но так как на его клавиатуре перестал работать блок с цифрами, то вместо указания количества товара числом, он добавляет его в список столько раз, сколько планирует купить. Все товары Тимур записывает в нижнем регистре через запятую.
# Напишите программу, которая выводит все товары из данного списка покупок, указывая для каждого его количество.
# Формат входных данных
# На вход программе подается последовательность товаров, разделенных запятой без пробелов.
# Формат выходных данных
# Программа должны вывести все введенные товары, указывая для каждого, сколько раз он встречается в данной последовательности. Товары должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <товар>: <количество>
# ---------------------------------------------------------------------------
# from collections import Counter

cnt = Counter(input().split(','))

for key, value in sorted(cnt.items()):
    print(f"{key}: {value}")
# ---------------------------------------------------------------------------

# ===========================================================================


# А сколько стоит курс?
# 948
# Тимур живет в мире, в котором цена товара определяется как сумма Unicode кодов букв его названия. Буквенным обозначением данной валюты являются две заглавные латинские буквы UC. Например, ручка в его мире стоит:
# 1088+1091+1095+1082+1072=5428  UC
# Тимур составляет список покупок, но так как на его клавиатуре перестал работать блок с цифрами, то вместо указания количества товара числом, он добавляет его в список столько раз, сколько планирует купить. Все товары Тимур записывает в нижнем регистре через запятую.
# Напишите программу, которая группирует одинаковые товары из данного списка покупок и определяет стоимость каждой группы.
# Формат входных данных
# На вход программе подается последовательность товаров, разделенных запятой без пробелов.
# Формат выходных данных
# Программа должна сгруппировать одинаковые товары, определить общую стоимость каждой группы и вывести полученный результат. Товары должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <товар>: <цена за единицу товара> UC x <количество товаров в группе> = <общая стоимость группы> UC
# Примечание 1. Программа должна добавлять нужное количество пробелов, если название товара имеет меньшую длину, чем другие.
# Примечание 2. Получить Unicode код символа можно с помощью функции ord().
# Примечание 3. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------
# from collections import Counter

def func_Output(commodity, amount, width):
    sum_codes_letters = sum(map(lambda x: ord(x), commodity.replace(' ', '')))

    return f'{commodity.ljust(width, " ")}: {sum_codes_letters} UC x {amount} = {sum_codes_letters * amount} UC'


cnt = Counter(input().split(','))

# длина отступа
width = len(max(cnt.keys(), key=len))

for key, value in sorted(cnt.items()):
    print(func_Output(key, value, width))
# ---------------------------------------------------------------------------
# from collections import Counter


def get_price(product):
    return sum(map(ord, filter(str.isalpha, product)))


products = Counter(input().split(','))
pattern = '{}: {} UC x {} = {} UC'
spaces = max(map(len, products))

for product, count in sorted(products.items()):
    price = get_price(product)
    total = price * count
    product = product.ljust(spaces, ' ')
    print(pattern.format(product, price, count, total))
# ===========================================================================


# The Zen of Python
# 962
# Вам доступен текстовый файл pythonzen.txt, содержащий текст на английском языке:
# Напишите программу, которая определяет, сколько раз встречается каждая буква в этом тексте. Буквы и их количество должны выводиться в лексикографическом порядке, каждая на отдельной строке, в следующем формате:
# <буква>: <количество>
# Примечание 1. Начальная часть ответа выглядит так:
# Примечание 2. Программа не должна учитывать регистр, то есть, например, буквы a и A считаются одинаковыми.
# Примечание 3. Программа должна игнорировать все небуквенные символы.
# Примечание 4. Указанный файл доступен по ссылке. Ответ на задачу доступен по ссылке.
# Примечание 5. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

# from collections import Counter
# import string

with open('pythonzen.txt', 'rt', encoding='utf-8') as file:
    content = file.read()

cnt = Counter(content.lower())

for key, value in sorted(cnt.items()):
    if key in string.ascii_lowercase:
        print(f"{key}: {value}")


# ---------------------------------------------------------------------------

# ===========================================================================

# В поисках слов 😇
# 962
# Дана последовательность слов. Напишите программу, которая выводит наиболее часто встречаемое слово в этой последовательности.
# Формат входных данных
# На вход программе подается последовательность слов, разделенных пробелом.
# Формат выходных данных
# Программа должна определить наиболее часто встречаемое слово в введенной последовательности и вывести его в нижнем регистре.
# Примечание 1. Гарантируется, что искомое слово единственное.
# Примечание 2. Программа должна игнорировать регистр. То есть, например, слова Python и python считаются одинаковыми.
# ---------------------------------------------------------------------------

# from collections import Counter

words = [i.lower() for i in input().split()]
cnt = Counter(words)

print(max(cnt.items(), key=lambda x: x[1])[0])
# ---------------------------------------------------------------------------
print(__import__('collections').Counter(
    input().lower().split()).most_common()[0][0])
# ===========================================================================
# from collections import Counter

counter = Counter(input().lower().split())
print(counter.most_common()[0][0])
# ===========================================================================

# В поисках слов 😋
# 967
# Дана последовательность слов. Напишите программу, которая выводит наименее часто встречаемое слово в этой последовательности. Если таких слов несколько, программа должна вывести их все.
# Формат входных данных
# На вход программе подается последовательность слов, разделенных пробелом.
# Формат выходных данных
# Программа должна определить наименее часто встречаемое слово в введенной последовательности и вывести его в нижнем регистре. Если таких слов несколько, программа должна вывести их все в лексикографическом порядке, в нижнем регистре, разделяя запятой и пробелом.
# Примечание 1. Программа должна игнорировать регистр. То есть, например, слова Python и python считаются одинаковыми.
# ---------------------------------------------------------------------------

# from collections import Counter

words = [i.lower() for i in input().split()]
cnt = Counter(words)

mn = cnt.most_common()[-1][1]

l1 = list(filter(lambda x: x[1] == mn, cnt.most_common()[::-1]))
l1 = ', '.join(map(lambda x: x[0], sorted(l1)))

print(l1)
# ---------------------------------------------------------------------------

# ===========================================================================


# В поисках слов 🥳
# 956
# Дана последовательность слов. Напишите программу, которая выводит наиболее часто встречаемое слово в этой последовательности. Если таких слов несколько, программа должна вывести то, которое больше в лексикографическом сравнении.
# Формат входных данных
# На вход программе подается последовательность слов, разделенных пробелом.
# Формат выходных данных
# Программа должна определить наиболее часто встречаемое слово в введенной строке и вывести его в нижнем регистре. Если таких слов несколько, программа должна вывести то, которое больше в лексикографическом сравнении, также в нижнем регистре.
# Примечание 1. Программа должна игнорировать регистр. То есть, например, слова Python и python считаются одинаковыми.
# ---------------------------------------------------------------------------


words = [i.lower() for i in input().split()]
cnt = Counter(words)

mn = cnt.most_common()[0][1]

l1 = list(filter(lambda x: x[1] == mn, cnt.most_common()))
l1 = ', '.join(map(lambda x: x[0], sorted(l1)))

print(l1)

# ---------------------------------------------------------------------------

# ===========================================================================


# Статистика длин слов
# 942
# Дана последовательность слов. Напишите программу, которая группирует слова из этой последовательности по их длине и определяет количество слов в каждой полученной группе.
# Формат входных данных
# На вход программе подается последовательность слов, разделенных пробелом.
# Формат выходных данных
# Программа должна сгруппировать слова из введенной последовательности по их длине и определить количество слов в каждой полученной группе. Каждую группу характеризуют два числа — длина слов в этой группе и количество слов в этой группе. Например, для группы {is, to, hi, no} это числа 2 и 4. Программа должна вывести данные о каждой группе, расположив их в порядке увеличения количества слов в них, каждые на отдельной строке, в следующем формате:
# Слов длины <длина слов в группе>: <количество слов в группе>
# Примечание 1. Если две разные группы имеют равное количество слов, то первой должна следовать та группа, слово которой в исходной последовательности встречается раньше.
# ---------------------------------------------------------------------------

# from collections import defaultdict

s = input().split()
words = [(len(i), i.lower()) for i in s]

d_dict = defaultdict(list)


for len_word, word in words:
    d_dict[len_word].append(word)


for key, value in sorted(d_dict.items(), key=lambda x: len(x[1])):
    print(f"Слов длины {key}: {len(value)}")
# ---------------------------------------------------------------------------
# from collections import Counter

res = Counter(len(word) for word in input().split())

for k, v in sorted(res.items(), key=lambda t: t[1]):
    print(f'Слов длины {k}: {v}')
# ===========================================================================


# Все еще достоин
# 9636
# Дан список имен учеников и их оценок за экзамДан список имен учеников и их оценок за экзамен. Напишите программу, которая определяет второго по счету ученика, имеющего самую низкую оценку.
# Формат входных данных
# На вход программе подается произвольное количество строк, в каждой из которых записаны имя очередного ученика и его оценка, разделенные пробелом.
# Формат выходных данных
# Программа должна определить второго по счету ученика, который имеет самую низкую оценку, и вывести его имя.
# Примечание 1. Гарантируется, что все ученики имеюа, который имеет самую низкую оценку, и вывести его имя.
# ---------------------------------------------------------------------------

# import sys
# from collections import Counter

l1 = [tuple(i.rstrip().split()) for i in sys.stdin.readlines()]
l1 = map(lambda x: (x[0], int(x[1])), l1)

cnt = Counter(lines)

print(cnt.most_common()[-2][0])
# ---------------------------------------------------------------------------
# from collections import Counter

res = Counter()

for man in open(0):
    name, grade = man.split()
    res[name] = int(grade)

print(res.most_common()[-2][0])
# ---------------------------------------------------------------------------
# from collections import Counter

c = Counter({i: int(j) for i, j in (s.split() for s in open(0))})
print(c.most_common()[-2][0])
# ===========================================================================


# Вам доступна переменная data, содержащая Counter словарь. Дополните приведенный ниже код, чтобы он добавил этому словарю два атрибута:
#     min_values() — функция, которая возвращает список элементов, имеющих наименьшее значение
#     max_values() — функция, которая возвращает список элементов, имеющих наибольшее значение
# Обе функции не должны принимать никаких аргументов.
# Примечание 1. Элементом словаря будем считать кортеж (ключ, значение).
# Примечание 2. Элементы словаря в возвращаемых функциями списках должны располагаться в своем исходном порядке.
# Примечание 3. Функции data.min_values() и data.max_values() должны учитывать содержимое словаря. Например, если в словарь data будет добавлена новая пара ключ-значение, то и в возвращаемых функциями списках данные ключ и значение должны присутствовать.
# Примечание 4. Программа ничего не должна выводить.
# 929
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Here we go again
# 907
# # Вам доступен файл name_log.csv, в котором находятся логи изменения имени пользователя. В первом столбце записано измененное имя пользователя, во втором — адрес электронной почты, в третьем — дата и время изменения. При этом email пользователь менять не может, только имя:
# username,email,dtime
# rare_charles6,charlesthompson@inbox.ru,15/11/2021 08:15
# busy_patricia5,patriciasmith@bk.ru,07/11/2021 08:07
# ...
# Напишите программу, которая определяет, сколько раз пользователь менял имя. Программа должна вывести адреса электронных почт пользователей, указав для каждого соответствующее количество смененных имен. Почтовые ящики должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <адрес электронной почты>: <количество изменений имен>
# Примечание 1. Начальная часть ответа выглядит так:
# barbaraanderson@bk.ru: 3
# barbarabrown@rambler.ru: 3
# ...
# Примечание 3. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------
# import csv
# from collections import defaultdict

with open('name_log.csv', 'rt', encoding='utf-8') as file:
    # rows = list(csv.reader(file)) # создаем reader объект
    # headers = rows.pop(0)  # удаляем шапку c заголовками csv-файда
    # for row in rows:
    #     print(row)

    rows = list(csv.DictReader(file, delimiter=','))

d_dict = defaultdict(list)

for row in rows:
    d_dict[row['email']].append((row['username'], row['dtime']))

for key, value in sorted(d_dict.items()):
    print(f"{key}: {len(value)}")
# ---------------------------------------------------------------------------
# from collections import Counter
# from csv import DictReader

with open('name_log.csv', encoding='utf-8') as file:
    logs = Counter([line['email'] for line in DictReader(file)])

for email in sorted(logs):
    print(f'{email}: {logs[email]}')
# ===========================================================================
with open('name_log.csv', encoding='utf-8') as file:
    data = __import__('csv').DictReader(file)
    counter = __import__('collections').Counter([i['email'] for i in data])
    for k, v in sorted(counter.most_common()):
        print(f'{k}: {v}')
# ===========================================================================
# import csv
# from collections import Counter

with open('name_log.csv', encoding='utf-8') as f:
    _, *base = csv.reader(f)
    res = Counter(l[1] for l in base)

for k, v in sorted(res.items()):
    print(f'{k}: {v}')
# ===========================================================================


# Функция scrabble()
# 953
# Реализуйте функцию scrabble(), которая принимает два аргумента в следующем порядке:
#     symbols — набор символов
#     word — слово
# Функция должна возвращать True, если из набора символов symbols можно составить слово word, или False в противном случае.
# Примечание 1. При проверке учитывается количество символов, которые нужны для составления слова, и не учитывается их регистр.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию scrabble(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
# from collections import Counter


def scrabble(symbols, word):

    letter1 = Counter(symbols.lower())
    letter2 = Counter(word.lower())

    return letter1 >= letter2
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция print_bar_chart()
#
# Реализуйте функцию print_bar_chart(), которая принимает два аргумента в следующем порядке:
#     data — строка или список строк
#     mark — одиночный символ
# Функция должна определять:
#     сколько раз встречается каждый символ в строке, если data является строкой
#     сколько раз встречается каждая строка в списке, если data является списком
# Затем функция должна выводить результат в виде столбчатой диаграммы, указывая каждый символ (строку) и его количество. Количество отображается как повторение символа mark соответствующее число раз, например, если mark='+', то количество, равное четырем, будет отображено как ++++. Символы (строки) в диаграмме должны быть расположены в порядке уменьшения количества, при равных количествах — в своем исходном порядке, каждая на отдельной строке, в следующем формате:
# <символ или строка> |<количество>
# Примечание 1. Обратите внимание на второй тест, функция должна добавлять нужное количество пробелов, если строка имеет меньшую длину, чем другие.
# Примечание 2. Программа должна учитывать регистр. То есть, например, строки Python и python считаются различными.
# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую функцию print_bar_chart(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

# from collections import Counter

def print_bar_chart(data, mark):
    cnt = Counter(data)

    weigth = len(max(cnt.keys(), key=len)) + 1

    for key, value in sorted(cnt.items(), key=lambda x: x[1], reverse=True):
        print(f"{key.ljust(weigth)}|{mark * value}")
# ---------------------------------------------------------------------------

# ===========================================================================


# Бесплатные курсы берут свое 😢
# 891
# Для дополнительного заработка Тимур решил заняться продажей овощей. У него имеются данные о продажах за год, разделенные на четыре файла по кварталам: quarter1.csv, quarter2.csv, quarter3.csv и quarter4.csv. В каждом файле в первом столбце указывается название продукта, а в последующих — количество проданного продукта в килограммах за определенный месяц:
# продукт,январь,февраль,март
# Картофель,39,61,3
# Дайкон,51,96,83
# ...
# Также присутствует файл prices.json, содержащий словарь, в котором ключом является название продукта, а значением — цена за килограмм в рублях:

# {
#    "Картофель": 53,
#    "Дайкон": 55,
# ...
# }
# Напишите программу, которая выводит единственное число — сумму, заработанную Тимуром за год на продаже овощей.
# Примечание 1. Ссылки на указанные файлы: quarter1.csv, quarter2.csv, quarter3.csv, quarter4.csv, prices.json. Ответ на задачу доступен по ссылке.
# Примечание 2. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------
# import csv
# import json
# from collections import defaultdict

vegetables = defaultdict(int)

# открываем поочередно файлы csv
for file_name in ['quarter1.csv', 'quarter2.csv', 'quarter3.csv', 'quarter4.csv']:
    with open(file_name, 'rt', encoding='utf-8') as file:
        rows = csv.DictReader(file, delimiter=',')
        # овощи(колонка1) - суммируем килограммы по месяцам (колонки(2,3,4))
        for row in rows:
            vegetables[row[rows.fieldnames[0]]] += sum(
                [int(row[rows.fieldnames[i]]) for i in range(1, len(rows.fieldnames))])

# открываем json
with open('prices.json', 'rt', encoding='utf-8') as file:
    data = json.load(file)

    for key, value in data.items():
        # старые значения (в кг) умножаем на рубли
        vegetables[key] *= value

# доход за год
print(sum(vegetables.values()))
# ---------------------------------------------------------------------------
# from collections import Counter
# import csv
# import json

files = 'quarter1.csv, quarter2.csv, quarter3.csv, quarter4.csv'
counts = Counter()
for name in files.split(', '):
    with open(name, encoding='utf-8') as f:
        _, *rows = csv.reader(f)
    counts += Counter({i[0]: sum(map(int, i[1:])) for i in rows})

with open('prices.json', encoding='utf-8') as f:
    price = json.load(f)

print(sum(j * price[i] for i, j in counts.items()))
# ===========================================================================


# Бесплатные курсы берут свое 😭
#
# Тимур продает книги по математике за 11—1111 класс. У него есть список, в котором указаны все книги, имеющиеся в наличии. К Тимуру приходят nn покупателей, называют номер класса, за который они хотят приобрести книгу, и сумму, которую они готовы заплатить, и если книга есть в наличии, Тимур ее продает.
# Напишите программу, которая вычисляет общую сумму денег, которую Тимур заработает на продаже книг.
# Формат входных данных
# На вход программе в первой строке подается последовательность чисел, разделенных пробелом, представляющих набор книг, которые имеются в наличии. Каждое число последовательности — книга за указанный класс, например, последовательность 1 1 4 представляет набор из двух книг за первый класс и одной книги за четвертый класс. Вторая строка содержит число nn — количество покупателей. В последующих nn строках вводятся два числа, разделенные пробелом, где первое число является номером класса, второе — суммой, предлагаемой покупателем.
# Формат выходных данных
# Программа должна вывести единственное число — общую сумму денег, которую заработал Тимур.
# Примечание. Рассмотрим первый тест. В первой строке указан список книг, которые есть в наличии:
#     22 книги за 11-й класс
#     11 книга за 1111-й класс
#     33 книги за 99-й класс
#     22 книги за 55-й класс
#     11 книга за 77-й класс
# В следующей строке указано число 77 — количество покупателей. Последующие 77 строк содержат номер класса и некоторую сумму:
#     первый покупатель приобретает книгу за 11-й класс за 300300р
#     второй покупатель приобретает книгу за 11-й класс за 250250р
#     третий покупатель приобретает книгу за 1111-й класс за 400400р
#     книг за 11-й класс больше нет в наличии, поэтому покупка невозможна
#     пятый покупатель приобретает книгу за 77-й класс за 200200р
#     шестой покупатель приобретает книгу за 99-й класс за 400400р
#     книг за 77-й класс больше нет в наличии, поэтому покупка невозможна
# Итого Тимур заработал 300+250+400+200+400=1550300+250+400+200+400=1550р.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Only numbers
# 912
# На вход программе подается неопределенное количество строк, каждая из которых содержит произвольное значение. Напишите программу с использованием конструкции try-except, которая выводит сумму всех введенных чисел, а затем — количество введенных нечисловых значений.
# Формат входных данных
# На вход программе подается неопределенное количество строк (хотя бы одна), каждая из которых содержит произвольное значение.
# Формат выходных данных
# Программа должна вывести сумму всех введенных чисел (тип int и float), а затем на следующей строке — количество введенных нечисловых значений.
# Примечание 1. Если ни одно число введено не было, то сумма равна 00.
# Примечание 2. Рассмотрим первый тест. Имеем три введенных числа, сумма которых равна:
# 100+10+1.1=111.1Также три нечисловых значения, а именно: i'm number!, [1, 99], {'math', 'physics'}.
# ---------------------------------------------------------------------------

# import sys

total = 0
cnt = 0

for line in sys.stdin:
    try:
        total += float(line)
    except:
        cnt += 1

if total % 1 == 0:
    print(int(total))
else:
    print(total)

print(cnt)
# ---------------------------------------------------------------------------
# import sys
s, counter = 0, 0
for line in sys.stdin:
    try:
        s += int(line)
    except ValueError:
        try:
            s += float(line)
        except ValueError:
            counter += 1
print(s)
print(counter)
# ===========================================================================


# Январь, февраль, ...
# 940
# Напишите программу с использованием конструкции try-except, которая выводит название месяца, соответствующее введенному целому числу (от 11 до 1212 включительно), причем
#     если введенное число не принадлежит отрезку [1;12][1;12], программа должна вывести текст:
#     Введено число из недопустимого диапазона
#     если введенное значение не является целым числом, программа должна вывести текст:
#     Введено некорректное значение
# Формат входных данных
# На вход программе подается единственная строка с произвольным значением.
# Формат выходных данных
# Программа должна вывести полное название месяца на английском, соответствующее введенному числу (от 11 до 1212 включительно) или текст с соответствующей ошибкой, если введенное значение некорректно.
# Примечание 1. Для получения списка с названиями месяцев вспомните атрибут month_name из модуля calendar.
# ---------------------------------------------------------------------------
# import calendar
# import locate

# Функция getlocale() модуля locale возвращает текущую настройку для данной категории локали в виде последовательности, содержащей код языка и кодировку.
# print(locale.getlocale())
# locale.setlocale(locale.LC_ALL, 'Russian_Russia.1251')

month_names = list(calendar.month_name)[1:]  # тк первый будет пустая строка
dict1 = dict(enumerate(month_names, 1))

try:
    num = int(input())
    print(dict1[num])
except KeyError:
    print('Введено число из недопустимого диапазона')
except ValueError:
    print('Введено некорректное значение')
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция add_to_list_in_dict()
# 944
# Реализуйте функцию add_to_list_in_dict() с использованием конструкции try-except, которая принимает три аргумента в следующем порядке:
#     data — словарь списков, то есть словарь, значениями в котором являются списки
#     key — хешируемый объект
#     element — произвольный объект
# Функция должна добавлять объект element в список по ключу key в словаре data. Если ключа key в словаре data нет, функция должна добавить его в словарь, присвоить ему в качестве значения пустой список и добавить в этот список объект element.
# Примечание 1. Функция должна изменять переданный словарь и возвращать значение None.
# Примечание 2. Элементы в список должны добавляться в конец.
# ---------------------------------------------------------------------------
def add_to_list_in_dict(data, key, element):

    try:
        data[key].append(element)
    except KeyError:
        data.setdefault(key, []).append(element)

# data = {'a': [1, 2, 3], 'b': [4, 5, 6]}
# add_to_list_in_dict(data, 'b', 7)

# print(data)

# ---------------------------------------------------------------------------

# ===========================================================================


# readme.txt
#
# Напишите программу с использованием конструкции try-except, которая принимает на вход название текстового файла и выводит его содержимое. Если файла с данным названием нет в папке с программой, программа должна вывести текст:
# ​Файл не найден
# Формат входных данных
# На вход программе подается название текстового файла.
# Формат выходных данных
# Программа должна вывести содержимое файла с введенным названием или соответствующий текст, если файла с данным названием нет в папке с программой.
# Примечание 1. Название подаваемого файла уже содержит расширение.
# Примечание 2. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

try:
    with open(input(), encoding='utf-8') as file:
        print(file.read())
except FileNotFoundError:
    print('Файл не найден')

# ---------------------------------------------------------------------------
# печать построчно, на случай если файл оч большой
try:
    with open(input(), encoding='utf-8') as file:
        for line in file:
            print(line, end='')
except:
    print('Файл не найден')
# ===========================================================================


# Функция get_weekday()
# 915
# Реализуйте функцию get_weekday(), которая принимает один аргумент:
#     number — целое число (от 11 до 77 включительно)
# Функция должна возвращать полное название дня недели на русском, который соответствует числу number, при этом:
#     если number не является целым числом, функция должна возбуждать исключение:
#     TypeError('Аргумент не является целым числом')
#     если number является целым числом, но не принадлежит отрезку [1; 7][1;7], функция должна возбуждать исключение:
#     ValueError('Аргумент не принадлежит требуемому диапазону')
# ---------------------------------------------------------------------------


locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
# locale.setlocale(locale.LC_ALL, 'Russian_Russia.1251')


def get_weekday(number):
    if not type(number) == int:
        raise TypeError('Аргумент не является целым числом')

    if not 1 <= number <= 7:
        raise ValueError('Аргумент не принадлежит требуемому диапазону')

    names_month = dict(enumerate([i.title() for i in calendar.day_name], 1))
    # {i: d for i, d in enumerate(map(str.title, day_name), 1)}

    return names_month[number]


# ---------------------------------------------------------------------------
week = {1: "Понедельник", 2: "Вторник", 3: "Среда",
        4: "Четверг", 5: "Пятница", 6: "Суббота", 7: "Воскресенье", }


def get_weekday(num):
    if not isinstance(num, int):
        raise TypeError('Аргумент не является целым числом')
    elif not 0 < num < 8:
        raise ValueError('Аргумент не принадлежит требуемому диапазону')
    return week[num]
# ===========================================================================


# Функция get_id()
#
# В онлайн-школе BEEGEEK имя ученика считается корректным, если оно начинается с заглавной латинской буквы, за которой следуют строчные латинские буквы. Например, имена Timur и Yo считаются корректными, а имена timyrik, Yo17, TimuRRR нет. Также у каждого ученика имеется идентификационный номер, представленный натуральным числом, который выдается при поступлении в школу. К примеру, если в школе обучается 1010 учеников, то новый прибывший ученик получит идентификационный номер равный 1111.
# Реализуйте функцию get_id(), которая принимает два аргумента:
#     names — список имен учеников, обучающихся в школе
#     name — имя поступающего ученика
# Функция должна возвращать идентификационный номер, который получит поступающий в школу ученик, при этом
#     если имя ученика name не является строкой (тип str), функция должна возбуждать исключение:
#     TypeError('Имя не является строкой')
#     если имя ученика name является строкой (тип str), но не представляет собой корректное имя, функция должна возбуждать исключение:
#     ValueError('Имя не является корректным')

def get_id(names, name):

    num = len([el for el in names if el.istitle() and el.isalpha()])

    if type(name) != str:
        raise TypeError('Имя не является строкой')
    elif type(name) == str and not (name.istitle() and name.isalpha()):
        raise ValueError('Имя не является корректным')
    elif type(name) == str and (name.istitle() and name.isalpha()):
        return num + 1

# names = ['Timur', 'Anri', 'Dima', 'Arthur']
# name = 'Ruslan1337'

# try:
#     print(get_id(names, name))
# except ValueError as e:
#     print(e)
# ---------------------------------------------------------------------------


def get_id(names: list, name: str) -> int:
    id_ = len(names)
    if not isinstance(name, str):
        raise TypeError('Имя не является строкой')
    if not name.istitle() or not name.isalpha():
        raise ValueError('Имя не является корректным')
    return id_ + 1
# ---------------------------------------------------------------------------

# ===========================================================================


# Десериализация
# 897
# Напишите программу, которая принимает на вход название JSON файла, десериализует содержащийся в этом файле объект и выводит его.
#     если файла с данным названием нет в папке с программой, программа должна вывести текст:
#     Файл не найден
#     если файл с данным названием содержит некорректные данные (то есть не удовлетворяющие формату JSON), программа должна вывести текст:
#     Ошибка при десериализации
# Формат входных данных
# На вход программе подается название JSON файла.
# Формат выходных данных
# Программа должна десериализовать объект, содержащийся в файле с введенным названием, и вывести его. Если при поиске файла или десериализации его содержимого произошла ошибка, программа должна вывести соответствующий текст.
# Примечание 1. Название подаваемого файла уже содержит расширение.
# Примечание 2. В первом тесте файл numbers.json имеет следующее содержание
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# Файл countries.json, представленный во втором тесте, отсутствует в папке с программой.
# В третьем тесте файл stores.json имеет следующее содержание:
# [}{}D}A{Sd]as][d]as[d][A}SD[as]d[][1111111111111[{}0002
# ---------------------------------------------------------------------------

try:
    with open(input(), encoding='utf-8') as file:
        data = json.load(file)
        print(data)
except FileNotFoundError:
    print('Файл не найден')
except json.decoder.JSONDecodeError:
    print('Ошибка при десериализации')
# ---------------------------------------------------------------------------

# ===========================================================================


# ===========================================================================
# =====================     РЕКУРСИЯ    =====================================
# ===========================================================================

#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# ===========================================================================
# ==================     ГЛАВА ВСтРОЕННЫЕ ФУНКЦИИ    ========================
# ===========================================================================

# Строчный алфавит
# 941
# Напишите программу, которая выводит все строчные латинские буквы.

# Формат входных данных
# На вход программе ничего не подается.

# Формат выходных данных
# Программа должна вывести все строчные латинские буквы от a до z, каждую на отдельной строке.

# Примечание. В задаче удобно воспользоваться функциями ord() и chr().
# ---------------------------------------------------------------------------

# import string
for el in string.ascii_lowercase:
    print(el)
# ---------------------------------------------------------------------------
for c in range(ord('a'), ord('z') + 1):
    print(chr(c))
# ===========================================================================


# Функция convert()
# 929
# Реализуйте функцию convert(), которая принимает один аргумент:
#     number — целое число
# Функция должна возвращать кортеж из трех элементов, расположенных в следующем порядке:
#     двоичное представление числа number в виде строки без префикса 0b
#     восьмеричное представление числа number в виде строки без префикса 0o
#     шестнадцатеричное представление числа number в виде строки в верхнем регистре без префикса 0x
# Примечание 1. В задаче удобно воспользоваться функциями bin(), oct() и hex().
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию convert(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

def convert(number):
    return bin(number).replace('0b', '', 1).upper(), oct(number).replace('0o', '', 1).upper(), hex(number).replace('0x', '', 1).upper()

# ---------------------------------------------------------------------------

# Форматирует значение переменной для вывода на печать d f-строке!!!!!!!!!!!!!


def convert(number):
    return f'{number:b}', f'{number:o}', f'{number:X}'
# ===========================================================================


#
# Вам доступен словарь films, ключом в котором является название некоторого фильма, а значением — словарь с оценками этого фильма от изданий imdb и kinopoisk.
# Дополните приведенный ниже код, чтобы он вывел название фильма с наименьшей средней оценкой.
# Примечание 1. Гарантируется, что искомый фильм единственный.
# Примечание 2. Средней оценкой считается отношение суммы всех оценок к их количеству.
# Примечание 3. В задаче удобно воспользоваться функцией min().
# 931
# ---------------------------------------------------------------------------
films = {'Spider-Man: No Way Home': {'imdb': 8.8, 'kinopoisk': 8.3},
         'Don"t Look Up': {'imdb': 7.3, 'kinopoisk': 7.6},
         'Encanto': {'imdb': 7.3, 'kinopoisk': 7.4},
         'The Witcher': {'imdb': 8.2, 'kinopoisk': 7.3},
         'Ghostbusters: Afterlife': {'imdb': 7.3, 'kinopoisk': 8},
         'Harry Potter 20th Anniversary: Return to Hogwarts': {'imdb': 8.1, 'kinopoisk': 8.2},
         'Shingeki no Kyojin': {'imdb': 9.0, 'kinopoisk': 8.3},
         'The Matrix': {'imdb': 8.7, 'kinopoisk': 8.5},
         'The Dark Knight': {'imdb': 9.0, 'kinopoisk': 8.5},
         'The Shawshank Redemption': {'imdb': 9.3, 'kinopoisk': 9.1},
         'Avengers: Endgame': {'imdb': 8.4, 'kinopoisk': 7.7}}
l1 = []
for key1, value1 in films.items():
    l1.append((key1, sum(value1.values()) / len(value1.values())))

print(min(l1, key=lambda x: x[1])[0])
# ---------------------------------------------------------------------------
result = min(films, key=lambda x: sum(films[x].values()))
print(result)
# ===========================================================================
print(min(films, key=lambda key: (
    films[key]["imdb"] + films[key]["kinopoisk"])/2))

# Функция non_negative_even()
#
# Реализуйте функцию non_negative_even(),  которая принимает один аргумент:
#     numbers — непустой список чисел
# Функция должна возвращать True, если все числа в списке numbers являются четными и неотрицательными, или False в противном случае.
# Примечание 1. В задаче удобно воспользоваться функцией all().
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию non_negative_even(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------


def non_negative_even(numbers):
    l1 = list(map(lambda x: (x % 2 == 0 and x >= 0), numbers))
    return all(l1)
# ---------------------------------------------------------------------------


def non_negative_even(numbers: list[int]) -> bool:
    return all(item >= 0 and not (item % 2) for item in numbers)
# ===========================================================================


# Функция is_greater()
#
# Реализуйте функцию is_greater(), которая принимает два аргумента в следующем порядке:
#     lists — список, элементами которого являются списки целых чисел
#     number — целое число
# Функция должна возвращать True, если хотя бы в одном вложенном списке из списка lists сумма всех элементов больше number, или False в противном случае.
# Примечание 1. В задаче удобно воспользоваться функцией any().
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию is_greater(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
def is_greater(lists, number):
    l1 = map(lambda x: sum(x) > number, lists)
    return any(l1)
# ---------------------------------------------------------------------------


def is_greater(lists: list[list[int]], number: int) -> bool:
    return any(sum(item) > number for item in lists)
# ===========================================================================


# Функция custom_isinstance()
#
# Реализуйте функцию custom_isinstance(), которая принимает два аргумента в следующем порядке:
#     objects — список произвольных объектов
#     typeinfo — тип данных или кортеж с типами
# Функция должна возвращать единственное число — количество объектов из списка objects, которые принадлежат типу typeinfo или одному из типов, если был передан кортеж.
# Примечание 1. В задаче удобно воспользоваться функцией isinstance().
# ---------------------------------------------------------------------------
def custom_isinstance(objects, typeinfo):
    l1 = map(lambda x: isinstance(x, typeinfo), objects)
    return len(list(filter(bool, l1)))

# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен список numbers. Дополните приведенный ниже код, чтобы он вывел индекс максимального элемента в этом списке.
# Примечание 1. Индексация начинается с нуля.
# Примечание 2. В задаче удобно воспользоваться функциями enumerate() и max().
# 983
# ---- -----------------------------------------------------------------------
numbers = [-7724, 5023, 3197, -102, -4129, -880, 5857, -2866, -8913, 1195, 9809, 5347, -8071, 903, 3030, -4347, -3354, 1024, 8670, 4210, -5228, 8900, 4823, -2002, 4900, 9520, -3658, 1104, -9554, 3064, 9632, -8701, 3384, 4370, 2034, 7822, -9694, 3347, 7440, -8459, 3238, -5193, -3381, 5281, 9022, 5559, 7593, -6540, -6204, -
           2483, 8729, 5810, -8254, -9846, -1801, 4882, 3838, -3140, 7609, -3325, 6026, 2994, -1677, 1266, -1893, -4408, -5722, -2841, 9812, 5837, -7474, 4624, -664, 6998, 7888, -971, 8810, 3812, -5396, 2593, 512, -4634, 9735, -3062, 9031, -9300, 3657, 6332, 7552, 8125, -725, 4392, 1727, 8194, -2828, -4314, -8967, -7912, -1363, -5957]


print(max(enumerate(numbers, 0), key=lambda x: x[1])[0])
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция my_pow()
#
# Реализуйте функцию my_pow(), которая принимает один аргумент:
#     number — целое неотрицательное число
# Функция должна возвращать сумму, состоящую из цифр числа, возведенных в степень их порядкового номера.
# Примечание 1. Рассмотрим число 139139 из первого теста. Сумма цифр этого числа, возведенных в степень их порядкового номера, равна:
# 11+32+93=739
# Примечание 2. В задаче удобно воспользоваться функциями enumerate() и sum().
# ---------------------------------------------------------------------------
def my_pow(number):
    l1 = enumerate(map(int, str(number)), 1)
    return sum(map(lambda x: x[1]**x[0], l1))

# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступны три списка names, budgets и box_offices. Первый список содержит названия различных мультфильмов, второй и третий — соответствующие бюджеты и сборы в долларах.
# Дополните приведенный ниже код, чтобы он определил, какую прибыль принес каждый мультфильм, и вывел названия мультфильмов, указав для каждого соответствующую прибыль. Мультфильмы должны быть расположены в лексикографическом порядке, каждый на отдельной строке, в следующем формате:
# <фильм>: <прибыль>$
# Примечание 1. Прибыль определяется как разность сборов и бюджета.
# 971
#
# ---------------------------------------------------------------------------
names = ['Moana', 'Cars', 'Zootopia', 'Ratatouille',
         'Coco', 'Inside Out', 'Finding Nemo', 'Frozen']
budgets = [150000000, 120000000, 150000000, 150000000,
           180000000, 175000000, 94000000, 150000000]
box_offices = [643331111, 462216280, 1023784195,
               620702951, 807082196, 857611174, 940335536, 1280802282]

for el in sorted(zip(names, box_offices, budgets), key=lambda x: x[0]):
    print(f"{el[0]}: {el[2] - el[1]}$")


# ---------------------------------------------------------------------------

# ===========================================================================


# Функция zip_longest()
#
# Как уже известно, функция zip() объединяет элементы различных последовательностей. Особенностью функции является то, что при передаче последовательностей различной длины элементы последовательности большей длины будут отброшены.
# Реализуйте функцию zip_longest(), которая принимает переменное количество позиционных аргументов, каждый из которых является списком, и один необязательный именованный аргумент fill, имеющий значение по умолчанию None.
# Функция должна объединять элементы переданных последовательностей в кортежи, аналогично функции zip(), и возвращать в виде списка, но если последовательности имеют различную длину, недостающие элементы последовательностей меньшей длины должны принимать значение fill.
# Примечание 1. Рассмотрим первый тест со следующим вызовом:
# zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_')
# Первый список имеет длину 55, второй — 33, то есть элементам 4 и 5 из первого списка нет пар из второго списка. В таком случае, функция должна сопоставить им значение fill, равное '_'. Итак, результатом работы функции будет список:
# [(1, 'a'), (2, 'b'), (3, 'c'), (4, '_'), (5, '_')]
# ---------------------------------------------------------------------------
def zip_longest(*args, fill=None):
    l1 = [len(arg) for arg in args]
    mx_len = max(l1)

    for arg in args:
        for _ in range(mx_len - len(arg)):
            arg.append(fill)

    return list(zip(*args))
# ---------------------------------------------------------------------------

# ===========================================================================


# Необычная сортировка 🌶️
#
# Дана строка, содержащая латинские буквы и цифры. Напишите программу, которая сортирует символы в строке согласно следующим правилам:
#     все отсортированные строчные буквы стоят перед заглавными буквами
#     все отсортированные заглавные буквы стоят перед цифрами
#     все отсортированные нечетные цифры стоят перед отсортированными четными
# Формат входных данных
# На вход программе подается строка, содержащая латинские буквы и цифры.
# Формат выходных данных
# Программа должна расположить символы в строке в соответствии с условием задачи и вывести полученный результат.
# ---------------------------------------------------------------------------
s = input()

l1 = sorted(filter(lambda x: x.islower(), s))
l2 = sorted(filter(lambda x: x.isupper(), s))
l3 = sorted(filter(lambda x: (x.isdigit() and int(x) % 2 == 1), s))
l4 = sorted(filter(lambda x: (x.isdigit() and int(x) % 2 == 0), s))

print(''.join(l1+l2+l3+l4))
# ---------------------------------------------------------------------------
# сортировка символов в строке


def comparator(char):
    if char.isalpha():
        return 0, char.isupper(), char
    digit = int(char)
    return 1, digit % 2 == 0, digit


string = input()

print(''.join(sorted(string, key=comparator)))
# ===========================================================================
print(*sorted(input(), key=lambda s: (not s.isalpha(),
      not s.islower(), not s in '13579', s)), sep='')
# ===========================================================================

# Функция hash_as_key()
# 879
# Реализуйте функцию hash_as_key(), которая принимает один аргумент:
#     objects — список хешируемых объектов
# Функция должна возвращать словарь, ключом в котором является хеш-значение объекта из списка objects, а значением — сам объект. Если хеш-значения некоторых объектов совпадают, их следует объединить в список.
# Примечание 1. Элементы в возвращаемом функцией словаре, а также объекты в списке, имеющие равные хеш-значения, должны располагаться в своем исходном порядке.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Коллекции
#
# Напишите программу, которая принимает на вход корректный непустой список, корректный непустой кортеж или корректное множество произвольной длины, и выполняет следующее:
#     если введен список, выводит его последний элемент
#     если введен кортеж, выводит его первый элемент
#     если введено множество, выводит количество его элементов
# Формат входных данных
# На вход программе подается корректный непустой список, кортеж или корректное произвольной длины множество.
# Формат выходных данных
# Программа должна вывести определенное значение, в зависимости от типа введенной коллекции.
# ---------------------------------------------------------------------------
s = input()
if isinstance(s, list):
    print(s[-1])
elif isinstance(s, tuple):
    print(s[0])
elif isinstance(s, set):
    print(len(s))

# ---------------------------------------------------------------------------
n = eval(input())
print(eval({list: 'n[-1]', tuple: 'n[0]', set: 'len(n)'}[type(n)]))
# ===========================================================================


# Математические выражения
# 950
# Напишите программу, которая принимает на вход произвольное количество строк, содержащих корректные математические выражения, и выводит значение наибольшего из них.
# Формат входных данных
# На вход программе подается произвольное количество строк, каждое из которых содержит корректное математическое выражение.
# Формат выходных данных
# Программа должна вычислить значения введенных выражений и вывести наибольшее.
# Примечание 1. Под корректным математическим выражением подразумевается выражение, полностью соответствующее синтаксису языка Python.
# ---------------------------------------------------------------------------
# import sys

l1 = []
for line in sys.stdin:
    l1.append(exec(line))

print(max(l1))

# ---------------------------------------------------------------------------
# import sys

print(max(map(eval, sys.stdin)))
# ===========================================================================


# Минимум и максимум
# 903
# Напишите программу, которая определяет минимальное и максимальное значения функции на отрезке в целых точках.
# Формат входных данных
# На вход программе в первой строке подается корректная функция f(x)f(x), в следующей строке вводятся два целых числа aa и bb, разделенные пробелом, которые представляют границы отрезка [a;b][a;b].
# Формат выходных данных
# Программа должна определить минимальное и максимальное значения функции f(x)f(x) на отрезке [a;b][a;b] в целых точках и вывести полученный результат в следующем формате:
# Минимальное значение функции <функция f(x)> на отрезке <отрезок> равно <мин. значение>
# Максимальное значение функции <функция f(x)> на отрезке <отрезок> равно <макс. значение>
# Примечание 1. Под корректной функцией подразумевается выражение, полностью соответствующее синтаксису языка Python.
# ---------------------------------------------------------------------------
s = input()
a, b = tuple(map(int, input().split()))

l1 = []
for x in range(a, b + 1):
    l1.append(eval(s))

print(
    f"Минимальное значение функции {s} на отрезке [{a}; {b}] равно {min(l1)}")
print(
    f"Максимальное значение функции {s} на отрезке [{a}; {b}] равно {max(l1)}")

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------
names = ['ульяна', 'арина', 'Дмитрий', 'Сергей', 'Яна', 'мила', 'Ольга', 'софья', 'семён', 'Никита', 'маргарита', 'Василиса', 'Кирилл', 'александр', 'александра', 'Иван', 'андрей', 'Родион', 'максим', 'алиса', 'Артём', 'софия', 'владимир', 'дамир', 'Валерий', 'степан', 'Алексей', 'Марк', 'олег', 'ирина', 'Милана', 'мия', 'денис', 'Фёдор', 'Елизавета', 'айлин', 'Варвара', 'валерия', 'Алёна', 'Николь', 'юлия', 'Ксения', 'пётр', 'георгий', 'Мария', 'глеб', 'илья', 'Захар', 'Дарья', 'Евгения',
         'матвей', 'Серафим', 'екатерина', 'Тимофей', 'виктор', 'Егор', 'Ника', 'анна', 'даниил', 'тихон', 'вера', 'кира', 'Эмилия', 'Виктория', 'Игорь', 'полина', 'алина', 'Давид', 'анастасия', 'Вероника', 'ярослав', 'Руслан', 'татьяна', 'Демид', 'амелия', 'Элина', 'Арсен', 'евгений', 'мадина', 'дарина', 'Савелий', 'Платон', 'Аделина', 'диана', 'Айша', 'павел', 'Стефания', 'Тимур', 'Ева', 'Елисей', 'Артемий', 'григорий', 'Мирон', 'Мирослава', 'Мира', 'Марат', 'Лилия', 'роман', 'владислав', 'Леонид']

l1 = filter(lambda x: x.lower()[0] in ('а', 'м') and len(x) > 4, names)
l1 = map(lambda x: x.capitalize(), l1)
print(*sorted(l1))
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция fib()
# Используя синтаксис анонимных функций, реализуйте рекурсивную функцию fib(), которая принимает один аргумент:
#     n — натуральное число
# Функция должна возвращать n-ый член последовательности Фибоначчи.
# Примечание 1. Последовательность Фибоначчи – последовательность натуральных чисел, где каждое последующее число является суммой двух предыдущих:
# 1,1,2,3,5,8,13,21,34,55,89,144,233,...
# 1,1,2,3,5,8,13,21,34,55,89,144,233,...Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию fib(), но не код, вызывающий ее.
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Функция print_operation_table()
#
# Реализуйте функцию print_operation_table(), которая принимает три аргумента в следующем порядке:

#     operation — функция, характеризующая некоторую бинарную операцию
#     rows — натуральное число
#     cols — натуральное число
# Функция должна составлять и выводить таблицу из rows строк и cols столбцов, в которой элемент со строкой nn и столбцом mm имеет значение operation(n, m).
# Примечание 1. Нумерация строк и столбцов в таблице начинается с единицы.
# Примечание 2. Элементы в строках таблицы должны быть разделены одним пробелом, причем выравнивать таблицу необязательно.
# Примечание 3. Бинарная операция — математическая операция, принимающая два аргумента и возвращающая один результат.
# Примечание 4. В тестирующую систему сдайте программу, содержащую только необходимую функцию print_operation_table(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Функция numbers_sum()
# 893
# Реализуйте функцию numbers_sum(), которая принимает один аргумент:
#     elems — список произвольных объектов
# Функция должна возвращать сумму чисел (типы int и float), находящихся в списке elems, игнорируя все нечисловые объекты. Если в списке elems нет чисел, функция должна вернуть число 00.
# Также функция должна иметь следующую строку документации:
# Принимает список и возвращает сумму его чисел (int, float),
# игнорируя нечисловые объекты. 0 - если в списке чисел нет.
# ---------------------------------------------------------------------------
def numbers_sum(elems):
    '''Принимает список и возвращает сумму его чисел (int, float),
игнорируя нечисловые объекты. 0 - если в списке чисел нет.'''
    l1 = list(filter(lambda x: isinstance(x, (int, float)), elems))
    if l1:
        return sum(l1)
    else:
        return 0
# ---------------------------------------------------------------------------


def numbers_sum(elems):
    """Принимает список и возвращает сумму его чисел (int, float),
игнорируя нечисловые объекты. 0 - если в списке чисел нет."""
    return sum(filter(lambda x: isinstance(x, (int, float)), elems))
# ===========================================================================


# Новый print()
# 825
# Напишите программу, которая переопределяет встроенную функцию print() так, чтобы она печатала все переданные строковые аргументы в верхнем регистре.
# Примечание 1. Значения sep и end также должны переводиться в верхний регистр.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Функция polynom()
# 892
# Реализуйте функцию polynom(), которая принимает один аргумент:
#     x — вещественное число
# Функция должна возвращать значение выражения x2+1x2+1.
# Также функция должна иметь атрибут values, представляющий собой множество (тип set) всех значений функции, которые уже были вычислены.
# ---------------------------------------------------------------------------
def polynom(x):
    result = x**2 + 1
    polynom.values.add(res)
    return res


polynom.values = set()
# ---------------------------------------------------------------------------


def polynom(x):
    polynom.__dict__.setdefault('values', set())
    value = x**2 + 1
    polynom.values.add(value)
    return value
# ===========================================================================
# import math


def polynom(num: int) -> int:
    '''Функция считает квадрат числа и добавляет один, все результаты запуска записываются в коллекцию set'''

    # основной расчет
    result = pow(num, 2)+1

    # создание словаря где значение это коллекция. Именно эта запись позволяет хранить в set больше одного элемента
    polynom.__dict__.setdefault('values', set())

    # добавление вычисления в коллекцию
    polynom.__dict__['values'].add(result)
# ===========================================================================


# Функция remove_marks()
# Реализуйте функцию remove_marks(), которая принимает два аргумента в следующем порядке:
#     text — произвольная строка
#     marks — набор символов
# Функция должна возвращать строку text, предварительно удалив из нее все символы, перечисленные в строке marks.
# Также функция remove_marks() должна иметь атрибут count, представляющий собой количество вызовов данной функции.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию remove_marks(), но не код, вызывающий ее.
# 889
def remove_marks(text, marks):
    '''возвращать строку text, предварительно удалив из нее все символы, перечисленные в строке marks'''

    # создание словаря где в ключе count хранится хранится количество вызовов функции
    remove_marks.__dict__[
        'count'] = remove_marks.__dict__.setdefault('count', 0) + 1

    for i in marks:
        text = text.replace(i, '')

    return text
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция power()
# 962
# # Реализуйте функцию power(), которая принимает один аргумент:
#     degree — целое число
# Функция power() должна возвращать функцию, которая принимает в качестве аргумента целое число x и возвращает значение x в степени degree.
# Примечание 1. Рассмотрим пример из первого теста. Вызов power(2) возвращает функцию, которая принимает в качестве аргумента число и возводит его во вторую степень. Функция присваивается переменной square. Далее полученная функция вызывается с аргументом 55 и возвращает значение 52=2552=25.
# ---------------------------------------------------------------------------
def power(degree):
    def func_inner(x):
        return x**degree

    return func_inner
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция generator_square_polynom()
#
# Рассмотрим семейство функций — квадратных трехчленов. Все эти функции имеют один и тот же вид:
# f(x)=ax2+bx+c
# Реализуйте функцию generator_square_polynom(), которая принимает три аргумента в следующем порядке:
#     a — вещественное число, коэффициент aa
#     b — вещественное число, коэффициент bb
#     c — вещественное число, коэффициент cc
# Функция generator_square_polynom() должна возвращать функцию, которая принимает в качестве аргумента вещественное число x и возвращает значение выражения ax2+bx+cax2+bx+c.
# Примечание 1. Рассмотрим пример из первого теста. Вызов generator_square_polynom(1, 2, 1) возвращает функцию, соответствующую квадратному трехчлену x2+2x+1x2+2x+1.  Функция присваивается переменной f. Далее полученная функция вызывается с аргументом 55 и возвращает значение 52+5⋅2+1=3652+5⋅2+1=36.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию generator_square_polynom(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
def generator_square_polynom(a, b, c):
    def inner(x):
        return a * x**2 + b * x + c
    return inner

# ---------------------------------------------------------------------------


def generator_square_polynom(a, b, c): return lambda x: a * x**2 + b * x + c
# ===========================================================================


# Функция sourcetemplate()
# 941
# Строка запроса (query string) — часть URL адреса, содержащая ключи и их значения. Она начинается после вопросительного знака и идет до конца адреса. Например:
# https://beegeek.ru?name=timur     # строка запроса: name=timur
# Если параметров в строке запроса несколько, то они отделяются символом амперсанда &:
# https://beegeek.ru?name=timur&color=green     # строка запроса: name=timur&color=green
# Реализуйте функцию sourcetemplate(), которая принимает один аргумент:
#     url — URL адрес
# Функция sourcetemplate() должна возвращать функцию, которая принимает произвольное количество именованных аргументов и возвращает url адрес, объединенный со строкой запроса, сформированной из переданных аргументов. При вызове без аргументов она должна возвращать исходный url адрес без изменений.
# Примечание 1. Параметры в строке запроса должны располагаться в лексикографическом порядке ключей.
# ---------------------------------------------------------------------------
def sourcetemplate(url):
    def inner(**kwargs):
        if kwargs:
            return f"{url}?{'&'.join([f'{key}={value}' for key, value in sorted(kwargs.items())])}"
        else:
            return url
    return inner
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция date_formatter()
#  919
# Нередко в разных странах используются разные форматы дат. Рассмотрим часть из них:
# код страны 	формат даты
# ru 	DD.MM.YYYY
# us 	MM-DD-YYYY
# ca 	YYYY-MM-DD
# br 	DD/MM/YYYY
# fr 	DD.MM.YYYY
# pt 	DD-MM-YYYY
# Реализуйте функцию date_formatter(), которая принимает один аргумент:
#     country_code — код страны
# Функция date_formatter() должна возвращать функцию, которая принимает в качестве аргумента дату (тип date) и возвращает строку с данной датой в формате страны с кодом country_code.
# Примечание 1. Гарантируется, что в функцию date_formatter() передаются только те коды стран, что перечислены в приведенной выше таблице.
# ---------------------------------------------------------------------------
# from datetime import date

def date_formatter(country_code):
    def inner(date1):
        format_date = {'ru': '%d.%m.%Y',
                       'us': '%m-%d-%Y',
                       'ca': '%Y-%m-%d',
                       'br': '%d/%m/%Y',
                       'fr': '%d.%m.%Y',
                       'pt': '%d-%m-%Y'}

        return date1.strftime(format_date[country_code])

    return inner


# date_ru = date_formatter('us')
# today = date(2025, 1, 5)
# print(date_ru(today))
# ---------------------------------------------------------------------------
# from datetime import date
loc = {
    'ru': '%d.%m.%Y',
    'us': '%m-%d-%Y',
    'ca': '%Y-%m-%d',
    'br': '%d/%m/%Y',
    'fr': '%d.%m.%Y',
    'pt': '%d-%m-%Y'
}


def date_formatter(region: str) -> date:
    return lambda dates: dates.strftime(loc[region])
# ===========================================================================


# Функция sort_priority() 🌶️
# 844
# Реализуйте функцию sort_priority(), которая принимает два аргумента в следующем порядке:
#     values — список чисел
#     group — список, кортеж или множество чисел
# Функция должна сортировать по неубыванию список чисел values, делая при этом приоритетной группу чисел из group, которая должна следовать первой.
# ---------------------------------------------------------------------------
def sort_priority(values, group):

    # ---------------------------------------------------------------------------

    # ===========================================================================

    # Функция get_digits()
    # Реализуйте функцию get_digits() c использованием аннотаций типов, которая принимает один аргумент:
    #     number — положительное целое или вещественное число
    # Функция должна возвращать список, состоящий из цифр числа number.
    # Примечание 1. Используйте встроенные типы (list, tuple, ...), а не типы из модуля typing. Также используйте нотацию |, а не тип Union из модуля typing.
    # Примечание 2. Порядок следования цифр в списке должен совпадать с порядком следования их в исходном числе.
    # 929
    # ---------------------------------------------------------------------------


def get_digits(number: int | float) -> List[int]:
    '''Функция возвращает список, состоящий из цифр числа number'''
    l1 = filter(lambda x: x.isdigit(), str(number))

    return list(map(int, l1))
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция top_grade()
# 935
# Реализуйте функцию top_grade() c использованием аннотаций типов, которая принимает один аргумент:
#     grades — словарь, содержащий данные об ученике, а именно имя по ключу name и список оценок по ключу grades
# Функция должна возвращать словарь, содержащий имя ученика по ключу name и его самую высокую оценку по ключу top_grade.
# Примечание 1. Используйте встроенные типы (list, tuple, ...), а не типы из модуля typing. Также используйте нотацию |, а не тип Union из модуля typing.
# Примечание 2. В возвращаемом функцией словаре сначала должно следовать имя, а затем — самая высокая оценка.
# ---------------------------------------------------------------------------
def top_grade(grades: dict[str, str | list[int]]) -> dict[str, str | int]:
    dict1 = {}
    for key, value in grades.items():
        if key == 'grades':
            key = 'top_grade'
            dict1.setdefault(key, max(value))
        dict1.setdefault(key, value)
    return dict1
# ---------------------------------------------------------------------------


def top_grade(grades: dict[str, str | list[int]]) -> dict[str, str | int]:
    top_grade.__dict__.setdefault('name', grades['name'])
    top_grade.__dict__.setdefault('top_grade', max(grades['grades']))
    return top_grade.__dict__
# ===========================================================================


# Функция cyclic_shift()
# 892
# Реализуйте функцию cyclic_shift() с использованием аннотаций типов, которая принимает два аргумента в следующем порядке:
#     numbers — список целых или вещественных чисел
#     step — целое число
# Функция должна изменять переданный список, циклически сдвигая элементы списка на step шагов, и возвращать значение None. Если step является положительным числом, сдвиг происходит вправо, если отрицательным — влево.
# Примечание 1. Используйте встроенные типы (list, tuple, ...), а не типы из модуля typing. Также используйте нотацию |, а не тип Union из модуля typing.
# ---------------------------------------------------------------------------
def cyclic_shift(numbers: list[int | float], step: int) -> None:
    '''Функция должна изменять переданный список, циклически сдвигая элементы списка на step шагов, и возвращать значение None. Если step является положительным числом, сдвиг происходит вправо, если отрицательным — влево.'''
    if step > 0:
        for _ in range(step):
            numbers.insert(0, numbers.pop())
    elif step < 0:
        for _ in range(abs(step)):
            numbers.append(numbers.pop(0))
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция matrix_to_dict()
#
# Реализуйте функцию matrix_to_dict() с использованием аннотаций типов, которая принимает один аргумент:
#     matrix — матрица произвольной размерности, элементами которой являются целые или вещественные числа
# Функция должна возвращать словарь, ключом в котором является номер строки матрицы, а значением — список элементов этой строки.
# Примечание 1. Используйте встроенные типы (list, tuple, ...), а не типы из модуля typing. Также используйте нотацию |, а не тип Union из модуля typing.
# Примечание 2. Под матрицей подразумеваются исключительно вложенные списки.
# Примечание 3. Нумерация строк матрицы в возвращаемом функцией словаре должна начинаться с единицы.
# Примечание 4. Элементы матрицы в списке должны располагаться в своем исходном порядке.
# ---------------------------------------------------------------------------
def matrix_to_dict(matrix: list[list[int | float]]) -> dict[int, list[int | float]]:
    '''Функция возвращает словарь, ключом в котором является номер строки матрицы, а значением — список элементов этой строки.'''
    dict1 = {}
    for i in range(1, len(matrix) + 1):
        dict1.setdefault(i, matrix[i - 1])

    return dict1


# Доступ к использованным в функции аннотациям можно получить через атрибут __annotations__, в котором аннотации представлены в виде словаря, где ключами являются названия параметров, а значениями – их типы. При этом, возвращаемое функцией значение хранится в записи с ключом return.
annotations = matrix_to_dict.__annotations__

print(annotations['return'])

# ---------------------------------------------------------------------------


def matrix_to_dict(matrix: list[list[int | float]]) -> dict[int, list[int | float]]:
    return {i: matrix[i - 1] for i in range(1, len(matrix) + 1)}
# ===========================================================================


# Декоратор sandwich
#
# Реализуйте декоратор sandwich, который выводит тексты:
# ---- Верхний ломтик хлеба ----
# ---- Нижний ломтик хлеба ----
# до и после вызова декорируемой функции соответственно.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимый декоратор sandwich, но не код, вызывающий его.
# ---------------------------------------------------------------------------
def sandwich(func):
    print('---- Верхний ломтик хлеба ----')

    def wrapper(**kwargs):
        return print(func())
    print('---- Нижний ломтик хлеба ----')
    return wrapper


@sandwich
def add_ingredients(ingredients):
    print(' | '.join(ingredients))


add_ingredients(['томат', 'салат', 'сыр', 'бекон'])
# ---------------------------------------------------------------------------

# ===========================================================================
# ===============          ДОП ЗАДАЧИ с другого курса        ==================================================
# ===========================================================================
# https://stepik.org/lesson/63305/step/3
# https://stepik.org/lesson/63306/step/1


# Это простое упражнение на использование упаковок.
# Определите функцию print_given, которая для каждого переданного аргумента будет распечатывать на отдельной строке через пробел имя аргумента (если таковое имеется), значение аргумента, тип аргумента.
# Аргументы без имени должны быть распечатаны раньше именованных. Порядок печати аргументов без имени важен: он должен совпадать с порядком, в котором аргументы передаются. Порядок печати аргументов с именем неважен.
#
# ---------------------------------------------------------------------------
def print_given(*args, **kwargs):
    for arg in args:
        print(arg, type(arg))
    for kwarg in kwargs:
        print(kwarg, type(kwarg))
# ---------------------------------------------------------------------------

# ===========================================================================


# Это простое упражнение (а заодно и распространённый пример) на использование распаковок.
# На вход подаётся строка, содержащая некоторое количество (не больше сотни) записанных через пробел целых чисел.
# Распечатайте каждое целое число, приведённое к типу float, на отдельной строке в том же порядке, в котором они были переданы.
#
# ---------------------------------------------------------------------------
def print_given(*args, **kwargs):
    for arg in args:
        print(float(arg))
    # for k, v in kwargs.items():
    #     print(k, v, type(v))


print_given(*input().split())
# ---------------------------------------------------------------------------

# ===========================================================================


# Это простое упражнение на использование функции как аргумента.
# Если вы не использовали раньше сортировку по заданному ключу при помощи встроенной функции sorted, рекомендую прочитать вот этот python-howto (упражнение про это, да и вообще возможность чрезвычайно полезная).
# На вход подаётся некоторое количество (не больше сотни) разделённых пробелом целых чисел (каждое не меньше 0 и не больше 19).
# Выведите их через пробел в порядке лексикографического возрастания названий этих чисел в английском языке.
# Т.е., скажем числа 1, 2, 3 должны быть выведены в порядке 1, 3, 2, поскольку слово two в словаре встречается позже слова three, а слово three -- позже слова one (иначе говоря, поскольку выражение 'one' < 'three' < 'two' является истинным)
#  449
# ---------------------------------------------------------------------------
number_names = {
    0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine',
    10: 'ten', 11: 'eleven', 12: 'twelve',
    13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen',  18: 'eighteen', 19: 'nineteen'}

l1 = list(map(int, input().split()))
print(*sorted(l1, key=lambda x: number_names[x]))
# ---------------------------------------------------------------------------

# ===========================================================================


# Это простое упражнение на написание функции высшего порядка, использующей замыкания.
# Напишите функцию composition(f, g), которая принимает на вход две функции: f и g, -- и возвращает их композицию.
# Не вдаваясь в лишние сейчас детали,  назовём композицией f∘gf∘g двух заданных функций f, gf, g  функцию hh, для которой
#   h(x)=f(g(x))h(x)=f(g(x))
# Определите функцию композиции, предполагая, что аргументы у функции g могут быть какие угодно, и любое возвращаемое функцией g значение будет корректным аргументом для функции f.
# Когда вы определите функцию, убедитесь, что вы понимаете, в каком именно месте используются замыкания.
#
#
# ---------------------------------------------------------------------------
def composition(f, g):
    def inner(*args):
        return f(g(*args))
    return inner

# h = composition(lambda x: x**2, lambda x: x + 1)
# print(h(5))
# ---------------------------------------------------------------------------

# ===========================================================================


# Это простое упражнение на написание очень несложного декоратора (почти "минимального" в смысле того, что он делает), чтобы убедиться, что основная конструкция вам понятна, и вы можете её реализовать (а ещё, как было сказано, чтобы у нас был простой пример, к которому мы будем обращаться и который мы будем развивать в дальнейшем).
# Завершите определение декоратора introduce из предыдущего видео.
# По возможности, не переписывайте уже сделанное там, а воспроизведите процесс построения для себя ещё раз.
#
# ---------------------------------------------------------------------------
def introduce(func):
    def wrapper(*args, **kwargs):
        print(func.__name__)
        res = func(*args, **kwargs)
        return res
    return wrapper

# ---------------------------------------------------------------------------

# ===========================================================================


# Это упражнение на написание декоратора.
# Напишите декоратор flip, который делает так, что задекорированная функция принимает все свои неименованные аргументы в порядке, обратном тому, в котором их передали (для аргументов с именем не вполне правильно учитывать порядок, в котором они были переданы)
#
def flip(func):
    def wrapper(*args, **kwargs):
        return func(*reversed(args), **kwargs)
    return wrapper


# @flip
# def div(x, y, show=False):
#     res = x / y
#     if show:
#         print(res)
#     return res


# div(2, 4, show=True)

# ---------------------------------------------------------------------------

# ===========================================================================


# Это упражнение на написание декоратора
# Напишите декоратор introduce_on_debug, который делает так, что задекорированная функция печатает своё имя при вызове в стандартный поток вывода ("представляется"), но только если встроенная константа __debug__ имеет значение True (то есть если программа не запущена с флажком оптимизации -o).
# Чтобы было проще всё это проверять, используйте в теле декоратора вместо встроенной константы __debug__ просто переменную debug (её значение будет установлено за вас).
# Версию с честным __debug__ вместо debug можете протестировать, запустив у себя программу с флажком -ο и без него
# ---------------------------------------------------------------------------
def introduce_on_debug(func):
    def wrapper(*args, **kwargs):
        if debug:
            print(func.__name__)
        return func(*args, **kwargs)
    return wrapper
# ---------------------------------------------------------------------------

# ===========================================================================


# Это упражнение на написание декоратора.
# Напишите декоратор optional_introduce, который делает так, что у задекорированной функции появляется дополнительный параметр introduce со значением False по умолчанию (именованный параметр), причём если функция вызвана с introduce=True, то она перед возвращением результата напечатает своё имя в стандартный поток вывода ("представится"), а если с introduce=False или без явного указания introduce вовсе, то она просто вернёт результат.
# Мы предполагаем, что у исходной функции параметра с именем introduce не было.
#
# ---------------------------------------------------------------------------
def optional_introduce(func):

    def wrapper(*args, introduce=False, **kwargs):
        if introduce:
            print(func.__name__)
        return func(*args, **kwargs)

    return wrapper


# @optional_introduce
# def identity(x):
#     return x


# print(identity(20))

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================
# ============        ОПЯТЬ    поколение PYTHON         =========================
# ===========================================================================
# Новый print
# Напишите программу с использованием декоратора, которая переопределяет функцию print() так, чтобы она печатала весь текст в верхнем регистре.
#
# ---------------------------------------------------------------------------
# from typing import Callable

def decorator(func1: Callable) -> Callable:
    '''Функция переопределяет функцию print() так, чтобы она печатала весь текст в верхнем регистре.'''

    def wrapper(*args: tuple[str], **kwargs: dict[str, str]) -> Callable:
        '''функция обёртка'''
        args = [str(arg).upper() for arg in args]

        for key, value in kwargs.items():
            kwargs[key] = str(value).upper()

        return func1(*args, **kwargs)
    return wrapper


print = decorator('print')
# ---------------------------------------------------------------------------
# import builtins


def upper_case(func):
    def wrapper(*args, **kwargs):
        args = (arg.upper() if isinstance(arg, str) else arg for arg in args)
        kwargs = {key: value.upper() for key, value in kwargs.items()}
        return func(*args, **kwargs)

    return wrapper


@upper_case
def print(*args, sep=' ', end='\n'):
    return builtins.print(*args, sep=sep, end=end)
# ===========================================================================


# Декоратор do_twice
# 950
# Реализуйте декоратор do_twice, вызывающий декорируемую функцию два раза.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
def do_twice(func):
    ''' декоратор do_twice, вызывающий декорируемую функцию два раза'''

    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        return func(*args, **kwargs)

    return wrapper

# @do_twice
# def beegeek():
#     print('beegeek')

# beegeek()
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор reverse_args
# 957
# Реализуйте декоратор reverse_args, который передает все позиционные аргументы в декорируемую функцию func в обратном порядке.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
def reverse_args(func):
    ''' декоратор reverse_args, который передает все позиционные аргументы в декорируемую функцию func в обратном порядке.'''
    def wrapper(*args, **kwargs):
        args = reversed(args)
        return func(*args, **kwargs)
    return wrapper

# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор exception_decorator
# 958
# Реализуйте декоратор exception_decorator, который возвращает
#     кортеж (value, 'Функция выполнилась без ошибок'), если декорируемая функция завершила свою работу без ошибок, где value — возвращаемое значение декорируемой функции
#     кортеж (None, 'При вызове функции произошла ошибка'), если при выполнении декорируемой функции возникла ошибка
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
def exception_decorator(func):
    def wrapper(*args, **kwargs):
        try:
            value = func(*args, **kwargs)
            return (value, 'Функция выполнилась без ошибок')
        except:
            return (None, 'При вызове функции произошла ошибка')

    return wrapper
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор takes_positive
#  899
# Реализуйте декоратор takes_positive, который проверяет, что все аргументы, передаваемые в декорируемую функцию, являются положительными целыми числами.
# Если хотя бы один аргумент не удовлетворяет данному условию, декоратор должен возбуждать исключение:
#     TypeError, если аргумент не является целым числом
#     ValueError, если аргумент является целым числом, но отрицательным или равным нулю
# Примечание 1. Приоритет возбуждения исключений при несоответствии аргумента обоим условиям или при наличии разных аргументов, несоответствующих разным условиям: TypeError, затем ValueError.
# Примечание 2. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
def takes_positive(func):
    def wrapper(*args, **kwargs):
        for el in [*args, *kwargs.values()]:
            if type(el) != int:
                raise TypeError
            elif type(el) == int and el <= 0:
                raise ValueError

        return func(*args, **kwargs)
    return wrapper
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор square
# 967
# Реализуйте декоратор square, который возводит возвращаемое значение декорируемой функции во вторую степень.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Гарантируется, что возвращаемым значением декорируемой функции является объект типа int или float.
# Примечание 2. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def square(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)**2
    return wrapper
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор returns_string
#
# Реализуйте декоратор returns_string, который проверяет, что возвращаемое значение декорируемой функции принадлежит типу str. Если возвращаемое значение принадлежит какому-либо другому типу, декоратор должен возбуждать исключение TypeError.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def returns_string(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        if type(res) != str:
            raise TypeError
        return res

    return wrapper
# ---------------------------------------------------------------------------
# import functools


def returns_string(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return '' + func(*args, **kwargs)
    return wrapper
# ===========================================================================


# Декоратор trace
# 931
# Реализуйте декоратор trace, который выводит отладочную информацию о декорируемой функции во время ее выполнения, а именно: имя функции, переданные аргументы и возвращаемое значение в следующем формате:
# Реализуйте декоратор trace, который выводит отладочную информацию о декорируемой функции во время ее выполнения, а именно: имя функции, переданные аргументы и возвращаемое значение в следующем формате:
# TRACE: вызов <имя функции>() с аргументами: <кортеж позиционных аргументов>, <словарь именованных аргументов>
# TRACE: возвращаемое значение <имя функции>(): <возвращаемое значение>
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def trace(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        print(
            f"TRACE: вызов {func.__name__}() с аргументами: {args}, {kwargs}")
        print(
            f"TRACE: возвращаемое значение {func.__name__}(): {repr(result)}")
        return result
    return wrapper
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор prefix
# 954
# Реализуйте декоратор prefix, который принимает два аргумента в следующем порядке:
#     string — произвольная строка
#     to_the_end — булево значение, по умолчанию равное False
# Декоратор должен добавлять строку string к возвращаемому значению декорируемой функции. Если to_the_end имеет значение True, строка string добавляется в конец, если False — в начало.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Гарантируется, что возвращаемым значением декорируемой функции является объект типа str.
# Примечание 2. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def prefix(string, to_the_end=False):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            res = func(*args, **kwargs)
            if to_the_end:
                return res + string
            elif not to_the_end:
                return string + res
        return wrapper
    return decorator

# ---------------------------------------------------------------------------
# import functools


def prefix(string, to_the_end=False):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            value = func(*args, **kwargs)
            return (string + value, value + string)[to_the_end]
        return wrapper
    return decorator
# ===========================================================================


# Декоратор make_html
# 972
# Тег — элемент языка разметки, используемый для форматирования текста. Например, текст, заключённый между начальным тегом <small> и конечным тегом </small>, отображается с меньшим размером, чем основной текст, а текст между тегами <big> и </big> отображается с большим размером.
# Реализуйте декоратор make_html(), который принимает один аргумент:
#     tag — HTML-тег, например, del
# Декоратор должен обрамлять возвращаемое значение декорируемой функции в HTML-тег tag.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Гарантируется, что возвращаемым значением декорируемой функции является объект типа str.
# Примечание 2. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def make_html(tag):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return f"<{tag}>{func(*args, **kwargs)}</{tag}>"
        return wrapper
    return decorator
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор repeat
#
# Реализуйте декоратор repeat, который принимает один аргумент:
#     times — натуральное число
# Декоратор должен вызывать декорируемую функцию times раз.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def repeat(times):
    def decorator(func):
        # декоратор должен сохранять имя и строку документации декорируемой функции
        @functools.wraps(func)
        # должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов
        def wrapper(*args, **kwargs):
            for _ in range(times - 1):
                func(*args, **kwargs)
            return func(*args, **kwargs)
        return wrapper
    return decorator


# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор strip_range
# 959
# Реализуйте декоратор strip_range, который принимает три аргумента в следующем порядке:
#     start — неотрицательное целое число
#     end — неотрицательное целое число
#     char — одиночный символ, по умолчанию равный точке .
# Декоратор должен изменять возвращаемое значение декорируемой функции, заменяя все символы в диапазоне индексов от start (включительно) до end (не включительно) на символ char.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Гарантируется, что возвращаемым значением декорируемой функции является объект типа str.
# Примечание 2. Гарантируется, что start < end.
# Примечание 3. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def strip_range(start: int, end: int, char='.'):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            nonlocal end
            res = func(*args, **kwargs)
            l1 = list(enumerate(res, 0))

            l2 = list(res[:start])

            if end - l1[-1][0] <= 0:    # если срез не длиннее res
                for el in res[start:end]:
                    l2.append(char)
                l2.extend(res[end:])
            elif end - l1[-1][0] > 0:  # если срез длиннее res
                for el in res[start:]:
                    l2.append(char)

            return ''.join(l2)

        return wrapper
    return decorator
# ---------------------------------------------------------------------------
# import functools


def strip_range(start, end, char='.'):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            res = list(func(*args, **kwargs))
            for i in range(start, end):
                if i >= len(res):
                    break
                res[i] = char
            return ''.join(res)
        return wrapper
    return decorator
# ===========================================================================


# Декоратор returns
#
# Реализуйте декоратор returns, который принимает один аргумент:
#     datatype — тип данных
# Декоратор должен проверять, что возвращаемое значение декорируемой функции принадлежит типу datatype. Если возвращаемое значение принадлежит какому-либо другому типу, декоратор должен возбуждать исключение TypeError.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def returns(datatype):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            res = func(*args, **kwargs)
            if not isinstance(res, datatype):
                raise TypeError
            return res
        return wrapper
    return decorator

# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор takes
# 940
# Реализуйте декоратор takes, который принимает произвольное количество позиционных аргументов, каждый из которых является типом данных.
# Декоратор должен проверять, что аргументы, передаваемые в декорируемую функцию, принадлежат одному из этих типов. Если хотя бы один аргумент не принадлежит одному из данных типов, декоратор должен возбуждать исключение TypeError.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def takes(*args1):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for arg in [*args, *kwargs.values()]:
                if not isinstance(arg, args1):
                    raise TypeError
                    break

            return func(*args, **kwargs)
        return wrapper
    return decorator
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор add_attrs
#
# Реализуйте декоратор add_attrs, который принимает произвольное количество именованных аргументов и устанавливает их в качестве атрибутов декорируемой функции. Названием атрибута должно являться имя аргумента, значением атрибута — значение аргумента.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Вспомните про атрибут функции __dict__.
# Примечание 2. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

def add_attrs(**kwargs1):
    def decorator(func):

        # 1) func.k = v. Такой синтаксис. Через точечную нотацию создаётся атрибут с таким именем, которое стоит после точки. __dict__ – это словарь атрибутов, где ключ – это имя атрибута, а значение – соответственно его значение 2) атрибуты относятся всегда именно к функции, а не к результату её работы 3) внутри wrapper можно сделать создание атрибутов, но они будут созданы только после первого вызова этой функции. К тому же, может быть такая ситуация, что они будут пересоздаваться после каждого вызова этой функции. Поэтому до вызова, т.к. атрибуты ещё не существуют, у wrapper их в этот момент тоже ещё нет.
        for key, value in kwargs1.items():
            func.__dict__.setdefault(key, value)

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            fnc = func(*args, **kwargs)

            return fnc
        return wrapper
    return decorator
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор ignore_exception
#
# Реализуйте декоратор ignore_exception, который принимает произвольное количество позиционных аргументов — типов исключений, и выводит текст:
# Исключение <тип исключения> обработано
# если во время выполнения декорируемой функции было возбуждено исключение, принадлежащее одному из переданных типов.
# Если возбужденное исключение не принадлежит ни одному из переданных типов, оно должно быть возбуждено снова.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools


def ignore_exception(*args1):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except args1 as err:
                print(f'Исключение {err.__class__.__name__} обработано')
            except:
                raise

        return wrapper
    return decorator
# ---------------------------------------------------------------------------

# ===========================================================================


# Декоратор retry
# 866
# Реализуйте декоратор retry, который принимает один аргумент:
#     times — натуральное число
# Декоратор должен выполнять повторную попытку вызова декорируемой функции, если во время ее выполнения возникает ошибка. Декоратор должен вызывать ее до тех пор, пока не исчерпает количество попыток times, после чего должен возбуждать исключение MaxRetriesException.
# Также декоратор должен сохранять имя и строку документации декорируемой функции.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------------------
# import functools

# Для создания собственного типа исключения необходимо создать класс, являющийся потомком (наследником) одного из уже существующего типа исключения.  Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс называется потомком, наследником, дочерним или производным классом. Базовым классом для большинства встроенных в Python исключений является Exception, поэтому самым верным вариантом является класс Exception.
class MaxRetriesException(Exception):
    pass


def retry(times):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(times):
                try:
                    return func(*args, **kwargs)
                except:
                    continue
            raise MaxRetriesException

        return wrapper
    return decorator

# ---------------------------------------------------------------------------

# ===========================================================================


# Две функции
#
# Вам доступна уже реализованная функция send_email(), которая принимает три аргумента в следующем порядке:
#     name — имя
#     email_address — адрес электронной почты
#     text — содержание письма
# Функция отправляет письмо пользователю с именем name на адрес email_address с содержанием text.
# 1. Реализуйте функцию to_Timur() с помощью функции partial(), которая принимает один аргумент:
#     text — содержание письма
# Функция должна отправлять письмо пользователю с именем Тимур на адрес timyrik20@beegeek.ru с содержанием text.
# 2. Реализуйте функцию send_an_invitation() с помощью функции partial(), которая принимает два аргумента в следующем порядке:
#     name — имя
#     email_address — адрес электронной почты
# Функция должна отправлять письмо на имя name и на адрес email_address со следующим содержанием:
# Школа BEEGEEK приглашает Вас на новый курс по программированию на языке Python. тутут....
# Примечание 1. Функции to_Timur() и send_an_invitation() должны являться partial объектами.
# ---------------------------------------------------------------------------
# from functools import partial


to_Timur = partial(send_email, text)
send_an_invitation = partial(send_email, name, email_address)

#  с помощью partial() мы можем создать другую функцию, которая будет являться этой же функцией, но уже с переданным одним аргументом:

# Т.е., по сути, это та же самая функция, скажем так, но как-будто с аргументом по умолчанию, который передавать необязательно.
to_Timur(name='Тимур', email_address='timyrik20@beegeek.ru')
send_an_invitation(
    text='Школа BEEGEEK приглашает Вас на новый курс по программированию на языке Python. тутут....')
# ---------------------------------------------------------------------------

# ===========================================================================


# Просто Дима 🙂
# 910
# Дима решил выучить английский алфавит, и чтобы изучение шло быстрее, он придумал упражнение: он берет произвольное английское слово и расставляет в нем все буквы в лексикографическом порядке. Иногда Дима берет слова повторно, так как не помнит, брал ли их раньше.
# Напишите программу, которая принимает на вход произвольное количество английских слов и в каждом расставляет буквы в лексикографическом порядке.
# Форматы входных данных
# На вход программе подается произвольное количество английских слов, каждое на отдельной строке.
# Форматы выходных данных
# Программа должна в каждом введенном слове расположить все буквы в лексикографическом порядке и вывести полученный результат. Слова должны быть расположены в исходном порядке, каждое на отдельной строке.
# Примечание 1. Обратите внимание, что в задаче установлено ограничение по времени в одну секунду.
# ---------------------------------------------------------------------------

# import functools
# import sys

@functools.lru_cache()
def anagramm(word):
    return ''.join(sorted(word))


words = [word.strip() for word in sys.stdin]

for word in words:
    print(anagramm(word))
# ---------------------------------------------------------------------------
# from functools import lru_cache


@lru_cache
def sort_string(string):
    return ''.join(sorted(string.strip()))


for l in open(0):
    print(sort_string(l))
# ===========================================================================


# Просто Дима 🙃
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# ===========================================================================
# =========         ИТЕРАТОРЫ              ==================================
# ===========================================================================

# Вам доступен список numbers, содержащий целые числа. Дополните приведенный ниже код с использованием функций iter() и next(), чтобы он вывел четвертый элемент данного списка.
#
# ---------------------------------------------------------------------------
numbers = [100, 70, 34, 45, 30, 83, 12, 83, -28, 49, -8, -2, 6, 62,
           64, -22, -19, 61, 13, 5, 80, -17, 7, 3, 21, 73, 88, -11, 16, -22]

i1 = iter(numbers)
for _ in range(4):
    el = next(i1)

print(el)
# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен список numbers, содержащий целые числа. Дополните приведенный ниже код с использованием функций iter() и next(), чтобы он вывел последний элемент данного списка.
#
# ---------------------------------------------------------------------------
numbers = [100, 70, 34, 45, 30, 83, 12, 83, -28, 49, -8, -2, 6, 62,
           64, -22, -19, 61, 13, 5, 80, -17, 7, 3, 21, 73, 88, -11, 16, -22]

i1 = iter(numbers)
while True:
    try:
        el = next(i1)
    except StopIteration:
        print(el)
        break
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция filterfalse()
#
# Реализуйте функцию filterfalse() с использованием функции filter(), которая принимает два аргумента:
#     predicate — функция-предикат; если имеет значение None, то работает аналогично функции bool()
#     iterable — итерируемый объект
# Функция должна работать противоположно функции filter(), то есть возвращать итератор, элементами которого являются элементы итерируемого объекта iterable, для которых функция predicate вернула значение False.
# Примечание 1. Предикат — это функция, которая возвращает True или False в зависимости от переданного в качестве аргумента значения.
# Примечание 2. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном порядке.
# Примечание 3. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------


# в качестве аргумента predicate может быть передана функция-предикат,
# либо значение None (как и в обычной функции filter()).
# Если передано значение None, функция-предикат должна работать аналогично функции bool(). Поэтому, перед тем как вызывать функцию-предикат, следует проверить, не было ли передано значение None, например, так:
# if predicate is None:
#     predicate = bool

def filterfalse(predicate, iterable):
    if predicate is None:
        predicate = bool

    return filter(lambda x: predicate(x) is False, iterable)


objects = [0, 1, True, False, 17, []]

print(*filterfalse(None, objects))
# ---------------------------------------------------------------------------


def filterfalse(func, iterable):
    if func is None:
        func = bool
    return filter(lambda elem: not func(elem), iterable)
# ===========================================================================


def filterfalse(predicate, iterable):
    if predicate == None:
        return filter(lambda x: bool(x) == False, iterable)
    return filter(lambda x: not predicate(x), iterable)
# ---
# ------------------------------------------------------------------------

# Функция transpose()
# 934
# Транспонированная матрица — матрица ATAT, полученная из исходной матрицы AA заменой строк на столбцы. Например, если
# ​То есть для получения транспонированной матрицы из исходной нужно каждую строчку исходной матрицы записать в виде столбца в том же порядке.
# Реализуйте функцию transpose() с использованием функции zip(), которая принимает один аргумент:
#     matrix — матрица произвольной размерности
# Функция должна возвращать транспонированную матрицу matrix.
# Примечание 1. Под матрицей подразумеваются исключительно вложенные списки.
# Примечание 2. Функция должна возвращать новую матрицу, а не изменять переданную.
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------


def transpose(matrix):

    return list(map(list, zip(*matrix)))

# ---------------------------------------------------------------------------


def transpose(matrix): return list(map(list, zip(*matrix)))
# ===========================================================================


# Функция get_min_max() 😎
#
# Реализуйте функцию get_min_max(), которая принимает один аргумент:
#     data — список произвольных объектов, сравнимых между собой
# Функция должна возвращать кортеж, в котором первым элементом является индекс минимального элемента в списке data, вторым — индекс максимального элемента в списке data. Если список data пуст, функция должна вернуть значение None.
# Примечание 1. Если минимальных / максимальных элементов несколько, следует вернуть индексы первого по порядку элемента.
# ---------------------------------------------------------------------------
def get_min_max(data):
    if data:
        a = min(enumerate(data), key=lambda x: x[1], default=None)[0]
        b = max(enumerate(data), key=lambda x: x[1], default=None)[0]
        return (a, b)

# ===========================================================================


# Функция starmap()
# Как известно, функция map() принимает функцию и итерируемый объект и возвращает итератор, элементами которого являются элементы итерируемого объекта, к которым была применена переданная функция. Нередко элементами итерируемого объекта являются коллекции (списки, кортежи, ..), тогда внутри переданной функции нам приходится обращаться к каждому элементу этих коллекций по индексу. Например:
# persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]
# full_names = map(lambda tup: tup[0] + ' ' + tup[1], persons)
# Было бы удобно иметь функцию, назовем ее starmap(), которая бы принимала функцию не с одним аргументом, а с несколькими — каждым элементом коллекции:
# persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]
# full_names = starmap(lambda name, surname: f'{name} {surname}', persons)
# Реализуйте функцию starmap() с использованием функции map(), которая принимает два аргумента:
#     func — функция
#     iterable — итерируемый объект, элементами которого являются коллекции
# Функция starmap() должна работать аналогично функции map(), то есть возвращать итератор, элементами которого являются элементы итерируемого объекта iterable, к которым была применена функция func, с единственным отличием: func должна принимать не один аргумент — коллекцию (элемент iterable), а каждый элемент этой коллекции в качестве самостоятельного аргумента.
# ---------------------------------------------------------------------------
def starmap(func, iterable):
    return map(lambda args: func(*(args)), iterable)
# --------------------------------------------------------------------------


def starmap(func, iterable):
    return map(func, *zip(*iterable))
# ===========================================================================


# Функция get_min_max() 😳
# 894
# # Реализуйте функцию get_min_max(), которая принимает один аргумент:
#     iterable — итерируемый объект, элементы которого сравнимы между собой
# Функция должна возвращать кортеж, в котором первым элементом является минимальный элемент итерируемого объекта iterable, вторым — максимальный элемент итерируемого объекта iterable. Если итерируемый объект iterable пуст, функция должна вернуть значение None.
# ---------------------------------------------------------------------------

# from copy import copy, deepcopy

def get_min_max(iterable):

    i1 = copy(iterable)
    i2 = copy(iterable)

    try:
        next(iter(iterable))
        a = min(i1)
        b = max(i2)
        return a, b
    except StopIteration:
        return None
# --------------ПРЕПОД--------------------------------------------


def get_min_max(iterable):
    iterable = iter(iterable)
    try:
        smallest = largest = next(iterable)
    except:
        return None
    for elem in iterable:
        if elem < smallest:
            smallest = elem
        if elem > largest:
            largest = elem
    return smallest, largest
# ===========================================================================


# Функция is_iterable()
#
# Реализуйте функцию is_iterable(), которая принимает один аргумент:
#     obj — произвольный объект
# Функция должна возвращать True, если объект obj является итерируемым объектом, или False в противном случае.
# ---------------------------------------------------------------------------
def is_iterable(obj):
    if '__len__' in dir(obj):
        return True
    else:
        return False

# ---------------------------------------------------------------------------


def is_iterable(obj):
    return '__iter__' in dir(obj)
# ===========================================================================


def is_iterable(obj):
    try:
        iter(obj)
        return True
    except TypeError:
        return False


# Функция is_iterator()
#
# Реализуйте функцию is_iterator(), которая принимает один аргумент:
#     obj — произвольный объект
# Функция должна возвращать True, если объект obj является итератором, или False в противном случае.
# ---------------------------------------------------------------------------
def is_iterator(obj):
    if '__next__' in dir(obj):
        return True
    else:
        return False

# ---------------------------------------------------------------------------


def is_iterator(obj): return '__next__' in dir(obj)
# ===========================================================================


def is_iterator(obj: object) -> bool:
    return '__next__' in obj.__dir__()


# Функция random_numbers()
#
# Реализуйте функцию random_numbers(), которая принимает два аргумента:
#     left — целое число
#     right — целое число
# Функция должна возвращать итератор, генерирующий бесконечную последовательность случайных целых чисел в диапазоне от left до right включительно.
# Примечание 1. Гарантируется, что left <= right.
# ---------------------------------------------------------------------------

# import random

def random_numbers(left, right):
    return iter(lambda: random.randint(left, right), '')
# ---------------------------------------------------------------------------

# ===========================================================================


# Итератор Repeater
# 953
# Реализуйте класс Repeater, порождающий итераторы, конструктор которого принимает один аргумент:
#     obj — произвольный объект
# Итератор класса Repeater должен бесконечно генерировать единственное значение — obj.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимый класс Repeater.
# ---------------------------------------------------------------------------
class Repeater:
    def __init__(self, obj):
        self.obj = obj

    def __iter__(self):
        return self

    def __next__(self):
        return self.obj
# ---------------------------------------------------------------------------
# from itertools import repeat as Repeater
# ===========================================================================


# Итератор BoundedRepeaterа
# 967
# Реализуйте класс BoundedRepeater, порождающий итераторы, конструктор которого принимает два аргумента в следующем порядке:
#     obj — произвольный объект
#     times — натуральное число
# Итератор класса BoundedRepeater должен генерировать значение obj times раз, а затем возбуждать исключение StopIteration.
# ---------------------------------------------------------------------------
class BoundedRepeater:
    def __init__(self, obj, times):
        self.obj = obj
        self.times = times

    def __iter__(self):
        return self

    def __next__(self):
        self.times -= 1

        if self.times < 0:
            raise StopIteration
        else:
            return self.obj
# ---------------------------------------------------------------------------

# ===========================================================================


# Итератор Square
# 963
# Реализуйте класс Square, порождающий итераторы, конструктор которого принимает один аргумент:
#     n — натуральное число,
# Итератор класса Square должен генерировать последовательность из n чисел, каждое из которых является квадратом очередного натурального числа, а затем возбуждать исключение StopIteration.
# Примечание 1. Последовательность квадратов натуральных чисел начинается
# с квадрата числа 11.
# ---------------------------------------------------------------------------
class Square:
    def __init__(self, n):
        self.n = n
        self.start = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.start += 1

        if self.start <= self.n:
            return self.start ** 2
        else:
            raise StopIteration

# squares = Square(10)
# print(list(squares))
# ---------------------------------------------------------------------------

# ===========================================================================


# Итератор Fibonacci
#
# Реализуйте класс Fibonacci, порождающий итераторы, конструктор которого не принимает никаких аргументов.
# Итератор класса Fibonacci должен генерировать бесконечную последовательность чисел Фибоначчи, начиная с 11.
# Примечание 1. Последовательность Фибоначчи – последовательность натуральных чисел, где каждое последующее число является суммой двух предыдущих:
# 1,1,2,3,5,8,13,21,34
# ---------------------------------------------------------------------------
class Fibonacci:
    def __init__(self) -> None:
        self.m1 = 0
        self.m2 = 1

    def __iter__(self):
        return self

    def __next__(self):
        self.m1, self.m2 = self.m2, self.m1 + self.m2
        return self.m1
# ---------------------------------------------------------------------------

# ===========================================================================

# Итератор PowerOf
# 960
# Реализуйте класс PowerOf, порождающий итераторы, конструктор которого принимает один аргумент:
#     number — ненулевое число
# Итератор класса PowerOf должен генерировать бесконечную последовательность целых неотрицательных степеней числа number в порядке возрастания, начиная с нулевой степени.
# ---------------------------------------------------------------------------


class PowerOf:
    def __init__(self, number):
        self.number = number
        self.power = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.power += 1
        return self.number**self.power
# ===========================================================================


# Итератор DictItemsIterator
# 940
# Как известно, во время итерации по словарю мы получаем ключи, а не значения или пары ключ-значение.
# Приведенный ниже код:
# info = {'name': 'Timur', 'age': 29, 'gender': 'Male'}
# print(*info)
# выводит:
# name age gender
# Реализуйте класс DictItemsIterator, порождающий итераторы, конструктор которого принимает один аргумент:
#     data — словарь
# Итератор класса DictItemsIterator должен генерировать последовательность кортежей, представляющих собой пары ключ-значение словаря data, а затем возбуждать исключение StopIteration.
# Примечание 1. При решении задачи не используйте словарные методы keys(), values() и items().
# Примечание 2. Пары ключ-значение в возвращаемом функцией итераторе должны располагаться в своем изначальном порядке.
# ---------------------------------------------------------------------------
class DictItemsIterator:
    def __init__(self, data):
        self.data = data
        self.data1 = dict(reversed(data.items()))  # развернуть словарь

    def __iter__(self):
        return self

    def __next__(self):
        try:
            return self.data1.popitem()
        except KeyError:
            raise StopIteration
# ---------------------------------------------------------------------------

# ===========================================================================


# Итератор CardDeck
# 923
# Реализуйте класс CardDeck, порождающий итераторы, конструктор которого не принимает никаких аргументов.
# Итератор класса CardDeck должен генерировать последовательность из 5252 игральных карт, а после возбуждать исключение StopIteration. Каждая карта должна представлять собой строку в следующем формате:
# <номинал> <масть>
# Например, 7 пик, валет треф, дама бубен, король червей, туз пик.
# Примечание 1. Карты, генерируемые итератором, должны располагаться сначала по величине номинала, затем масти.
# Примечание 2. Старшинство мастей по возрастанию: пики, трефы, бубны, червы. Старшинство карт в масти по возрастанию: двойка, тройка, четверка, пятерка, шестерка, семерка, восьмерка, девятка, десятка, валет, дама, король, туз.
# Примечание 3. Масти не требуют склонения и независимо от номинала должны сохранять следующее написание: пик, треф, бубен, червей.
# ---------------------------------------------------------------------------
class CardDeck:
    def __init__(self):
        self.card = [f"{j} {i}" for i in ('пик', 'треф', 'бубен', 'червей') for j in (
            '2', '3', '4', '5', '6', '7', '8', '9', '10', 'валет', 'дама', 'король', 'туз')]
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1
        if self.index == len(self.card):
            raise StopIteration
        return self.card[self.index]
# ---------------------------------------------------------------------------

# ===========================================================================


# Итератор Cycle
# 941
# Реализуйте класс Cycle, порождающий итераторы, конструктор которого принимает один аргумент:
#     iterable — итерируемый объект
# Итератор класса Cycle должен циклично генерировать последовательность элементов итерируемого объекта iterable.
# Примечание 1. Гарантируется, что итерируемый объект, передаваемый в конструктор класса, не является множеством и итератором.
# Примечание 2. Элементы итерируемого объекта, генерируемые итератором, должны располагаться в своем изначальном порядке.
# ---------------------------------------------------------------------------
class Cycle:
    def __init__(self, iterable):
        self.iterable = iterable
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1
        if self.index == len(self.iterable):
            self.index = 0
        return self.iterable[self.index]
# ---------------------------------------------------------------------------
# from copy import copy


class Cycle:
    def __init__(self, iterable):
        self.pattern = iter(iterable)
        self.iterable = copy(self.pattern)

    def __iter__(self):
        return self

    def __next__(self):
        try:
            return next(self.iterable)
        except StopIteration:
            self.iterable = copy(self.pattern)
            return next(self.iterable)
# ===========================================================================


# Итератор RandomNumbers
#
#
# ---------------------------------------------------------------------------


class RandomNumbers:
    def __init__(self, left, right, n) -> None:
        self.n = n
        self.rnd = random.choices(range(left, right + 1, 1), k=self.n)
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1
        if self.index == len(self.rnd):
            raise StopIteration
        return self.rnd[self.index]
# ---------------------------------------------------------------------------

# ===========================================================================


# Итератор Alphabet 🌶️
# 921
# Реализуйте класс Alphabet, порождающий итераторы, конструктор которого принимает один аргумент:
#     language — код языка: ru — русский, en — английский
# Итератор класса Alphabet() должен циклично генерировать последовательность строчных букв:
#     русского алфавита, если language имеет значение ru
#     английского алфавита, если language имеет значение en
# Примечание 1. Буква ё в русском алфавите не учитывается.
# ---------------------------------------------------------------------------


class Alphabet:
    def __init__(self, language):
        self.language = language
        self.letters = {'en': tuple(string.ascii_lowercase), 'ru': tuple(
            'абвгдежзийклмнопрстуфхцчшщъыьэюя')}
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1

        if self.index == len(self.letters[self.language]):
            self.index = 0
        return self.letters[self.language][self.index]
# ---------------------------------------------------------------------------

# ===========================================================================


# Итератор Xrange 🌶️
#
# Реализуйте класс Xrange, порождающий итераторы, конструктор которого принимает три аргумента в следующем порядке:
#     start — целое или вещественное число
#     end — целое или вещественное число
#     step — целое или вещественное число, по умолчанию имеет значение 11
# Итератор класса Xrange должен генерировать последовательность членов арифметической прогрессии от start до end, включая start и не включая end, с шагом step, а затем возбуждать исключение StopIteration.
# ---------------------------------------------------------------------------
class Xrange:
    def __init__(self, start, end, step=1) -> None:
        def frange(start, end, step):

            i = start
            l1 = []

            if start < end:
                while i < end:
                    l1.append(i)
                    i += step

            elif start > end:
                while i > end:
                    l1.append(i)
                    i += step

            return l1

        self.rng = frange(start, end, step)
        self.index = -1

    def __iter__(self):
        return self

    def __next__(self):
        self.index += 1

        if self.index == len(self.rng):
            raise StopIteration
        return self.rng[self.index]
# ---------------------------------------------------------------------------
# from numpy import arange


class Xrange:
    def __init__(self, start, end, step=1):
        self.num_iterator = iter(arange(start, end, step))

    def __iter__(self):
        return self

    def __next__(self):
        return next(self.num_iterator)
# ===========================================================================


# ===========================================================================
# ==========          ГЕНЕРАТОРЫ                   ==========================
# ===========================================================================

# Функция simple_sequence()
# 937
# Реализуйте генераторную функцию simple_sequence(), которая не принимает никаких аргументов.
# Функция должна возвращать генератор, порождающий бесконечную возрастающую последовательность натуральных чисел, в которой каждое число встречается столько раз, каково оно:
# 1,2,2,3,3,3,4,4,4,4,..
# ---------------------------------------------------------------------------
def simple_sequence(n=1):
    while True:
        for i in range(n):
            yield n
        n += 1
# ---------------------------------------------------------------------------

# from typing import Iterable


def simple_sequence() -> Iterable:
    '''Функция должна возвращать генератор, порождающий бесконечную возрастающую последовательность натуральных чисел, в которой каждое число встречается столько раз, каково оно'''
    x = 1
    while True:
        for _ in range(x):
            yield x
        x += 1
# ===========================================================================


# Функция alternating_sequence()
# 943
#  Реализуйте генераторную функцию alternating_sequence(), которая принимает один аргумент:
#     count — натуральное число, по умолчанию имеет значение None
# Если count имеет значение None, функция должна возвращать генератор, порождающий бесконечный знакочередующийся ряд натуральных чисел.
# Если count имеет в качестве значения натуральное число, функция должна возвращать генератор, порождающий первые count чисел знакочередующегося ряда натуральных чисел, а затем возбуждающий исключение StopIteration.
# Примечание 1. Знакочередующийся ряд натуральных чисел имеет вид:
# 1,−2,3,−4,5,−6,7,−8,9,−10,...
# ---------------------------------------------------------------------------

# from typing import Iterable

def alternating_sequence(count=None) -> Iterable:
    '''функция должна возвращать генератор, порождающий первые count чисел знакочередующегося ряда натуральных чисел, а затем возбуждающий исключение StopIteration'''
    n = 1
    while True:
        if n % 2:
            yield n
        else:
            yield -n
        n += 1
        if count and n == count + 1:
            break
# ---------------------------------------------------------------------------


def alternating_sequence(count=None):
    n = 0
    while n != count:
        n += 1
        sign = [-1, 1][n % 2]
        yield n * sign
# ===========================================================================


# Функция primes()
# 937
# # Реализуйте генераторную функцию primes(), которая принимает два аргумента в следующем порядке:
#     left — натуральное число
#     right — натуральное число
# Функция должна возвращать генератор, порождающий последовательность простых чисел от left до right включительно, а затем возбуждающий исключение StopIteration.
# Примечание 1. Гарантируется, что left <= right.
# Примечание 2. Простое число — натуральное число, имеющее ровно два различных натуральных делителя — единицу и самого себя. Единица простым числом не является.
# ---------------------------------------------------------------------------


def is_prime(n: int) -> bool:
    '''простых неотрицательных чисел (возврацает true)'''
    # Оптимизированный алгоритм поиска простых неотрицательных чисел:
    #     проверить на 0 и 1
    #     проверить на чётность и равенство 2 (исключается ~50% чисел)
    #     проверить на кратность 3 и равенство 3 (исключается ещё ~33% чисел)
    #     для проверки оставшихся чисел воспользоваться формулой 6n ± 1 (при n = 1, простыми будут 5 и 7, при n = 2: 11 и 13, и т.д.)
    #     как отмечено раньше, проверять делители следует до корня из заданного числа


def is_prime(num):
    prime = num > 1 and (num % 2 != 0 or num == 2) and (
        num % 3 != 0 or num == 3)
    i = 5
    d = 2

    while prime and i * i <= num:
        prime = num % i != 0
        i += d
        d = 6 - d  # чередование прироста 2 и 4: 5 + 2, 7 + 4, 11 + 2, и т.д.
    return prime


def primes(left: int, right: int) -> Iterable:
    '''ф-я возвращает генератор, порождающий последовательность простых чисел от left до right включительно, а затем возбуждающий исключение StopIteration.'''

    for i in range(left, right + 1):

        if is_prime(i):
            yield i

#  ---------------------------------------------------------------------------

# ===========================================================================


# Функция reverse()
# 966
# Реализуйте генераторную функцию reverse(), которая принимает один аргумент:
#     sequence — последовательность
# Функция должна возвращать генератор, порождающий элементы последовательности sequence в обратном порядке, а затем возбуждающий исключение StopIteration.
# Примечание 1. Последовательностью является коллекция, поддерживающая индексацию и имеющая длину. Например, объекты типа list, str, tuple являются последовательностями.
# ---------------------------------------------------------------------------
def reverse(sequence):
    '''Функция должна возвращать генератор, порождающий элементы последовательности sequence в обратном порядке, а затем возбуждающий исключение StopIteration.'''

    for el in reversed(sequence):
        yield el
# ---------------------------------------------------------------------------


def reverse(sequence):
    yield from sequence[::-1]
# ===========================================================================


# Функция dates()
#
# Реализуйте генераторную функцию dates(), которая принимает два аргумента в следующем порядке:
#     start — дата, тип date
#     count — натуральное число, по умолчанию имеет значение None
# Если count имеет значение None, функция должна возвращать генератор, порождающий последовательность из максимально допустимого количества дат (тип date), начиная с даты start.
# Если count имеет в качестве значения натуральное число, функция должна возвращать генератор, порождающий последовательность из count дат (тип date), начиная с даты start, а затем возбуждающий исключение StopIteration.
# ---------------------------------------------------------------------------
# from datetime import date, timedelta

def dates(start, count=None):
    try:
        while True:
            yield start
            start += timedelta(days=1)

            if count:
                count -= 1
                if not count:
                    break

    except (StopIteration, OverflowError):
        return
# ---------------------------------------------------------------------------
# from datetime import date, timedelta


def dates(start: date, count: int = None):
    if count is None:
        count = (date(9999, 12, 31) - start).days + 1
    for _ in range(count-1):
        yield start
        start += timedelta(1)
    yield start
# ===========================================================================

# Функция card_deck()
#
# еализуйте генераторную функцию card_deck(), которая принимает один аргумент:
#     suit — одна из четырех карточных мастей: пик, треф, бубен, червей
# Функция должна возвращать генератор, циклично порождающий колоду игральных карт без масти suit. Каждая карта должна представлять собой строку в следующем формате:
# <номинал> <масть>
# Например, 7 пик, валет треф, дама бубен, король червей, туз пик.
# Примечание 1. Карты, генерируемые итератором, должны располагаться сначала по величине номинала, затем масти.
# Примечание 2. Старшинство мастей по возрастанию: пики, трефы, бубны, червы. Старшинство карт в масти по возрастанию: двойка, тройка, четверка, пятерка, шестерка, семерка, восьмерка, девятка, десятка, валет, дама, король, туз.
# Примечание 3. Масти не требуют склонения и независимо от номинала должны сохранять следующее написание: пик, треф, бубен, червей.
# ---------------------------------------------------------------------------


def card_deck(suit):

    l1 = ['пик', 'треф', 'бубен', 'червей']
    l1.pop(l1.index(suit))
    while True:
        for i in l1:
            for j in ('2', '3', '4', '5', '6', '7', '8', '9', '10', 'валет', 'дама', 'король', 'туз'):
                yield f"{j} {i}"
# ---------------------------------------------------------------------------


def card_deck(suit: str):
    suits = ['пик', 'треф', 'бубен', 'червей']
    face_values = ['2', '3', '4', '5', '6', '7', '8',
                   '9', '10', 'валет', 'дама', 'король', 'туз']
    suits.remove(suit)
    while True:
        for suit_ in suits:
            for face_value in face_values:
                yield f'{face_value} {suit_}'


# ===========================================================================


# Функция matrix_by_elem()
# 959
# Вам доступна генераторная функция matrix_by_elem(), которая принимает в качестве аргумента матрицу произвольной размерности и возвращает генератор, порождающий последовательность элементов переданной матрицы.
# Перепишете данную функцию с использованием конструкции yield from, чтобы она выполняла ту же задачу.
# Примечание 1. Под матрицей подразумеваются исключительно вложенные списки.
# ---------------------------------------------------------------------------
def matrix_by_elem(matrix):
    for row in matrix:
        yield from row
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция palindromes()
#
# Реализуйте генераторную функцию palindromes(), которая не принимает никаких аргументов.
# Функция должна возвращать генератор, порождающий бесконечную последовательность натуральных чисел-палиндромов.
# Примечание 1. Число-палиндром — число, которое читается одинаково как справа налево, так и слева направо.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую генераторную функцию palindromes(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------
# from typing import Generator

def palindromes() -> Generator[int, None, None]:
    '''возвращает генератор, порождающий бесконечную последовательность натуральных чисел-палиндромов'''
    i = 1
    while True:
        n = str(i)
        if n == n[::-1]:
            yield i

        i += 1


# generator = palindromes()
# numbers = [next(generator) for _ in range(3000)]

# print(*numbers)


# ---------------------------------------------------------------------------
# Это решение основано на собирании палиндрома из строк, основанием для которых служит переменная base. Половинки палиндромов собираются из base и и ее зеркального отражения по определенному правилу. Закономерность изменения base тоже непростая: в общем случае base = str(int(base) + 1), однако при переходе от чисел с нечетным количеством знаков к числам с четным от base приходится "откидывать" лишний разряд.
# Данная реализация нахождения чисел-палиндромов работает практически молниеносно в сравнении с реализациями, основанными на переборе каждого целого числа с последующей проверкой его на палиндром.
def palindromes():
    '''быстрый поиск палиндром '''
    base = '0'
    prev_num = ''
    rule = False
    while True:
        if prev_num:
            yield prev_num
        base = str(int(base) + 1)
        next_num = f'{base}{base[-2::-1]}' if rule else f'{base}{base[::-1]}'
        if len(next_num) > len(prev_num):
            if len(prev_num) % 2:
                base = base[:-1]
            rule = not rule
            next_num = f'{base}{base[-2::-1]}' if rule else f'{base}{base[::-1]}'
        prev_num = next_num


# generator = palindromes()
# numbers = [next(generator) for _ in range(3000)]

# print(*numbers)
#
# ===========================================================================
# from string import digits

# Хорошая задачка. Сразу отказался от "простого" пути с проверкой строкового представления всех чисел подряд - это мы на предыдущих курсах практиковали. Реализовал сначала через рекурсию с мемоизацией, но в ней не нашлось места yield from ((
# Модифицировал во вложенный рекурсивный генератор, который выдает все палиндромы заданной длины, "собирая" их из цифр, и вызывая рекурсию для включения "внутренних" палиндромов - код простой и с комментариями. Здесь для yield from нашлось законное применение.
# Решение работает быстро, 100_000 палиндромов выдаются за 65 мс. Для сравнения, "простой" путь выдает 10_000 за 2 секунды на Colab, а для 100_000 я не дождался результата


def palindromes():
    '''быстрый поиск палиндром'''
    def pali(n):    # Внутренний генератор "строковых" палиндромов длиной n
        if n == 1:
            yield from digits
        elif n == 2:
            yield from (d * 2 for d in digits)
        else:       # Рекурсивный случай - "оборачиваем" одинаковыми цифрами "внутренние палиндромы"
            yield from (f"{d}{p}{d}" for d in digits for p in pali(n - 2))

    i = 0
    while True:
        i += 1
        for x in pali(i):    # Получаем все значения из внутреннего генератора
            if x[0] != "0":  # Если значение начинается с "0", оно недопустимо
                yield int(x)


# generator = palindromes()
# numbers = [next(generator) for _ in range(3000)]

# print(*numbers)
# ---------------------------------------------------------------------------


# Функция flatten()
# 938
# Реализуйте генераторную функцию flatten(), которая принимает один аргумент:
#     nested_list — список, элементами которого являются целые числа или списки, элементами которых, в свою очередь, также являются либо целые числа, либо списки; вложенность может быть произвольной
# Функция должна возвращать генератор, порождающий все числа, содержащиеся в nested_list, включая все числа из всех вложенных списков, а затем возбуждает исключение StopIteration.
# ---------------------------------------------------------------------------
def flatten(nested_list):

    for i in nested_list:
        if type(i) == int:
            yield i
        elif type(i) == list:
            yield from flatten(i)
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция cubes_of_odds()
# 972
# Вам доступна генераторная функция cubes_of_odds(), принимающая в качестве аргумента итерируемый объект, элементами которого являются целые числа, и возвращающая генератор, порождающий последовательность нечетных чисел переданного итерируемого объекта, возведенных в третью степень.
# Перепишите данную функцию с использованием генераторного выражения, чтобы она выполняла ту же задачу.
# Примечание 1. Если генераторное выражение становится достаточно большим, его можно записать в виде нескольких строк.
# ---------------------------------------------------------------------------
def cubes_of_odds(iterable):
    for number in iterable:
        if number % 2:
            yield number ** 3
# ---------------------------------------------------------------------------


def cubes_of_odds(iterable):
    return (number ** 3 for number in iterable if number % 2)
# ===========================================================================


# Функция is_prime()
# 972
# Вам доступна генераторная функция cubes_of_odds(), принимающая в качестве аргумента итерируемый объект, элементами которого являются целые числа, и возвращающая генератор, порождающий последовательность нечетных чисел переданного итерируемого объекта, возведенных в третью степень.
# Перепишите данную функцию с использованием генераторного выражения, чтобы она выполняла ту же задачу.
# Примечание 1. Если генераторное выражение становится достаточно большим, его можно записать в виде нескольких строк.
# ---------------------------------------------------------------------------
# from typing import Iterable

def is_prime(n: int) -> bool:
    '''простых неотрицательных чисел (возврацает true)'''
    # Оптимизированный алгоритм поиска простых неотрицательных чисел:
    #     проверить на 0 и 1
    #     проверить на чётность и равенство 2 (исключается ~50% чисел)
    #     проверить на кратность 3 и равенство 3 (исключается ещё ~33% чисел)
    #     для проверки оставшихся чисел воспользоваться формулой 6n ± 1 (при n = 1, простыми будут 5 и 7, при n = 2: 11 и 13, и т.д.)
    #     как отмечено раньше, проверять делители следует до корня из заданного числа


def is_prime(num):
    prime = num > 1 and (num % 2 != 0 or num == 2) and (
        num % 3 != 0 or num == 3)
    i = 5
    d = 2

    while prime and i * i <= num:
        prime = num % i != 0
        i += d
        d = 6 - d  # чередование прироста 2 и 4: 5 + 2, 7 + 4, 11 + 2, и т.д.
    return prime


def primes(left: int, right: int) -> Iterable:
    '''ф-я возвращает генератор, порождающий последовательность простых чисел от left до right включительно, а затем возбуждающий исключение StopIteration.'''

    return (i for i in range(left, right + 1) if is_prime(i))
# ---------------------------------------------------------------------------
# from sympy import isprime as is_prime
# ===========================================================================


def is_prime(number: int) -> bool:
    return number != 1 and all(number % i != 0 for i in range(2, round(number**0.5)+1))
# ===========================================================================

# Функция count_iterable()
# 973
# Реализуйте функцию count_iterable() с использованием генераторных выражений, которая принимает один аргумент:
#     iterable — итерируемый объект
# Функция должна возвращать единственное число — количество элементов итерируемого объекта iterable.
# Примечание 1. Гарантируется, что передаваемый в функцию итерируемый объект является конечным.
# ---------------------------------------------------------------------------


def count_iterable(iterable):
    if '__next__' not in dir(iterable):
        return len(iterable)
    else:
        gen = (i for i in iterable)
        i = 0
        while True:
            try:
                next(gen)
                i += 1
            except StopIteration:
                break
        return i


data = filter(None, range(100_000_001))

print(count_iterable(data))
# ---------------------------------------------------------------------------
# подсчет количества элементов итератора


def count_iterable(iterable) -> int:
    '''подсчет количества элементов итератора'''
    return sum(1 for _ in iterable)
# ===========================================================================


# Функция all_together()
# 977
# Реализуйте функцию all_together() с использованием генераторных выражений, которая принимает произвольное количество позиционных аргументов, каждый из которых является итерируемым объектом.
# Функция должна возвращать генератор, порождающий каждый элемент всех переданных итерируемых объектов: сначала все элементы первого итерируемого объекта, затем второго, и так далее.
# Примечание 1. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------
def all_together(*args):
    '''Функция должна возвращать генератор, порождающий каждый элемент всех переданных итерируемых объектов: сначала все элементы первого итерируемого объекта, затем второго, и так далее.'''

    return (el for arg in args for el in arg)
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция interleave()
# 956
# Реализуйте функцию interleave() с использованием генераторных выражений, которая принимает произвольное количество позиционных аргументов, каждый из которых является последовательностью.
# Функция должна возвращать генератор, порождающий каждый элемент всех переданных последовательностей: сначала первый элемент первой последовательности, затем первый элемент второй последовательности, и так далее; после второй элемент первой последовательности, затем второй элемент второй последовательности, и так далее.
# Примечание 1. Последовательностью является коллекция, поддерживающая индексацию и имеющая длину. Например, объекты типа list, str, tuple являются последовательностями.
# Примечание 2. Гарантируется, что все последовательности, передаваемые в функцию, имеют равные длины.
# Примечание 3. Гарантируется, что в функцию всегда подается хотя бы одна последовательность.
# ---------------------------------------------------------------------------
def interleave(*args):
    '''Функция должна возвращать генератор, порождающий каждый элемент всех переданных последовательностей: сначала первый элемент первой последовательности, затем первый элемент второй последовательности, и так далее; после второй элемент первой последовательности, затем второй элемент второй последовательности, и так далее.'''

    for iterable in zip(*args):
        yield from iterable
# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен именованный кортеж Person, который содержит данные о человеке. Первым элементом именованного кортежа является имя и фамилия человека, вторым — национальность, третьим — пол, четвертым — год рождения, пятым — год смерти. Если человек жив, год смерти считается равным 00. Также доступен список persons, содержащий эти кортежи.
# Дополните приведенный ниже код с использованием конвейеров генераторов, чтобы он вывел имя и фамилию самого молодого живого мужчины (male) из Швеции (Swedish).
#
# ---------------------------------------------------------------------------

Person = namedtuple('Person', ['name', 'nationality', 'sex', 'birth', 'death'])

persons = [Person('E. M. Ashe', 'American', 'male', 1867, 1941),
           Person('Goran Aslin', 'Swedish', 'male', 1980, 0),
           Person('Erik Gunnar Asplund', 'Swedish', 'male', 1885, 1940),
           Person('Genevieve Asse', 'French', 'female', 1949, 0),
           Person('Irene Adler', 'Swedish', 'female', 2005, 0),
           Person('Sergio Asti', 'Italian', 'male', 1926, 0),
           Person('Olof Backman', 'Swedish', 'male', 1999, 0),
           Person('Alyson Hannigan', 'Swedish', 'female', 1940, 1987),
           Person('Dana Atchley', 'American', 'female', 1941, 2000),
           Person('Monika Andersson', 'Swedish', 'female', 1957, 0),
           Person('Shura_Stone', 'Russian', 'male', 2000, 0),
           Person('Jon Bale', 'Swedish', 'male', 2000, 0)]

gen1 = (i for i in persons if i[1] == 'Swedish')
gen2 = (i for i in gen1 if i[4] == 0)
gen3 = (i for i in gen1 if i[2] == 'male')
people = max(gen3, key=lambda x: x[3])

print(people[0])
# ---------------------------------------------------------------------------
# l1 = filter(lambda x: x[1] == 'Swedish', persons)
# l1 = filter(lambda x: x[4] == 0, l1)
# l1 = filter(lambda x: x[2] == 'male', l1)

# people = max(l1, key=lambda x: x[3])

# print(people[0])
# ===========================================================================

# Функция parse_ranges()
# 958
# Назовем диапазоном запись двух натуральных чисел через дефис a-b, где a — левая граница диапазона, b — правая граница диапазона, причем a <= b. Диапазон содержит в себе все числа от a до b включительно. Например, диапазон 1-4 содержит числа 11, 22, 33 и 44.
# Реализуйте генераторную функцию parse_ranges(), которая принимает один аргумент:
#     ranges — строка, в которой через запятую указаны диапазоны чисел
# Функция должна возвращать генератор, порождающий последовательность чисел, содержащихся в диапазонах ranges.
# ---------------------------------------------------------------------------


def parse_ranges(ranges: str) -> Generator[int, None, None]:
    '''Функция должна возвращать генератор, порождающий последовательность чисел, содержащихся в диапазонах ranges '''
    gen1 = (i for i in ranges.split(','))
    gen2 = (i.split('-') for i in gen1)
    gen3 = (range(int(a), int(b) + 1) for a, b in gen2)
    gen4 = (i for i in gen3)
    for i in gen4:
        yield from i
# ---------------------------------------------------------------------------


def parse_ranges(ranges: str):
    for r in ranges.split(","):
        start, end = map(int, r.split("-"))
        yield from range(start, end+1)
# ===========================================================================

# Функция filter_names()
#
# Реализуйте генераторную функцию filter_names(), которая принимает три аргумента в следующем порядке:
#     names — список имен
#     ignore_char — одиночный символ
#     max_names — натуральное число
# Функция должна возвращать генератор, порождающий max_names имён из списка names, игнорируя имена, которые
#     начинаются на ignore_char (в любом регистре)
#     содержат хотя бы одну цифру
# Если max_names больше количества имен в списке names, то генератор должен породить все возможные имена из данного списка.
# Примечание 1. Имена в возвращаемом функцией генераторе должны располагаться в своем исходном порядке.
# ---------------------------------------------------------------------------


def filter_names(names, ignore_char, max_names):
    gen1 = (
        i
        for i in names
        if (not (i.lower()).startswith(ignore_char.lower()))
        and
        (not (''.join(filter(lambda x: x in '0123456789', i))).isdigit())
    )

    for i in gen1:
        yield i
        max_names -= 1
        if not max_names:
            break

# ---------------------------------------------------------------------------


def filter_names(names, ignr, max_names):
    res = (n
           for n in names
           if n[0].lower() != ignr.lower()
           and not any(ch.isdigit() for ch in n))

    for _ in range(max_names):
        try:
            yield next(res)
        except:
            break
# ===========================================================================


# Инвестиции
# 940
# Вам доступен файл data.csv, который содержит информацию об инвестициях в различные стартапы. В первом столбце записано название компании (стартапа), во втором — инвестируемая сумма в долларах, в третьем — раунд инвестиции:
# company,raisedAmt,round
# LifeLock,6850000,b
# LifeLock,6000000,a
# LifeLock,25000000,c
# MyCityFaces,50000,seed
# Flypaper,3000000,a
# ...
# Напишите программу с использованием конвейеров генераторов, определяющую общую сумму, которая была инвестирована в раунде а, и выводящую полученный результат.
# Примечание 1. Разделителем в файле data.csv является запятая, при этом кавычки не используются.
#  При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------

with open('data.csv', 'r', encoding='utf-8') as file:
    rows = csv.DictReader(file)

    gen1 = (i for i in rows if i['round'] == 'a')
    gen2 = map(lambda x: int(x['raisedAmt']), gen1)

    print(sum(gen2))
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция years_days()
# 934
# Реализуйте генераторную функцию years_days(), которая принимает один аргумент:
#     year — натуральное число
# Функция должна возвращать генератор, порождающий последовательность всех дат (тип date) в году year.
# Примечание 1. Возьмем в качестве примера 20222022 год. В январе этого года 3131 день, в феврале — 2828, в марте — 3131, и так далее. Тогда генератор, полученный при вызове years_days(2022), должен порождать сначала все даты с 11 по 3131 января, затем с 11 по 2828 февраля, и так далее до 3131 декабря.
# ---------------------------------------------------------------------------


def years_days(year):
    td = timedelta(days=1)
    date1 = date(year, 1, 1)
    while date1.year < year + 1:
        yield date1
        date1 += td
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция nonempty_lines()
# 937
# Реализуйте генераторную функцию nonempty_lines(), которая принимает один аргумент:
#     file — название текстового файла, например, data.txt
# Функция должна возвращать генератор, порождающий последовательность всех непустых строк файла file с убранным символом переноса строки \n. Если строка содержит более 2525 символов, она заменяется многоточием ....
# Примечание 1. При открытии файла используйте явное указание кодировки UTF-8.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию nonempty_lines(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------


def nonempty_lines(f):
    with open(f, 'r', encoding='utf-8') as file:
        for line in file:
            line = line.strip(" '\n\t")
            if len(line) <= 25:
                if line != '':
                    yield line
            else:
                yield "..."


# ---------------------------------------------------------------------------

# ===========================================================================

# Функция txt_to_dict()
# 889
# # Вам доступен файл planets.txt, содержащий информацию о различных планетах. В первых четырех строках указаны характеристики первой планеты, после чего следует пустая строка, затем характеристики второй планеты, и так далее:
# Реализуйте генераторную функцию txt_to_dict(), которая не принимает никаких аргументов.
# Функция должна возвращать генератор, порождающий последовательность словарей, каждый из которых содержит информацию об очередной планете из файла planets.txt, а именно ее название, диаметр, массу и орбитальный период. Например:
# {'Name': 'Mercury', 'Diameter': '4879.4', 'Mass': '3.302×10^23', 'OrbitalPeriod': '0.241'}
# Примечание 2. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------------------
def txt_to_dict():

    with open('planets.txt', encoding='utf-8') as file:
        gen1 = (line.split('\n\n') for line in file)
        gen2 = (i[0].strip('\n') for i in gen1)
        gen3 = (i.split(' = ') for i in gen2 if i.strip())

        l1 = []
        for i in gen3:
            l1.append(i)
            if len(l1) == 4:
                yield {i: j for i, j in l1}
                l1 = []
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция unique()
#
# Реализуйте генераторную функцию, которая принимает один аргумент:
#     iterable — итерируемый объект
# Функция должна возвращать генератор, порождающий последовательность элементов итерируемого объекта iterable без дубликатов.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией генераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------


def unique(iter1):
    iterable = tuple(iter1)
    # смысл взять только уникальные ключи из словаря,
    counter = dict.fromkeys(iterable, 0)
# т к они добавлены попорядку и уникальны

    yield from counter
# ===========================================================================

# смысл взять только уникальные ключи из словаря,
# т к они добавлены попорядку и уникальны


def unique(numbers):
    yield from (dict.fromkeys(numbers))

# ---------------------------------------------------------------------------


def unique(iterable):
    res = Counter(iterable)
    for i in res:
        yield i
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция stop_on()
# 956
# Реализуйте генераторную функцию, которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     obj — произвольный объект
# Функция должна возвращать генератор, порождающий последовательность элементов итерируемого объекта iterable до тех пор, пока не будет достигнут элемент, равный obj. Если итерируемый объект iterable не содержит ни одного элемента, равного obj, генератор должен породить все элементы iterable.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией генераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# from typing import Any


def stop_on(iterable: iter, obj: Any) -> Any:
    for item in iterable:
        if item == obj:
            break
        yield item
# ---------------------------------------------------------------------------


def stop_on(iterable, obj):
    it = iter(iterable)
    return iter(lambda: next(it), obj)
# ===========================================================================

# Функция with_previous()
# 945
# Реализуйте генераторную функцию, которая принимает один аргумент:
#     iterable — итерируемый объект
# Функция должна возвращать генератор, порождающий последовательность кортежей, каждый из которых содержит очередной элемент итерируемого объекта iterable, а также предшествующий ему элемент:
# (<очередной элемент>, <предыдущий элемент>)
# Для первого элемента предыдущим считается значение None.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией генераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------


def with_previous(iterable):
    '''Функция должна возвращать генератор, порождающий последовательность кортежей, каждый из которых содержит очередной элемент итерируемого объекта iterable, а также предшествующий ему элемент:'''
    if iterable:
        iter1 = iter(iterable)

        next1 = next(iter1)
        yield (next1, None)

        for i in iter1:
            yield (i, next1)
            next1 = i
    else:
        return []
# ----------------------------------------


def with_previous(iterable, previous=None):
    for c in iterable:
        yield c, previous
        previous = c
# ===========================================================================


def with_previous(iterable):
    i = list(iterable)
    it1 = iter(i)
    it2 = iter((None, *i))
    yield from zip(it1, it2)
# ---------------------------------------------------------------------------

# Функция pairwise()
# 926
# Реализуйте генераторную функцию, которая принимает один аргумент:
#     iterable — итерируемый объект
# Функция должна возвращать генератор, порождающий последовательность кортежей, каждый из которых содержит очередной элемент итерируемого объекта iterable, а также следующий за ним элемент:
# (<очередной элемент>, <следующий элемент>)
# Для последнего элемента следующим считается значение None.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией генераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------


def pairwise(iterable):
    if iterable:
        iterable = iter(iterable)
        a = next(iterable)
        try:
            for i in iterable:
                yield (a, i)
                a = i
            yield (i, None)
        except:
            yield (a, None)
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция around()
# 902
# Реализуйте генераторную функцию, которая принимает один аргумент:
#     iterable — итерируемый объект
# Функция должна возвращать генератор, порождающий последовательность кортежей, каждый из которых содержит очередной элемент итерируемого объекта iterable, а также предыдущий и следующий за ним элементы:
# (<предыдущий элемент>, <очередной элемент>, <следующий элемент>)
# Для первого элемента предыдущим считается значение None, для последнего элемента следующим считается так же значение None.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией генераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------


def around(iterable):
    if iterable:
        iterable = iter(iterable)
        start = None
        a = next(iterable)

        try:
            for i in iterable:
                yield (start, a, i)
                start = a
                a = i
            yield (a, i, None)
        except:
            yield (None, a, None)
# ---------------------------------------------------------------------------


def around(iterable):
    it = tuple(iterable)
    yield from zip((None, *it), it, (*it[1:], None))
# ===========================================================================


def around(iterable):
    """элемент итерируемого объекта iterable,
    а также предыдущий и следующий за ним элементы
    """
    seq1 = list(iterable)
    seq2 = [None] + list(seq1[:-1])
    seq3 = list(seq1[1:])+[None]
    result = zip(seq2, seq1, seq3)
    yield from result

# ---------------------------------------------------------------------------


def around(iterable: Iterable) -> Generator[Any, Any, Any]:
    '''Функция возвращает генератор, порождающий последовательность кортежей, 
    каждый из которых содержит очередной элемент итерируемого объекта iterable, 
    а также предыдущий и следующий за ним элементы:'''
    # итератор
    iterator = iter(iterable)
    # предыдущий объект
    previous_object = None
    # текущий объект
    current_object = next(iterator, None)
    # следующий объект
    next_object = next(iterator, None)

    while not current_object is None:  # цикл пока текщий обьект не равен None
        # возврат значения
        yield previous_object, current_object, next_object
        # предыдущий перезаписывается текущим
        previous_object = current_object
        # текущий перезаписывается следующим
        current_object = next_object
        # следующий берется из итератора
        next_object = next(iterator, None)


#
#
# волна
# ---------------------------------------------------------------------------
# import time

# symbols = ['.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_','.', '-', "'", '"', "'", '-', '.', '_',]

# while True:
#     symbols = '\r' + symbols.pop() + ''.join(symbols)
#     print(symbols, end='')
#     symbols = list(symbols)[1:]
#     time.sleep(0.1)
# ---------------------------------------------------------------------------

# import itertools as it
# import time

# symbols = ['.', '-', "'", '"', "'", '-', '.', '_']

# for c in it.cycle(symbols):
#     print(c, end='', flush=True)
#     time.sleep(0.005)
# ===========================================================================

#  Функция tabulate()
# 948
# Реализуйте функцию tabulate(), которая принимает один аргумент:
#     func — произвольная функция
# Функция tabulate() должна возвращать итератор, генерирующий бесконечную последовательность возвращаемых значений функции func сначала с аргументом 1, затем 2, затем 3, и так далее.
# ---------------------------------------------------------------------------

# from itertools import count

def tabulate(func):
    for i in count(1):
        yield func(i)

# func = lambda x: x
# values = tabulate(func)

# print(next(values))
# print(next(values))

# ---------------------------------------------------------------------------
# from itertools import count


def tabulate(func):
    return map(func, count(1))
# ===========================================================================
# from itertools import *


def tabulate(f): return map(f, count(1))
# ---------------------------------------------------------------------------


# Функция factorials()
#
# Реализуйте функцию factorials() с использованием функции accumulate(), которая принимает один аргумент:
#     n — натуральное число
# Функция должна возвращать итератор, генерирующий последовательность из n чисел, каждое из которых является факториалом очередного натурального числа.
# ---------------------------------------------------------------------------
# from itertools import accumulate
# import operator

def factorials(n):
    gen1 = (i for i in range(1, n + 1))

    return accumulate(gen1, operator.mul)


# numbers = factorials(6)

# print(*numbers)
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция alnum_sequence()
# 965
# Реализуйте функцию alnum_sequence(), которая не принимает никаких аргументов.
# Функция должна возвращать итератор, циклично генерирующий бесконечную последовательность натуральных чисел и заглавных латинских букв:
# ---------------------------------------------------------------------------
# import string
# from itertools import cycle

def alnum_sequence():
    gen1 = cycle(i for i in enumerate(string.ascii_uppercase, 1))
    for i, j in gen1:
        yield i
        yield j

# alnum = alnum_sequence()

# print(*(next(alnum) for _ in range(55)))

# ---------------------------------------------------------------------------
# from itertools import cycle
# from string import ascii_uppercase


def alnum_sequence():
    for item in zip(cycle(range(1, 27)), cycle(ascii_uppercase)):
        yield from item
# ===========================================================================

# Функция roundrobin() 🌶️
# 868
# Реализуйте функцию roundrobin(), которая принимает произвольное количество позиционных аргументов, каждый из которых является итерируемым объектом.
# Функция должна возвращать итератор, генерирующий последовательность из элементов всех переданных итерируемых объектов: сначала первый элемент первого итерируемого объекта, затем первый элемент второго итерируемого объекта, и так далее; после второй элемент первого итерируемого объекта, затем второй элемент второго итерируемого объекта, и так далее.
# Примечание 1. Элементы итерируемых объектов в возвращаемом функцией итераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------
# from itertools import starmap


def roundrobin(*args):
    def f1(x): return x
    return starmap(f1, *args)


# ---------------------------------------------------------------------------

# ===========================================================================

# Функция drop_while_negative()
#
# Реализуйте функцию drop_while_negative(), которая принимает один аргумент:
#     iterable — итерируемый объект, элементами которого являются целые числа
# Функция должна возвращать итератор, генерирующий все числа итерируемого объекта iterable, начиная с первого неотрицательного числа.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# from itertools import dropwhile

def drop_while_negative(iterable):
    return dropwhile(lambda x: x < 0, iterable)
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция drop_this()
#
# Реализуйте функцию drop_this(), которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     obj — произвольный объект
# Функция должна возвращать итератор, генерирующий последовательность элементов итерируемого объекта iterable, начиная с элемента, не равного obj.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# from itertools import dropwhile


def drop_this(iterable, obj):
    return dropwhile(lambda x: x == obj, iterable)
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция first_true()
# 967
# Реализуйте функцию first_true(), которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     predicate — функция-предикат; если имеет значение None, то работает аналогично функции bool()
# Функция first_true() должна возвращать первый по счету элемент итерируемого объекта iterable, для которого функция predicate вернула значение True. Если такого элемента нет, функция first_true() должна вернуть значение None.
# Примечание 1. Предикат — это функция, которая возвращает True или False в зависимости от переданного в качестве аргумента значения.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# import itertools as it


def first_true(iterable, predicate):
    iter1 = it.takewhile(predicate, iterable)

    try:
        return next(iter1)
    except:
        pass
# ---------------------------------------------------------------------------


def first_true(iterable, func):
    return next(filter(func, iterable), None)
# ===========================================================================

# Функция take()
#
# Реализуйте функцию take(), которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     n — натуральное число
# Функция должна возвращать итератор, генерирующий последовательность из первых n элементов итерируемого объекта iterable.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# import itertools as it


def take(iterable, n):
    return it.islice(iterable, n)
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция take_nth()
#
# Реализуйте функцию take_nth(), которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     n — натуральное число
# Функция должна возвращать n-ый по счету элемент итерируемого объекта iterable. Если итерируемый объект iterable содержит менее n элементов, функция должна вернуть значение None.
# Примечание 1. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# from typing import Generator, Iterable
# from itertools import islice


def take_nth(iterable: Iterable, n: int) -> Generator[int, None, None]:
    '''Функция должна возвращать n-ый по счету элемент итерируемого объекта iterable. Если итерируемый объект iterable содержит менее n элементов, функция должна вернуть значение None.'''

    try:
        return next(islice(iter(iterable), n - 1, n))
    except:
        return
# ---------------------------------------------------------------------------

# ===========================================================================

# Функция first_largest()
# 953
# Реализуйте функцию first_largest(), которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект, элементами которого являются целые числа
#     number — произвольное число
# Функция должна возвращать индекс первого элемента итерируемого объекта iterable, который больше number. Если таких элементов нет, функция должна вернуть число −1−1.
# Примечание 1. Рассмотрим список чисел 10,2,14,7,7,18,2010,2,14,7,7,18,20 из первого теста. Первым числом, превосходящим 1111, является число 1414, которое имеет индекс 22.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------
# import itertools as it


def first_largest(iterable, number):
    try:
        iter1 = enumerate(iterable)
        iter2 = it.dropwhile(lambda x: x[1] < number, iter1)

        return next(iter2)[0]

    except StopIteration:
        return -1
# ---------------------------------------------------------------------------
# from itertools import compress, count


def first_largest(it, n): return next(
    compress(count(), (i > n for i in it)), -1)
# ===========================================================================


# Функция sum_of_digits()
# 961
# Реализуйте функцию sum_of_digits(), которая принимает один аргумент:
#     iterable — итерируемый объект, элементами которого являются натуральные числа
# Функция должна возвращать единственное число — сумму цифр всех чисел, присутствующих в итерируемом объекте iterable.
# Примечание 1. Рассмотрим набор чисел 13,20,41,2,2,513,20,41,2,2,5 из первого теста. Сумма цифр всех представленных чисел будет равна:
# 1+3+2+0+4+1+2+2+5=20
# ---------------------------------------------------------------------------

# import itertools as it

def suim_of_digits(iterable):
    iter1 = map(str, iterable)
    iter2 = it.chain(iter1)
    iter3 = map(str, iter2)

    return sum(iter3)


# ---------------------------------------------------------------------------

# ===========================================================================


# Функция is_rising()
# 979
# Реализуйте функцию is_rising(), которая принимает один аргумент:
#     iterable — итерируемый объект, элементами которого являются числа
# Функция должна возвращать True, если элементы итерируемого объекта расположены строго по возрастанию, или False в противном случае.
# Примечание 1. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством, а также содержит не менее двух элементов.
# ---------------------------------------------------------------------------

# from typing import Iterable
# import itertools as it

def is_rising(iterable: Iterable[int | float]) -> bool:
    iter1 = it.pairwise(iterable)
    iter2 = map(lambda x: x[0] < x[1], iter1)

    return all(iter2)
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция max_pair()
# 978
# Реализуйте функцию max_pair(), которая принимает один аргумент:
#     iterable — итерируемый объект, элементами которого являются числа
# Функция должна возвращать единственное число — максимальную сумму двух соседних чисел итерируемого объекта iterable.
# Примечание 1. Рассмотрим список чисел 1,8,2,4,31,8,2,4,3 из первого теста. Из данной последовательности можно получить следующие пары соседних элементов: 11 и 88, 88 и 22, 22 и 44, 44 и 33. Максимальную сумму имеет вторая пара — 1010.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством, а также содержит не менее двух элементов.
# ---------------------------------------------------------------------------
# from typing import Iterable
# import itertools as it


def max_pair(iterable: Iterable[int | float]) -> int:
    ''' Функция возвращаtn единственное число — максимальную сумму двух соседних чисел итерируемого объекта iterable.'''

    iter1 = it.pairwise(iterable)
    max_tuple = max(iter1, key=lambda x: x[0] + x[1])
    return sum(max_tuple)
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция ncycles()
# 965
# Реализуйте функцию ncycles(), которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     times — натуральное число
# Функция должна возвращать итератор, генерирующий последовательность элементов итерируемого объекта iterable, зацикленных times раз.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# from typing import Iterable, Generator
# import itertools as it


def ncycles(iterable: Iterable[int | float], times: int) -> Generator[int, None, None]:
    ''' Функция должна возвращать итератор, генерирующий последовательность элементов итерируемого объекта iterable, зацикленных times раз.'''

    return it.chain.from_iterable(it.tee(iterable, times))
# ---------------------------------------------------------------------------
# import itertools as it


def ncycles(iterable, times):
    for new_iterable in it.tee(iterable, times):
        yield from new_iterable
# ===========================================================================


# Функция grouper()
# 902
# Реализуйте функцию grouper(), которая принимает два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     n — натуральное число
# Функция должна возвращать итератор, генерирующий последовательность, элементами которой являются объединенные в кортежи по n элементов соседние элементы итерируемого объекта iterable. Если у элемента не достаточно соседей, то ими становится значение None.
# Примечание 1. Элементы итерируемого объекта в возвращаемом функцией итераторе должны располагаться в своем исходном порядке.
# Примечание 2. Гарантируется, что итерируемый объект, передаваемый в функцию, не является множеством.
# ---------------------------------------------------------------------------

# import itertools as it
# from typing import Iterable, Generator


def grouper(iterable: Iterable[int | float], n: int):
    '''Функция должна возвращать итератор, генерирующий последовательность, элементами которой являются объединенные в кортежи по n элементов соседние элементы итерируемого объекта iterable. Если у элемента не достаточно соседей, то ими становится значение None'''

    iter1 = iter(iterable)

    while True:
        try:
            l1 = []
            for i in range(n):
                l1.append(next(iter1))
            yield tuple(l1)

        except StopIteration:
            while len(l1) % n > 0:
                l1.append(None)

            break

    if l1:
        yield tuple(l1)
# ---------------------------------------------------------------------------
# from itertools import repeat, zip_longest

# создаем в зипе повторяющийся тот же самый объект - основной итератор (ссылка на один и тот же итератор в памяти)


def grouper(iterable, n):
    return zip_longest(*repeat(iter(iterable), n))
# ===========================================================================
# from itertools import zip_longest


def grouper(it, n):
    x = iter(it)
    return zip_longest(*[x]*n)

# ===========================================================================


#
# 948
# # ам доступен именованный кортеж Person, который содержит данные о человеке. Первым элементом именованного кортежа является имя человека, вторым — возраст, третьим — рост. Также доступен список persons, содержащий эти кортежи.
# Дополните приведенный ниже код, чтобы он сгруппировал людей из данного списка по их росту и вывел полученные группы. Для каждой группы сначала должен быть указан рост, а затем через запятую перечислены имена людей, имеющих соответствующий рост. Группы должны быть расположены в порядке увеличения роста, каждая на отдельной строке, имена в группах — в алфавитном порядке, в следующем формате:
# <рост>: <имя>, <имя>, ...
# ---------------------------------------------------------------------------
# import itertools as it


# from collections import namedtuple
# from itertools import groupby

Person = namedtuple('Person', ['name', 'age', 'height'])

persons = [Person('Tim', 63, 193), Person('Eva', 47, 158),
           Person('Mark', 71, 172), Person('Alex', 45, 193),
           Person('Jeff', 63, 193), Person('Ryan', 41, 184),
           Person('Ariana', 28, 158), Person('Liam', 69, 193)]

persons.sort(key=lambda x: x.height)

group_iter = it.groupby(persons, key=lambda x: x.height)

for key, value in group_iter:
    gen1 = (i.name for i in value)
    print(f"{key}: {', '.join(sorted(gen1))}")
# ---------------------------------------------------------------------------

# ===========================================================================


# Вам доступен именованный кортеж Student, который содержит данные об ученике. Первым элементом именованного кортежа является фамилия ученика, вторым — имя, третьим — класс. Также доступен список students, содержащий эти кортежи.
# Дополните приведенный ниже код, чтобы он вывел наиболее часто встречаемое имя среди учеников из данного списка.
# Примечание. Гарантируется, что искомое имя единственное.
#
# ---------------------------------------------------------------------------
# from collections import namedtuple, Counter
# from itertools import groupby

Student = namedtuple('Student', ['surname', 'name', 'grade'])

students = [Student('Гагиев', 'Александр', 10), Student('Дедегкаев', 'Илья', 11), Student('Кодзаев', 'Георгий', 10),
            Student('Набокова', 'Алиса', 11), Student(
                'Кораев', 'Артур', 10), Student('Шилин', 'Александр', 11),
            Student('Уртаева', 'Илина', 11), Student(
                'Салбиев', 'Максим', 10), Student('Капустин', 'Илья', 11),
            Student('Гудцев', 'Таймураз', 11), Student(
                'Перчиков', 'Максим', 10), Student('Чен', 'Илья', 11),
            Student('Елькина', 'Мария', 11), Student(
                'Макоев', 'Руслан', 11), Student('Албегов', 'Хетаг', 11),
            Student('Щербак', 'Илья', 10), Student(
                'Идрисов', 'Баграт', 11), Student('Гапбаев', 'Герман', 10),
            Student('Цивинская', 'Анна', 10), Student(
                'Туткевич', 'Юрий', 11), Student('Мусиков', 'Андраник', 11),
            Student('Гадзиев', 'Георгий', 11), Student(
                'Белов', 'Юрий', 11), Student('Акоева', 'Диана', 11),
            Student('Денисов', 'Илья', 11), Student('Букулова', 'Диана', 10), Student('Акоева', 'Лера', 11)]


def func(x): return x.name


l1 = sorted(students, key=func)
group_iter = groupby(l1, key=func)

cnt = Counter()
for key, value in group_iter:
    cnt[key] = len(list(value))

print(max(cnt.items(), key=lambda x: x[1])[0])
# ---------------------------------------------------------------------------


# ===========================================================================


# Группы слов
#
# Напишите программу, которая группирует слова по их длине.
# Формат входных данных
# На вход программе подается последовательность слов, разделенных пробелом. Каждое слово записано строчными латинскими буквами.
# Формат выходных данных
# Программа должна сгруппировать введенные слова по их длине и вывести полученные группы. Для каждой группы должна быть указана длина, а затем через запятую перечислены слова, имеющие соответствующую длину. Группы должны быть расположены в порядке увеличения длины, каждая на отдельной строке, слова в группах — в алфавитном порядке, в следующем формате:
# <длина> -> <слово>, <слово>, ...
# ---------------------------------------------------------------------------

# from itertools import groupby

words_gen = (i for i in sorted(input().split(), key=len))
words_group_iter = groupby(words_gen, key=len)

words_group = ((length_words, ', '.join(sorted(words)))
               for length_words, words in words_group_iter)

for length_words, words in sorted(words_group, key=lambda x: x[0]):
    print(f"{length_words} -> {words}")
# ---------------------------------------------------------------------------
# from itertools import groupby

s = sorted(input().split(), key=len)
for k, v in groupby(s, key=lambda x: (sum(1 for _ in x))):
    print(k, '->', ', '.join(sorted(v)))
# ===========================================================================


# Нет дел
#
# Каждый день Тимур записывает в блокнот дела, которые ему нужно выполнить. Каждое дело он разбивает на несколько действий.
# Вам доступен список tasks, в котором записаны все дела Тимура. Каждый элемент списка представляет собой кортеж из трех элементов: первый — название дела, второй — действие, третий — очередность.
# Дополните приведенный ниже код, чтобы он вывел все дела Тимура в алфавитном порядке, указав для каждого набор соответствующих действий в правильной очередности, в следующем формате:
# <дело>:
#     1. <действие>
#     2. <действие>
#     ...
# Между двумя делами должна быть расположена пустая строка.
# ---------------------------------------------------------------------------

# from collections import namedtuple
# from itertools import groupby

tasks = [('Отдых', 'поспать днем', 3),
         ('Ответы на вопросы', 'ответить на вопросы в дискорде', 1),
         ('ЕГЭ Математика', 'доделать курс по параметрам', 1),
         ('Ответы на вопросы', 'ответить на вопросы в курсах', 2),
         ('Отдых', 'погулять вечером', 4),
         ('Курс по ооп', 'обсудить темы', 1),
         ('Урок по groupby', 'добавить задачи на программирование', 3),
         ('Урок по groupby', 'написать конспект', 1),
         ('Отдых', 'погулять днем', 2),
         ('Урок по groupby', 'добавить тестовые задачи', 2),
         ('Уборка', 'убраться в ванной', 2),
         ('Уборка', 'убраться в комнате', 1),
         ('Уборка', 'убраться на кухне', 3),
         ('Отдых', 'погулять утром', 1),
         ('Курс по ооп', 'обсудить задачи', 2)]

Tasks = namedtuple('Tasks', ['task', 'action', 'priority'])
tasks1 = (Tasks._make(i) for i in tasks)

gpoup_iter1 = groupby(
    sorted(tasks1, key=lambda x: x.task), key=lambda x: x.task)

for task, action_iter in gpoup_iter1:
    print(f"{task}:")
    for elem in sorted(action_iter, key=lambda x: x.priority):
        print(f"    {elem.priority}. {elem.action}")
    print()
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция group_anagrams()
#
# Анаграммы — это слова, которые состоят из одинаковых букв. Например:
#     адаптер — петарда
#     адресочек — середочка
#     азбука — базука
#     аистенок — осетинка
# Реализуйте функцию group_anagrams(), которая принимает один аргумент:
#     words — список слов
# Функция должна группировать в кортежи слова из списка words, являющиеся анаграммами, и возвращать список полученных кортежей.
# Примечание 1. Порядок кортежей в возвращаемом функцией списке, а также порядок элементов в этих кортежах, не важен.
# ---------------------------------------------------------------------------
# from typing import Iterable
# import itertools as it

# def group_anagrams(words: list) -> Generator[tuple[str], None, None]:
def group_anagrams(words: list) -> Iterable[tuple]:
    '''Функция должна группировать в кортежи слова из списка words, являющиеся анаграммами, и возвращать список полученных кортежей.'''

    words_tuple_gen = ((word, len(word), ''.join(sorted(word)))
                       for word in words)
    # yield from words_tuple_gen

    group_iter = it.groupby(
        sorted(words_tuple_gen, key=lambda x: x[2]), key=lambda x: x[2])

    for k, v in group_iter:
        yield (f"{tuple((i[0] for i in v))}")
# ---------------------------------------------------------------------------
# from itertools import groupby


def group_anagrams(words):
    return (tuple(i) for _, i in groupby(sorted(words, key=sorted), key=sorted))
# ===========================================================================

# from itertools import groupby


def group_anagrams(words):
    for _, group in groupby(sorted(words, key=sorted), key=sorted):
        yield tuple(group)
# ===========================================================================


# Функция ranges() 🌶️
#
# Будем считать, что последовательность целых неотрицательных чисел можно преобразовать в отрезок, если разница между соседними элементами этой последовательности равна единице. Например, числа 3,4,5,6,7,83,4,5,6,7,8 можно преобразовать в отрезок [3;8][3;8]. Числа 1,3,5,11,15,221,3,5,11,15,22 в отрезок преобразовать нельзя. Одиночное число преобразуется в отрезок, в котором и правой, и левой границей является оно само. Например, число 11 можно преобразовать в отрезок [1;1][1;1].
# Реализуйте функцию ranges(), которая принимает один аргумент:
#     numbers — список различных натуральных чисел, расположенных в порядке возрастания
# Функция должна преобразовывать числа из списка numbers в отрезки, представляя их в виде кортежей, где первый элемент кортежа является левой границей отрезка, второй элемент — правой границей отрезка. Полученные кортежи-отрезки функция должна возвращать в виде списка.
# Примечание 1. Числа в возвращаемом функцией списке должны располагаться в своем исходном порядке.
# ---------------------------------------------------------------------------


# В формуле key=lambda x: numbers.index(x) - x функция группирует цифры по разнице между индексом и значением. Числа, которые идут по порядку будут иметь одинаковую разницу между индексом и значением и следовательно попадут в одну и ту же группу, которая будет обозначена этой разностью.
# key=lambda x: numbers.index(x)


# ---------------------------------------------------------------------------

# ===========================================================================

# Перестановки
# 942
# Напишите
# Формат входных данных
# На вход программе подается произвольная строка из строчных латинских букв, длина которой не превышает 1010 символов.
# Формат выходных данных
# Программа должна вывести все перестановки символов данной строки без дубликатов в алфавитном порядке, каждую на отдельной строке.
# ---------------------------------------------------------------------------


def permutations1(text: str) -> Iterator[tuple]:
    '''функция генератор кортежей - перестановки символов данной строки без дубликатов'''
    gen1 = it.permutations(text)
    for i in gen1:
        yield i


tuple1_iter = permutations1(input())

for i in sorted(set(tuple1_iter)):
    print(''.join(i))
# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# ---------------------------------------------------------------------------
# ---------------           РЕГУЛЯРНЫЕ  ВЫРАЖЕНИЯ          ------------------
# ---------------------------------------------------------------------------

# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности символов длины 55, удовлетворяющие следующим условиям:
    # первый символ — строчная латинская буква
    # второй символ — произвольная цифра
    # третий символ — строчная латинская буква
    # четвертый символ — заглавная латинская буква
    # пятый символ — заглавная латинская буква#
# ---------------------------------------------------------------------------
regex = r'[a-z]{1}[0-9]{1}[a-z]{1}[A-Z]{2}'
# ---------------------------------------------------------------------------
regex = r'[a-z]\d[a-z][A-Z]{2}'
# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности символов длины 66, удовлетворяющие следующим условиям:

# первый символ — произвольная цифра
# второй символ — строчная латинская гласная буква (a, e, i, o, u, y)
# третий символ — любой символ, кроме b, c, D, F
# четвертый символ — любой не пробельный символ
# пятый символ — любой символ, кроме заглавной латинской гласной буквы (A, E, I, O, U, Y)
# шестой символ — любой символ, кроме точки и запятой
# 923
# ---------------------------------------------------------------------------
regex = r'\d[aeiouy][^bcDF]\S[^AEIOUY][^.,]'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности символов длины 66, удовлетворяющие следующим условиям:
#     первый символ — цифра 11, 22 или 33
#     второй символ — цифра 00, 11 или 22
#     третий символ — цифра 11, 22 или строчная латинская буква x
#     четвертый символ — цифра 00, 33 или латинская буква a в любом регистре
#     пятый символ — строчная латинская буква x, s или u
#     шестой символ — точка или запятая
# Примечание. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------------------
regex = r'[1-3][0-2][12x][03aA][xsu][.,]'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют телефонные номера следующих форматов:
#     +7xxxxxxxxxx
#     +7(xxx)xxxxxxx
#     +7(xxx)-xxx-xx-xx
#     +7 xxx xxx xx xx
# где x — произвольная цифра.
# Примечание 1. Дополнительная проверка телефонного номера на корректность не требуется.
# Примечание 2. Символы +, ( и ) является метасимволами. Если требуется поиск соответствий самим символам  +, ( и ), то в регулярном выражении им должен предшествовать символ обратной косой черты  \+, \( и \).
# ---------------------------------------------------------------------------
regex = r'\+7\d{10}|\+7\(\d{3}\)[0-9]{7}|\+7\([0-9]{3}\)[-][0-9]{3}[-][0-9]{2}[-][0-9]{2}|\+7\s[0-9]{3}\s[0-9]{3}\s[0-9]{2}\s[0-9]{2}'
#  ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют даты следующих форматов:
# DD.MM.YYYY
# DD/MM/YYYY
# YYYY.MM.DD
# YYYY/MM/DD#
#
# ---------------------------------------------------------------------------
regex = r'[0-3][0-9]\.[01][0-9]\.[0-9]{4}|[0-3][0-9]\/[01][0-9]\/[0-9]{4}|[0-9]{4}\.[01][0-9]\.[1-3][0-9]|[0-9]{4}\/[01][0-9]\/[0-3][0-9]'
# ---------------------------------------------------------------------------
regex = r'\d{2}\.\d{2}\.\d{4}|' \
        r'\d{2}/\d{2}/\d{4}|' \
        r'\d{4}\.\d{2}\.\d{2}|' \
        r'\d{4}/\d{2}/\d{2}'
# ===========================================================================
regex = r'[0-9]{2}[.][0-9]{2}[.][0-9]{4}|' \
        r'[0-9]{2}/[0-9]{2}/[0-9]{4}|' \
        r'[0-9]{4}[.][0-9]{2}[.][0-9]{2}|' \
        r'[0-9]{4}/[0-9]{2}/[0-9]{2}'

# Так более наглядно, имхо. Но ни один из вариантов не универсален, т.к. будь тут запись 99.99.9999, например, то она тоже попадёт в результирующий набор. Но такой даты не существует. Ну или 31 февраля, к примеру

# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют времена формата HH:MM.
# Примечание 1. Требуется дополнительная проверка на корректность, то есть время 54:96 не должно соответствовать регулярному выражению regex.
#
# ---------------------------------------------------------------------------
regex = r'[0-1][0-9]:[0-5][0-9]|[0-2][0-3]:[0-5][0-9]'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют слова a, A, an и An.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W
#
# ---------------------------------------------------------------------------
regex = r'\b[Aa]n?\b'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют слова, написанные строго заглавными латинскими буквами.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W
#
# ---------------------------------------------------------------------------
regex = r'\b[A-Z]+\b'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют слова, начинающиеся с латинской заглавной буквы.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W
#
# ---------------------------------------------------------------------------
regex = r'\b[A-Z]\w*'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют строки, содержащие открывающую круглую скобку, а за ней когда-нибудь закрывающую круглую скобку.
#
# ---------------------------------------------------------------------------
regex = r'.*\(.+\).*'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют строки, удовлетворяющие следующим условиям:
# строка начинается с двух или более цифр
# после следуют ноль или более букв латинского алфавита в нижнем регистре
# строка оканчивается нулем или более букв латинского алфавита в верхнем регистре
# ---------------------------------------------------------------------------
regex = r'\d{2,}[a-z]*[A-Z]*\b'
# ---------------------------------------------------------------------------
regex = r'^\d{2,}[a-z]*[A-Z]*$'
# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют строки, удовлетворяющие следующим условиям:
# строка содержит исключительно буквы латинского алфавита в произвольном регистре
# строка оканчивается латинской буквой s в нижнем регистре
#
# ---------------------------------------------------------------------------
regex = r'^[a-zA-Z]*s$'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют строки длины 4545, удовлетворяющие следующим условиям:
# первые 4040 символов являются либо латинскими буквами произвольного регистра, либо четными цифрами
# последние 55 символов являются либо нечетными цифрами, либо символами пробела
# ---------------------------------------------------------------------------
regex = r'^[a-zA-Z02468]{40}[13579\s]{5}$'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют строки, удовлетворяющие следующим условиям:
# строка начинается с Mr., Mrs., Ms., Dr. или Er.
# оставшаяся часть строки состоит только из одной или более букв латинского алфавита в произвольном регистре
#
# ---------------------------------------------------------------------------
regex = r'^Mr\.[a-zA-Z]+$|^Mrs\.[a-zA-Z]+$|^Ms\.[a-zA-Z]+$|^Dr\.[a-zA-Z]+$|^Er\.[a-zA-Z]+$'
#  -------------------------------------------------------------------------------
regex = r'^[MDE]r\.[a-zA-Z]+$|^Mr?s\.[a-zA-Z]+$'
# ===========================================================================


#   Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют строки, удовлетворяющие следующим условиям:
# строка начинается с одной или двух цифр
# после следуют три или более буквы латинского алфавита в произвольном регистре
# оставшаяся часть строки содержит от 00 до 33 точек включительно

# ---------------------------------------------------------------------------
regex = r'^\d{1,2}[a-zA-Z]{3,}[.]{0,3}$'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют Американские почтовые индексы, удовлетворяющие следующим условиям:
# почтовый индекс начинается с пяти цифр
# далее следует необязательная часть из четырех цифр, которая отделяется от пяти первых цифр дефисом
#
# ---------------------------------------------------------------------------
regex = r'(\d{5})(\-\d{4})?'
# ---------------------------------------------------------------------------
regex = r'\d{5}(-\d{4})?'
# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют Североамериканские номера телефонов, удовлетворяющие следующим условиям:
#     номер телефона начинается из трехцифрового кода города, который может заключаться в круглые скобки
#     далее через пробел или дефис следует номер с семью цифрами, разделенный на трехцифровой префикс и четырехцифровой номер линии, между которыми указывается дефис
# В номере телефона могут использоваться любые цифры за двумя исключениями: первая цифра кода города и первая цифра префикса не могут быть 00 или 11.
# ---------------------------------------------------------------------------
regex = r'([23456789]\d{2}|\([23456789]\d{2}\))(\s|[-])[23456789]\d{2}[-]\d{4}'
# ---------------------------------------------------------------------------
regex = r'(\([2-9]\d{2}\)|[2-9]\d{2})[- ][2-9]\d{2}-\d{4}'
# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности символов, удовлетворяющие следующим условиям:
# последовательность должна состоять только из bee и geek
# последовательность должна содержать хотя бы один geek
# bee не может находиться рядом с самим собой (не может быть beebee)
# geek может появиться только после того, как до этого было записано bee
# после каждого bee когда-нибудь должен появиться geek
# ---------------------------------------------------------------------------
regex = r'((bee){1}(geek){1,})+'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности символов длины 66, удовлетворяющие следующим условиям:
# первый символ — строчная латинская буква
# второй символ — цифра, любая буква в произвольном регистре или символ нижнего подчеркивания
# третий символ — заглавная латинская буква
# четвертый символ должен совпадать с первым символом
# пятый символ должен совпадать со вторым символом
# шестой символ должен совпадать с третьим символом
#
# ---------------------------------------------------------------------------
regex = r'([a-z])(\w)([A-Z])\1\2\3'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют строки, содержащие три или более последовательных повторений ok.
# ---------------------------------------------------------------------------
regex = r'(ok){3,}'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности символов, представляющие собой девятисимвольные палиндромы.
# ---------------------------------------------------------------------------
regex = r'(.)(.)(.)(.).\4\3\2\1'
# ---------------------------------------------------------------------------

# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют слова, содержащие повторяющиеся буквы.#
# ---------------------------------------------------------------------------
regex = r'\w*(\w+)\w*\1\w*'
# ---------------------------------------------------------------------------
regex = r'\b\w*(\w)\w*\1\w*\b'
# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности из 88 цифр. Причем последовательность может содержать символы дефиса - в качестве разделителей, только если они делят ее на группы по 22 цифры.
# ---------------------------------------------------------------------------
regex = r'\d\d([-]?)\d\d\1\d\d\1\d\d'
# ---------------------------------------------------------------------------
regex = r'\d{2}(-?)(\d{2}\1){2}\d{2}'
# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют последовательности из 88 цифр, удовлетворяющие следующим условиям:
# последовательность может содержать символы -, --- или . в качестве разделителей, только если они делят ее на группы по 22 цифры
# последовательность должна содержать только один тип разделителя, если он присутствует
# ---------------------------------------------------------------------------
regex = r'\d\d(-?|(---)?|\.?)?\d\d\1\d\d\1\d\d'
# ---------------------------------------------------------------------------
regex = r'\d{2}(---|\.|-|)?\d{2}\1\d{2}\1\d{2}'
# ===========================================================================


# Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют слова, записанные дважды подряд. Слова могут быть разделены одним или несколькими пробелами.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W#
# ---------------------------------------------------------------------------
regex = r'\b(\w+)(\s+)\1\b'
# ---------------------------------------------------------------------------
regex = r'(\b\w+\b)[ ]+\b\1\b'
# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------
regex = r'\b[A-Za-zА-Яа-яЁё]{4}'
# ---------------------------------------------------------------------------

# ===========================================================================


# Телефонные номера
# 913
# Вам доступен набор телефонных номеров, имеющих следующие форматы:
#     <код страны>-<код города>-<номер>
#     <код страны> <код города> <номер>
# в котором код страны и код города представлены последовательностями от одной до трех цифр включительно, а номер — последовательностью от четырех до десяти цифр включительно. Между кодом страны, кодом города и номером используется разделитель, которым служит либо символ дефис, либо пробел, причем одновременно оба вида разделителя в одном номере присутствовать не могут.
# Напишите программу, которая принимает произвольное количество телефонных номеров и для каждого выводит отдельно его код страны, код города и номер.
# Формат входных данных
# На вход программе подается произвольное количество телефонных номеров, удовлетворяющих приведенным выше шаблонам, каждый на отдельной строке.
# Формат выходных данных
# Программа должна для каждого введенного телефонного номера вывести отдельно его код страны, код города и номер в следующем формате:
# Код страны: <код страны>, Код города: <код города>, Номер: <номер>
# ---------------------------------------------------------------------------
# import sys
# import re

pattern = r'(\d{1,3})(\s|-)(\d{1,3})(\2)(\d{4,10})'

gen_tel_numbers = (i.strip() for i in sys.stdin)

for i in gen_tel_numbers:
    match_tel1 = re.fullmatch(pattern, i).groups()
    print(match_tel1)
    print(
        f"Код страны: {match_tel1[0]}, Код города: {match_tel1[2]}, Номер: {match_tel1[4]}")
# ---------------------------------------------------------------------------
# import re
# import sys

pattern = r"(?P<country>\d{1,3})([ -]?)(?P<city>\d{1,3})\2(?P<number>\d{4,10})"
for number in map(str.rstrip, sys.stdin):
    match = re.fullmatch(pattern, number)
    groups = match.groupdict()
    print(
        f"Код страны: {groups['country']}, Код города: {groups['city']}, Номер: {groups['number']}")
# =======================================================================


# Онлайн-школа BEEGEEK
#
# В онлайн-школе BEEGEEK логин учетной записи определяется следующим образом:
#     первым символом является символ нижнего подчеркивания _
#     затем следуют одна или более цифр
#     после записываются ноль или более латинских букв в произвольном регистре
#     логин может иметь на конце необязательный символ нижнего подчеркивания _
# Напишите программу, которая принимает произвольное количество строк и определяет, какие из них представляют собой корректный логин онлайн-школы BEEGEEK.
# Формат входных данных
# На вход программе подаётся произвольное количество строк, каждая из которых содержит набор произвольных символов.
# Формат выходных данных
# Программа должна для каждой введенной строки вывести True, если она представляет собой корректный логин онлайн-школы BEEGEEK, или False в противном случае.
# ---------------------------------------------------------------------------
# import sys
# import re

pattern = r"[_]\d+[A-Za-z]*[_]?"
gen_logins = (i.rstrip() for i in sys.stdin)

for login in gen_logins:
    match1 = re.fullmatch(pattern, login)
    # короткое условие if else
    print(True if match1 else False)
# ---------------------------------------------------------------------------
    print(bool(match1))
# ===========================================================================
    print(match1 is not None)


# Одинаковые слоги
# 950
# ---------------------------------------------------------------------------
# Напишите программу, которая выводит слова, состоящие из двух одинаковых слогов.
# Формат входных данных
# На вход программе подается произвольное количество слов, каждое на отдельной строке.
# Формат выходных данных
# Программа должна из введенных слов вывести только те, которые состоят из двух одинаковых слогов. Слова должны быть расположены в своем исходном порядке, каждое на отдельной строке.
# Примечание 1. Словом будем считать любую непрерывную последовательность из одного или нескольких символов, соответствующих \w.
# ---------------------------------------------------------------------------
# import sys
# import re

pattern = r"^(\w+[aeiouy]{0,1})(\1)$"
gen_words = (i.rstrip() for i in sys.stdin)

for word in gen_words:
    match1 = re.search(pattern, word)
    if match1:
        print(word)
# ===========================================================================
# import sys
# import re

for line in map(str.rstrip, sys.stdin):
    if re.fullmatch(r'(\w+)\1', line):
        print(line)
# ===========================================================================


# Beegeek
#
# Напишите программу, определяющую:
#     количество строк, в которых bee встречается в качестве подстроки не менее двух раз
#     количество строк, в которых geek встречается в качестве слова хотя бы один раз
# Формат входных данных
# На вход программе произвольное количество строк, каждая из которых содержит набор произвольных символов.
# Формат выходных данных
# Программа должна вывести два числа:
#     первое — количество строк, в которых bee встречается в качестве подстроки не менее двух раз
#     второе — количество строк, в которых geek встречается в качестве слова хотя бы один раз
# каждое на отдельной строке.
# Примечание 1. Словом будем считать любую непрерывную последовательность из одного или нескольких символов, соответствующих \w.
# Примечание 2. Строка может одновременно удовлетворять обоим условиям.
# Примечание 3. В первой строке первого теста bee встречается в качестве подстроки 33 раза:
# ---------------------------------------------------------------------------
# import sys
# import re

gen_line = (i.rstrip() for i in sys.stdin)

pattern1 = r"(bee).*\1"
pattern2 = r"(\b(geek)\b)+"

cnt1 = 0
cnt2 = 0
for line in gen_line:
    if re.findall(pattern1, line):
        cnt1 += 1
    if re.search(pattern2, line):
        cnt2 += 1

print(cnt1)
print(cnt2)
# ---------------------------------------------------------------------------
# from re import search
# import sys

pattern_bee = r'(bee).*(bee)'
pattern_geek = r'\bgeek\b'
data = [i.rstrip() for i in sys.stdin]
print(sum(1 for i in data if search(pattern_bee, i)))
print(sum(1 for i in data if search(pattern_geek, i)))
# ===========================================================================


# Популярность
#
# В онлайн-школе BEEGEEK мы всегда следим за тем, насколько растет наша популярность. Для этого мы собираем публикации из различных соцсетей, которые содержат вхождения строки beegeek в нижнем регистре. Мы оцениваем публикацию:
#     в 33 балла, если она начинается и заканчивается строкой beegeek
#     в 22 балла, если она только начинается или только заканчивается строкой beegeek
#     в 11 балл, если она содержит строку beegeek только внутри
#     в 00 баллов, если она не содержит строку beegeek
# Напишите программу, которая определяет популярность онлайн-школы BEEGEEK путем суммирования баллов всех публикаций.
# Формат входных данных
# На вход программе подается произвольное число строк, каждая из которых представляет очередную публикацию.
# Формат выходных данных
# Программа должна определить, во сколько баллов оценивается каждая введенная публикация, и вывести сумму всех полученных баллов.
# Примечание 1. Если публикация представляет собой просто строку beegeek, то она оценивается в 22 балла.
# ---------------------------------------------------------------------------
# import sys
# import re

gen_line = (i.rstrip() for i in sys.stdin)

# если она начинается и заканчивается строкой beegeek
pattern1 = r"^(beegeek).*\1$"
# если она только начинается или только заканчивается строкой beegeek
pattern2 = r"^(beegeek)|(beegeek)$"
pattern3 = r".+(beegeek).+"  # если она содержит строку beegeek только внутри

cnt = 0

for line in gen_line:

    if re.findall(pattern1, line):
        cnt += 3

    elif re.search(pattern2, line):
        cnt += 2

    elif re.search(pattern3, line):
        cnt += 1

print(cnt)
# ---------------------------------------------------------------------------
# import re
# import sys

patterns = [
    r"^beegeek.*beegeek$",
    r"^beegeek.*|.*beegeek$",
    r".*beegeek.*"
]


def get_score(text: str) -> int:
    for score, pattern in enumerate(patterns, start=-3):
        match = re.search(pattern, text)
        if match:
            return abs(score)
    return 0


scores = 0
for text in map(str.rstrip, sys.stdin):
    scores += get_score(text)
print(scores)
# ===========================================================================


# Уважение
#
# На электронную почту Тимура нередко приходят письма с предложением о сотрудничестве. Тимур ценит взаимное уважение и считает письмо достойным внимания, если оно начинается с одного из следующих выражений:
#     Здравствуйте
#     Доброе утро
#     Добрый день
#     Добрый вечер
# Напишите программу, которая определяет, является ли письмо достойным внимания Тимура.
# Формат входных данных
# На вход программе подается единственная строка .
# Формат выходных данных
# Программа должна вывести True, если введенная строка начинается с одного из представленных в условии задачи выражений (в произвольном регистре), или False в противном случае.
# ---------------------------------------------------------------------------
# import re

s = input()

strings = ["Здравствуйте",
           "Доброе утро",
           "Добрый день",
           "Добрый вечер"]

flag = False

for start_string in strings:
    if re.match(start_string, s, re.IGNORECASE):
        flag = True
        break


print(flag)
# ---------------------------------------------------------------------------
# import re

message = input()
pattern = r"Здравствуйте|Доброе утро|Добрый (день|вечер)."

match = re.match(pattern, message, re.I)
print(bool(match))
# ===========================================================================


# Социальные сети
# 950
# Вам доступен набор популярных публикаций из социальной сети Твиттер, которые могут иметь следующий вид:
#     Люблю курсы BEEGEEK!
#     Когда курс по ООП? @timur_guev
#     BEEGEEK, спасибо за курсы, вы лучшие! #python #BeeGeek
#     и т.д.
# Напишите программу, которая определяет, в скольких публикациях содержится строка beegeek.
# Формат входных данных
# На вход программе подается произвольное число строк, каждая из которых представляет очередную публикацию.
# Формат выходных данных
# Программа должна определить, в скольких введенных строках содержится строка beegeek в произвольном регистре, и вывести полученный результат.
# ---------------------------------------------------------------------------
# import sys
# import re

pattern = r"beegeek"

cnt = 0
for line in map(str.rstrip, sys.stdin):
    if re.findall(pattern, line, re.IGNORECASE):
        cnt += 1

print(cnt)
# ---------------------------------------------------------------------------
# import sys, re
print(sum(bool(re.search(r'beegeek', s, re.I)) for s in sys.stdin))
# ===========================================================================
# ---------------------------------------------------------------------------
# import re
# import sys

data = (i.rstrip() for i in sys.stdin)
print(sum(1 for i in data if re.search(r'beegeek', i, re.I)))
# ===========================================================================
# ---------------------------------------------------------------------------
# import sys, re
print(sum(bool(re.search(r'beegeek', s, re.I)) for s in sys.stdin))
# ===========================================================================


# Вам доступна переменная article, содержащая некоторый многострочный текст. Дополните приведенный ниже код, чтобы он определил:
#     количество строк, которые начинаются со слова Stepik (в произвольном регистре);
#     количество строк, которые оканчиваются тремя точками ... или восклицательным знаком !.
# и вывел два соответствующих числа, каждое на отдельной строке.
# Примечание 1. Строка может одновременно удовлетворять обоим условиям.
# 940
# ---------------------------------------------------------------------------

# import re

article = '''Stepik (до августа 2016 года Stepic) — это образовательная платформа и конструктор онлайн-курсов!

Первые образовательные материалы были выпущены на Stepik 3 сентября 2013 года.
В январе 2016 года Stepik выпустил мобильные приложения под iOS и Android. В 2017 году разработаны мобильные приложения для изучения ПДД в адаптивном режиме для iOS и Android...

На октябрь 2020 года на платформе зарегистрировано 5 миллионов пользователей!
Stepik позволяет любому зарегистрированному пользователю создавать интерактивные обучающие уроки и онлайн-курсы, используя видео, тексты и разнообразные задачи с автоматической проверкой и моментальной обратной связью. 

Проект сотрудничает как с образовательными учреждениями, так и c индивидуальными преподавателями и авторами.  
Stepik сегодня предлагает онлайн-курсы от образовательных организаций, а также индивидуальных авторов!

Система автоматизированной проверки задач Stepik была использована в ряде курсов на платформе Coursera, включая курсы по биоинформатике от Калифорнийского университета в Сан-Диего и курс по анализу данных от НИУ «Высшая школа экономики»...

Stepik также может функционировать как площадка для проведения конкурсов и олимпиад, среди проведённых мероприятий — отборочный этап Олимпиады НТИ (2016—2020) (всероссийской инженерной олимпиады школьников, в рамках программы Национальная технологическая инициатива), онлайн-этап акции Тотальный диктант в 2017 году, соревнования по информационной безопасности StepCTF-2015...'''

result1 = re.findall('^(Stepik)', article, re.IGNORECASE | re.MULTILINE)
result2 = re.findall('(\.\.\.|!)$', article, re.MULTILINE)

print(len(result1))
print(len(result2))

# ---------------------------------------------------------------------------
print(len(re.findall('^stepik', article, re.I | re.M)))
print(len(re.findall('!$|\.\.\.$', article, re.M)))
# ===========================================================================
pattern1 = r'^[Ss]tepik'
pattern2 = r'\.\.\.$|!$'

print(sum(1 for i in article.splitlines() if re.search(pattern1, i, re.MULTILINE)))
print(sum(1 for i in article.splitlines() if re.search(pattern2, i, re.MULTILINE)))
# ---------------------------------------------------------------------------


# Подслова
# 960
# Напишите программу, которая принимает на вход строку текста и некоторое слово и определяет, сколько раз данное слово встречается как подслово в введенном тексте.
# Формат входных данных
# На вход программе на первой строке подается текст, на второй — слово.
# Формат выходных данных
# Программа должна определить, сколько раз данное слово встречается как подслово в введенном тексте, и вывести полученный результат.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W. Подсловом же будет являться последовательность символов, соответствующих \w, окруженную символами, соответствующими \w. Например, is является подсловом optimist, а age не является подсловом ageless.
# Примечание 2. Программа должна учитывать регистр. То есть, например, слова Python и python считаются разными.
# ---------------------------------------------------------------------------

# import re

text = input()
word = rf"\B{input()}\B"

result1 = re.findall(word, text)
print(len(result1))
# ---------------------------------------------------------------------------

# ===========================================================================


# Слова
#
# Напишите программу, которая принимает на вход строку текста и некоторое слово и определяет, сколько вхождений данного слова содержится в введенном тексте.
# Формат входных данных
# На вход программе на первой строке подается текст, на второй — слово.
# Формат выходных данных
# Программа должна определить, сколько вхождений данного слова содержится в веденном тексте, и вывести полученный результат.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W.
# Примечание 2. Рассмотрим первый тест, в котором содержится 66 вхождений слова foo:
# foo bar (foo) bar foo-bar foo_bar foo'bar bar-foo bar, foo.
# foo_bar же является самостоятельным словом.
# ---------------------------------------------------------------------------

# import re

text = input()
word = input()

result = re.findall(rf'\b({word})\b', text)
print(len(result))
# ---------------------------------------------------------------------------

# ===========================================================================


# Одинаковые и разные 🍕
# 958
# Американский английский и Британский английский языки имеют несколько различий, одно из которых наблюдается в написании слов. Например, слова, написанные на Американском английском языке и имеющие суффикс ze, в Британском варианте языка часто записываются с использованием суффикса se.
# Напишите программу, которая определяет, сколько раз слово встречается в тексте, учитывая его Британско-Американское написание.
# Формат входных данных
# На вход программе на первой строке подается слово, которое может быть записано как в Британском, так в Американском варианте, а на следующей — текст.
# Формат выходных данных
# Программа должна определить, сколько раз введенное слово встречается в тексте, учитывая его Британско-Американское написание, и вывести полученный результат.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W.
# Примечание 2. Программа должна игнорировать регистр. То есть, например, слова Python и python считаются одинаковыми.
# ---------------------------------------------------------------------------
# import re

word = input()[:-2]
text = input()

word = rf"\b{word}[zs]e\b"

match1 = re.findall(word, text, re.I | re.M)
print(len(match1))
# ---------------------------------------------------------------------------

# ===========================================================================


# Одинаковые и разные ☕️
# 946
# В одной из предыдущих задач мы уже наблюдали различие в написании Британских и Американских слов. Еще одно различие заключается в том, что Британия сохранила использование сочетания букв our в своих словах, в то время как Америка отказалась от буквы u и использует лишь or.
# Напишите программу, которая определяет, сколько раз слово встречается в тексте, учитывая его Британско-Американское написание.
# Формат входных данных
# На вход программе на первой строке подается слово, которое записано в Британском варианте, а на следующей — текст.
# Формат выходных данных
# Программа должна определить, сколько раз введенное слово встречается в тексте, учитывая его Британско-Американское написание, и вывести полученный результат.
# Примечание 1. Словом будем считать последовательность символов, соответствующих \w, окруженную символами, соответствующими \W.
# Примечание 2. Гарантируется, что введенное слово состоит из 44 или более букв.
# Примечание 3. Программа должна игнорировать регистр. То есть, например, слова Python и python считаются одинаковыми.
# ---------------------------------------------------------------------------

# import re

word = input()[:-2]
text = input()

word = rf"\b{word}ou?r\b"

match1 = re.findall(word, text, re.I | re.M)
print(len(match1))
# ---------------------------------------------------------------------------

# ===========================================================================


# Функция abbreviate()
#
# Аббревиатура — слово, образованное сокращением слова или словосочетания и читаемое по алфавитному названию начальных букв или по начальным звукам слов, входящих в него.
# Реализуйте функцию abbreviate(), которая принимает один аргумент:
#     phrase — фраза
# Функция должна создавать из фразы phrase аббревиатуру в верхнем регистре и возвращать её.
# Примечание 1. В аббревиатуре должны присутствовать как начальные буквы слов, так и начальные буквы подслов, начинающихся с заглавной буквы, например, JavaScript Object Notation -> JSON.
# ---------------------------------------------------------------------------

# import re

def abbreviate(phrase):
    '''Функция должна создавать из фразы phrase аббревиатуру в верхнем регистре и возвращать её.'''

    pattern = rf"[A-Z]|\b[A-Za-z]|\B[A-Z]\B"
    match = re.findall(pattern, phrase)

    return ''.join(match).upper()
# ---------------------------------------------------------------------------
# 1. В паттерне использовать |
# 2. Искать все заглавные буквы
# 3. Искать буквы в начале слова, в этом поможет \b
# 4. findall возвращает список, который можно объеденить с помощью join и применить upper()
# ===========================================================================
# import re


def abbreviate(phrase):
    return ''.join(re.findall(r'[A-Z]|\b\w', phrase)).upper()
# ---------------------------------------------------------------------------


# HTML 🌶️
#
# HTML-элементы — основа языка HTML. Каждый HTML-элемент обозначается начальным (открывающим) и конечным (закрывающим) тегами. Открывающий и закрывающий теги содержат имя элемента. Открывающий тег может содержать дополнительную информацию — атрибуты и значения атрибутов. Гиперссылки в языке HTML создаются с помощью тега <a></a>. Внутрь помещается текст, который будет отображаться на веб-странице. Обязательной составляющей тега <a></a> является атрибут href, который задает URL-адрес веб-страницы:
# <a href="https://stepik.org">Stepik</a>
# Гиперссылка состоит из двух частей — указателя (Stepik) и адресной части (https://stepik.org). Указатель ссылки представляет собой фрагмент текста или изображение, видимые для пользователя. Адресная часть ссылки пользователю не видна, она представляет собой адрес ресурса, к которому необходимо перейти. Иногда указатель может быть окружен различными тегами (<b></b>, <h1></h1>):
# <a href="https://stepik.org"><b><h1>Stepik</h1></b></a>
# Напишите программу, которая находит во фрагменте HTML-страницы все гиперссылки и выводит их составляющие — адресные части и указатели.
# Формат входных данных
# На вход программе подается произвольное количество строк, которые образуют фрагмент HTML-страницы.
# Формат выходных данных
# Программа должна найти во введенном фрагменте HTML-страницы все гиперссылки и вывести их составляющие — адресные части и указатели, в следующем формате:
# <адресная часть>, <указатель>
# <адресная часть>, <указатель>
# ...
# Примечание 1. Порядок следования данных об очередной гиперссылке должен совпадать с порядком их следования в введенном фрагменте HTML-страницы.
# ---------------------------------------------------------------------------
# import re
# import sys
gen1 = (i.rstrip() for i in sys.stdin)

for i in gen1:
    match1 = re.findall(r'<a href="(.+)">(.+)</a>', i)
    if match1:
        print(f'{match1[0][0]}, {match1[0][1]}')

# # ------------препод--------------------------------------
# import sys
# import re

text = sys.stdin.read()
pattern = r'<a href="(.+)">(.+)</a>'

for address, pointer in re.findall(pattern, text):
    print(f'{address}, {pointer}')
# ===========================================================================
# import re
# import sys
for i in list(map(str.strip, sys.stdin)):
    k = re.search(r'<a\shref="(.+)?">(.*)</a>', i)
    if k:
        print(f'{k.group(1)}, {k.group(2)}')


# HTML 🌶️🌶️
# 760
# HTML-элементы — основа языка HTML. Каждый HTML-элемент обозначается начальным (открывающим) и конечным (закрывающим) тегами. Открывающий и закрывающий теги содержат имя элемента. Открывающий тег может содержать дополнительную информацию — атрибуты и значения атрибутов:
# <b>BeeGeek</b>
# <a href="https://stepik.org">Stepik</a>
# В примере выше тег <b> не содержит никаких атрибутов, а тег <a> содержит атрибут href со значением https://stepik.org.
# Напишите программу, которая находит во фрагменте HTML-страницы все атрибуты каждого тега.
# Формат входных данных
# На вход программе подается произвольное количество строк, которые образуют фрагмент HTML-страницы.
# Формат выходных данных
# Программа должна найти в введенном фрагменте HTML-страницы все теги и вывести их, указав для каждого соответствующие атрибуты. Теги вместе со всеми атрибутами должны быть расположены каждый на отдельной строке, в следующем формате:
# <тег>: <атрибут>, <атрибут>, ...
# Теги, а также атрибуты тегов, должны быть расположены в лексикографическом порядке.
# ---------------------------------------------------------------------------

# "Не парсите HTML/XHTML/JSON с помощью регулярных выражений! Регулярные выражения не созданы для этого. Существуют специальные инструменты, которые помогут вам с этим разобраться, но это точно не регулярки." Поэтому в данном случае даже парится не стал - зачем тратить время на то что тебе никогда не пригодится?!

# ---------------------------------------------------------------------------

#  Да, мы отрабатываем здесь модуль re,  но при работе с HTML-тегами и их атрибутами это нецелесообразно из-за многострочности, + код становится практически нечитабельным. Так вот, здесь отлично подойдет BeautifulSoup (from bs4 import BeautifulSoup) - библиотека для разбора HTML и XML документов и уже знакомый нам defaultdict. Никого не принуждаю, возможно, кому-то данный способ будет полезен в будущем.

#     Импортируем BeautifulSoup,  import sys и  from collections import defaultdict.
#     Создаем defaultdict(set) в переменной, именно в него мы и будем помещать все необходимые нам теги (ключи) и их атрибуты (значения).
#     Потоковый ввод циклом for line in sys.stdin:

# И вот здесь, самое интересное: встроенный парсер "html.parser".

#     В цикл потокового ввода добавляем вложенный цикл for tag in BeautifulSoup(line, "html.parser")():
#     Обрабатываем полученные данные, добавляя их в наш словарь defaultdict:
#     переменная_со_словарем[tag.name] |= set(tag.attrs)
#     (Кто забыл, |= - это расширенный оператор присваивания . Его цель состоит в том, чтобы выполнить операцию на месте или операцию, как и обычная операция |).
#     Дальше только сортировка и вывод, надеюсь с ним проблем не возникнет.

# Если данная информация избыточна, то прошу прощения у модераторов и создателей, можете удалить.


# ===========================================================================


# Функция normalize_jpeg()
#
# Реализуйте функцию normalize_jpeg(), которая принимает один аргумент:
#     filename — название файла, имеющее расширение jpeg или jpg, которое может быть записано буквами произвольного регистра
# Функция должна возвращать новое название файла с нормализованным расширением — jpg.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию normalize_jpeg(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

# import re

def normalize_jpeg(filename: str) -> str:
    '''Функция должна возвращать новое название файла с нормализованным расширением — jpg.'''

    pattern = r"\.[jpegJPEG]+$"
    file_name = re.sub(pattern, '.jpg', filename)

    return file_name
# ---------------------------------------------------------------------------


def normalize_jpeg(filename: str) -> str:
    return re.sub(r"jpe?g$", "jpg", filename, flags=re.I)
# ===========================================================================


# Функция normalize_whitespace()
# 969
# Реализуйте функцию normalize_whitespace(), которая принимает один аргумент:
#     string — произвольная строка
# Функция должна заменять все множественные пробелы в строке string на единственный пробел и возвращать полученный результат.
# ---------------------------------------------------------------------------

# import re

def normalize_whitespace(string: str) -> str:
    '''Функция должна заменять все множественные пробелы в строке string на единственный пробел и возвращать полученный результат.'''

    pattern = r"\s+"
    replace_str = ' '

    return re.sub(pattern, replace_str, string)
# ---------------------------------------------------------------------------

# ===========================================================================


# Ключевые слова
# 957
# В Python существуют ключевые слова, которые нельзя использовать для названия переменных, функций и классов. Для получения списка всех ключевых слов можно воспользоваться атрибутом kwlist из модуля keyword.
# Приведенный ниже код:
# import keyword
# print(keyword.kwlist)
# выводит:
# ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
# Напишите программу, которая принимает строку текста и заменяет в ней все ключевые слова на <kw>.
# Формат входных данных
# На вход программе подается строка.
# Формат выходных данных
# Программа должна в введенном тексте заменить все ключевые слова (в любом регистре) на строку <kw> и вывести полученный результат.
# ---------------------------------------------------------------------------

# import re
# import keyword

def func1(match_obj):
    word = match_obj.group(0)
    return ('<kw>' if word.lower() in (i.lower() for i in keyword.kwlist) else word)


string1 = input()
pattern = r"\b(\w+)\b"

result = re.sub(pattern, func1, rf"{string1}")
print(result)
# ---------------------------------------------------------------------------

# ===========================================================================


# Первые буквы
# 955
# Напишите программу, которая меняет местами первые две буквы в каждом слове, состоящем из двух или более букв.
# ---------------------------------------------------------------------------
# import re

str1 = input()

result = re.sub(r"\b(\w)(\w)(\w*)\b", r"\2\1\3", rf"{str1}")
print(result)
# ---------------------------------------------------------------------------

# ===========================================================================


# Умножение строк
# 854
# Назовем умножением строки на число запись в формате n(string), где n — неотрицательное целое число, а string — строка, которая должна быть записана n раз. Раскрытием умножения будем считать развернутый вариант данной записи, например, строка ti2(Be)3(Ge) после раскрытия в ней всех умножений будет иметь вид tiBeBeGeGeGe.
# Напишите программу, которая раскрывает все умножения в тексте и выводит полученный результат.
# Формат входных данных
# На вход программе подается одна строка, содержащая строчные латинские буквы, числа и скобки.
# Формат выходных данных
# Программа должна вывести строку, в которой раскрыты все умножения с учетом приоритетности операций.
# Примечание 1. Гарантируется, что умножение в подаваемой строке всегда записано корректно, то есть строго в формате n(string). Записи вида 4(2), 3q, (fg)7 не корректны.
# Примечание 2. Рассмотрим третий тест. С учетом приоритетности операций сначала раскрываем умножение 2(a) и получаем промежуточную строку bbbb10(aa)bbb, далее раскрываем умножение 10(aa) и получаем конечный результат в виде строки bbbbaaaaaaaaaaaaaaaaaaaabbb.
# Примечание 3. Строка, в которой раскрыты все умножения, всегда содержит исключительно строчные латинские буквы.
# Примечание 4. Максимальная длина результирующей строки не превосходит 450000450000 символов.
# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------

# ===========================================================================

# import re
# from typing import Match
# аннотировать аргумент Match-объект  функции

def func(pattern: str, s: str) -> re.Match:
    return re.search(pattern, s)


def func2(pattern: str, s: str) -> Match:
    return re.search(pattern, s)
# ---------------------------------------------------------------------------


# Точка с запятой
# 881
# Напишите программу, которая разбивает строку по символам точки, запятой и точки с запятой.
# Формат входных данных
# На вход программе подается строка, содержащая различные значения, разделенные символами точки ., запятой , или точки с запятой ;, вокруг которых могут располагаться пробелы.
# Формат выходных данных
# Программа должна разбить введенную строку по символам точки, запятой и точки с запятой, захватывая вокруг стоящие пробелы, и вывести все значения, полученные при разбиении, через пробел.
# ---------------------------------------------------------------------------

# import re

text = input()
result = re.split(r"\s*[.,;]\s*", text)

print(*result)
# ---------------------------------------------------------------------------
# import re

print(*re.split(r' *[,;.] *', input()))
# ===========================================================================


# Логическое выражение
# 909
# Дано логическое выражение, состоящее из переменных, а также операторов |, &, and или or. Напишите программу, которая разбивает данную строку по указанным операторам.
# Формат входных данных
# На вход программе подается строка, содержащая логическое выражение, которое состоит из переменных и операторов |, &, and или or, между которыми могут располагаться пробелы.
# Формат  выходных данных
# Программа должна разбить введенную строку по указанным логическим операторам, захватывая вокруг стоящие пробелы, и вывести все значения, полученные при разбиении, через запятую и пробел.
#---------------------------------------------------------------------------
# import re

result = re.split(r"\s*\&\s*|\s*\|\s*|\s*and\s*|\s*or\s*", input())
print(*result, sep=', ')
# ---------------------------------------------------------------------------
# import re


print(*re.split(r'\s*(?:[|&]|and|or)\s*', input()), sep=', ')
# ===========================================================================


# Функция multiple_split()
# 850
# Реализуйте функцию multiple_split(), которая принимает два аргумента:
#     string — строка
#     delimiters — список строк
# Функция должна разбивать строку string на подстроки, используя в качестве разделителей строки из списка delimiters, и возвращать полученный результат в виде списка.
# Примечание 1. Другими словами, функция multiple_split() должна работать аналогично строковому методу split(), за тем исключением, что delimiters может содержать не единственный разделитель, а целый набор разделителей.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию multiple_split(), но не код, вызывающий ее.
# ---------------------------------------------------------------------------

import re

def multiple_split(string, delimiters) -> list:
    '''Функция должна разбивать строку string на подстроки, используя в качестве разделителей строки из списка delimiters, и возвращать полученный результат в виде списка.'''
    
    delimiters1 = (re.escape(f'{i}') for i in delimiters)
    regex = rf"{'|'.join(delimiters1)}"
    
    result = re.split(regex, string)

    return result
# ---------------------------------------------------------------------------

# ===========================================================================


#
#           ООП
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


# Класс Circle
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================


#
#
#
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------

# ===========================================================================
