
# ████─████─████
# █──█─█──█─█──█
# █──█─█──█─█──█
# █──█─█──█─█──█
# ████─████─█──█


# Класс Circle
#  977
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь три атрибута:
#     radius — радиус круга
#     diameter — диаметр круга
#     area — площадь круга
# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.
# Примечание 2. Импортировать константу ππ можно из модуля math:
# from math import pi
# ---------------------------------------------------------------

# import math


from typing import Self
import math
import copy


class Circle:
    def __init__(self, radius) -> None:
        self.radius = radius
        self.diameter = 2 * radius
        self.area = math.pi * radius**2


circle = Circle(5)

print(circle.radius)
print(circle.diameter)
print(circle.area)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#  Класс Bee
#
# Реализуйте класс Bee, описывающий пчелку, которая перемещается по координатной плоскости в четырех направлениях: вверх, вниз, влево и вправо. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата пчелки по оси xx, по умолчанию имеет значение 0
#     y — координата пчелки по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Bee должен иметь два атрибута:
#     x — координата пчелки по оси xx
#     y — координата пчелки по оси yy
# Класс Bee должен иметь четыре метода экземпляра:
#     move_up() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси yy на n
#     move_down() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси yy на n
#     move_right() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси xx на n
#     move_left() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси xx на n
# ---------------------------------------------------------------
class Bee:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def move_up(self, n):
        self.y += n

    def move_down(self, n):
        self.y -= n

    def move_right(self, n):
        self.x += n

    def move_left(self, n):
        self.x -= n


bee = Bee()

bee.move_right(2)
bee.move_right(2)
bee.move_up(3)
bee.move_left(1)
bee.move_down(1)

print(bee.x, bee.y)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Gun
# 979
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь один метод экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.pif = 'pif'
        self.paf = 'paf'
        self.cnt = 0

    def shoot(self):
        if self.cnt % 2 == 0:
            print(self.pif)
        else:
            print(self.paf)
        self.cnt += 1


gun = Gun()

gun.shoot()
gun.shoot()
gun.shoot()
gun.shoot()

# ---------------------------------------------------------------


class Gun:
    def __init__(self):
        self.shoots = 0

    def shoot(self):
        self.shoots += 1
        print(('paf', 'pif')[self.shoots % 2])
# ---------------------------------------------------------------

# from itertools import cycle


# class Gun:
#     def __init__(self):
#         self.sounds = cycle(('pif', 'paf'))

#     def shoot(self):
#         print(next(self.sounds))


# Класс Gun2
# 973
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь три метода экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
#     shots_count() — метод, возвращающий актуальное количество вызовов метода shoot()
#     shots_reset() — метод, сбрасывающий количество вызовов метода shoot() до нуля
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.cnt_call_method_shoot = 0

    def shoot(self):
        self.cnt_call_method_shoot += 1
        # print(('paf', 'pif')[self.cnt_call_method_shoot % 2])
        print('pif' if self.cnt_call_method_shoot % 2 else 'paf')

    def shots_count(self):
        return self.cnt_call_method_shoot

    def shots_reset(self):
        self.cnt_call_method_shoot = 0
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Scales
# 970
# Реализуйте класс Scales, описывающий весы с двумя чашами. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Scales должен иметь три метода экземпляра:
#     add_right() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на правую чашу весов этот груз
#     add_left() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на левую чашу весов этот груз
#     get_result() — метод, возвращающий строку Весы в равновесии, если массы грузов на чашах совпадают, Правая чаша тяжелее — если правая чаша тяжелее, Левая чаша тяжелее — если левая чаша тяжелее
# Примечание 1. Пустые весы всегда находятся в равновесии.
# ---------------------------------------------------------------
class Scales:
    def __init__(self) -> None:
        self.cap_right = 0
        self.cap_left = 0

    def add_right(self, cargo_mass_right):
        self.cap_right += cargo_mass_right

    def add_left(self, cargo_mass_left):
        self.cap_left += cargo_mass_left

    def get_result(self):
        if self.cap_left == self.cap_right:
            message = 'Весы в равновесии'
        elif self.cap_left < self.cap_right:
            message = 'Правая чаша тяжелее'
        elif self.cap_left > self.cap_right:
            message = 'Левая чаша тяжелее'

        return message
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 964
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx, по умолчанию имеет значение 0
#     y — координата вектора по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Vector должен иметь два атрибута:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Класс Vector должен иметь один метод экземпляра:
#     abs() — метод, возвращающий модуль вектора
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def abs(self):
        return (self.x**2 + self.y**2)**0.5
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# Класс Numbers
# 963
# Реализуйте класс Numbers, описывающий изначально пустой расширяемый набор целых чисел. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Numbers должен иметь три метода экземпляра:
#     add_number() — метод, принимающий в качестве аргумента целое число и добавляющий его в набор
#     get_even() — метод, возвращающий список всех четных чисел из набора
#     get_odd() — метод, возвращающий список всех нечетных чисел из набора
# Примечание 1. Числа в списках, возвращаемых методами get_even() и get_odd(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------


class Numbers:
    def __init__(self) -> None:
        self.lst = []

    def add_number(self, num):
        self.lst.append(num)

    def get_even(self):
        return list(filter(lambda x: x % 2, self.lst))

    def get_odd(self):
        return list(filter(lambda x: not x % 2, self.lst))


numbers = Numbers()

numbers.add_number(1)
numbers.add_number(3)
numbers.add_number(1)

print(numbers.get_even())
print(numbers.get_odd())
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс TextHandler
# 944
# Будем называть словом любую последовательность из одной или более букв. Текстом будем считать набор слов, разделенных пробельными символами.
# Реализуйте класс TextHandler, описывающий изначально пустой расширяемый набор слов. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса TextHandler должен иметь три метода:
#     add_words() — метод, принимающий в качестве аргумента текст и добавляющий слова из данного текста в набор
#     get_shortest_words() — метод, возвращающий актуальный список самых коротких слов в наборе
#     get_longest_words() — метод, возвращающий актуальный список самых длинных слов в наборе
# Примечание 1. Слова в списках, возвращаемых методами get_shortest_words() и get_longest_words(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------
class TextHandler:
    def __init__(self) -> None:
        self.words = []

    def add_words(self, text):
        for word in text.split():
            self.words.append(word)

    def get_shortest_words(self):
        short = min(self.words, key=len, default=None)

        if short:
            return list(filter(lambda x: len(x) == len(short), self.words))
        return []

    def get_longest_words(self):
        long = max(self.words, key=len, default=None)

        if long:
            return list(filter(lambda x: len(x) == len(long), self.words))
        return []
# -------------------ПРЕПОД--------------------------------------


class TextHandler:
    def __init__(self):
        self.words = []
        self.shortest = 0
        self.longest = 0

    def add_words(self, words):
        words = words.split()
        self.words.extend(words)
        self.shortest = min(map(len, self.words))
        self.longest = max(map(len, self.words))

    def get_shortest_words(self):
        return [w for w in self.words if len(w) == self.shortest]

    def get_longest_words(self):
        return [w for w in self.words if len(w) == self.longest]
# ---------------------------------------------------------------


# Класс Todo
# 941
# Реализуйте класс Todo, описывающий список дел. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Todo должен иметь один атрибут:
#     things — изначально пустой список дел, которые нужно выполнить
# Класс Todo должен иметь четыре метода экземпляра:
#     add() — метод, принимающий название дела и его приоритет (целое число) и добавляющий данное дело в список дел в виде кортежа:
#     (<название дела>, <приоритет>)
#     get_by_priority() — метод, принимающий в качестве аргумента целое число n и возвращающий список названий дел, имеющих приоритет n
#     get_low_priority() — метод, возвращающий список названий дел, имеющих самый низкий приоритет
#     get_high_priority() — метод, возвращающий список названий дел, имеющих самый высокий приоритет
# Примечание 1. Названия дел в списках, возвращаемых методами get_by_priority(), get_low_priority() и get_high_priority(), должны располагаться в том порядке, в котором они были добавлены в список.
# ---------------------------------------------------------------
class Todo:
    def __init__(self) -> None:
        self.things = []
        self.priority_lst = []

    def add(self, case_name, priority):
        self.things.append((case_name, priority))
        self.priority_lst.append(priority)

    def get_by_priority(self, n):
        self.priority_lst.append(n)
        return [w[0] for w in self.things if w[1] == n]

    def get_low_priority(self):
        low_low_priority = min(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == low_low_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)

    def get_high_priority(self):
        high_priority = max(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == high_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)


todo = Todo()

todo.add('Ответить на вопросы', 5)
todo.add('Сделать картинки', 1)
todo.add('Доделать задачи', 4)
todo.add('Дописать конспект', 5)

print(todo.get_low_priority())
print(todo.get_high_priority())
print(todo.get_by_priority(3))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Postman
# 910
# Реализуйте класс Postman, описывающий почтальона. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Postman должен иметь один атрибут:
#     delivery_data — изначально пустой список адресов, по которым следует доставить письма
# Экземпляр класса Postman должен иметь три метода экземпляра:
#     add_delivery() — метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:
#     (<улица>, <дом>, <квартира>)
#     get_houses_for_street() — метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма
#     get_flats_for_house() — метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма
# Примечание 1. Дома и квартиры в списках, возвращаемых методами get_houses_for_street() и get_flats_for_house(), должны располагаться в том порядке, в котором они были добавлены.
# ---------------------------------------------------------------

class Postman:
    def __init__(self) -> None:
        # '''изначально пустой список адресов, по которым следует доставить письма'''
        self.delivery_data = []

    def add_delivery(self, street, house, flat):
        '''метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:  '''
        self.delivery_data.append((street, house, flat))

    def get_houses_for_street(self, street):
        '''метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма'''
        gen1 = (i[1] for i in self.delivery_data if i[0] == street)
        # удаляет дубликат списка
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)
        # sorted(set(x), key=lambda d: x.index(d))
        # функцию drop_duplicates из пандаса
        # збавиться от дубликатов, сохранив порядок можно через словарь
        return l1

    def get_flats_for_house(self, street, house):
        '''метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма'''
        gen1 = (i[2] for i in self.delivery_data if i[0]
                == street and i[1] == house)
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)

        return l1
# ---------------------препод--через словарь---------------------------------


class Postman:
    def __init__(self):
        self.delivery_data = []

    def add_delivery(self, street, house, apartment):
        self.delivery_data.append((street, house, apartment))

    def get_houses_for_street(self, street):
        return list({h: None for s, h, _ in self.delivery_data if s == street})

    def get_flats_for_house(self, street, house):
        return list({a: None for s, h, a in self.delivery_data if s == street and h == house})
# ---------------------------------------------------------------


#  Класс Wordplay
# 850
# Будем называть словом любую последовательность из одной или более латинских букв.
# Реализуйте класс Wordplay, описывающий расширяемый набор слов. При создании экземпляра класс должен принимать один аргумент:
#     words — список, определяющий начальный набор слов. Если не передан, начальный набор слов считается пустым
# Экземпляр класса Wordplay должен иметь один атрибут:
#     words — список, содержащий набор слов
# Класс Wordplay должен иметь четыре метода экземпляра:
#     add_word() — метод, принимающий в качестве аргумента слово и добавляющий его в набор. Если слово уже есть в наборе, метод ничего не должен делать
#     words_with_length() — метод, принимающий в качестве аргумента натуральное число n и возвращающий список слов из набора, длина которых равна n
#     only() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из набора, которые включают в себя только переданные буквы
#     avoid() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из списка words, которые не содержат ни одну из этих букв
# Примечание 1. Слова в списках, возвращаемых методами words_with_length(), only() и avoid(), должны располагаться в том порядке, в котором они были добавлены.
# Примечание 2. Экземпляр класса Wordplay не должен зависеть от списка, на основе которого он был создан. Другими словами, если исходный список изменится, то экземпляр класса Wordplay измениться не должен.
# ---------------------------------------------------------------


class Wordplay:
    def __init__(self, words=None) -> None:
        if words is None:
            words = []
        words2 = copy.copy(words)
        self.words = words2

    def add_word(self, new_word):
        if new_word not in self.words:
            self.words.append(new_word)

    def words_with_length(self, n):
        return [word for word in self.words if len(word) == n]

    def only(self, *args):
        return [word for word in self.words if set(args) >= set(word)]

    def avoid(self, *args):
        return [word for word in self.words if set(args).isdisjoint(set(word))]


words = ['Лейбниц', 'Бэббидж', 'Нейман', 'Джобс', 'да_Винчи', 'Касперский']
wordplay = Wordplay(words)

words.extend(['Гуев', 'Харисов', 'Светкин'])
print(words)
print(wordplay.words)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Knight ♞
#
# Реализуйте класс Knight, описывающий шахматного коня. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     horizontal — координата коня по горизонтальной оси, представленная латинской буквой от a до h
#     vertical — координата коня по вертикальной оси, представленная целым числом от 1 до 8 включительно
#     color — цвет коня (black или white)
# Экземпляр класса Knight должен иметь три атрибута:
#     horizontal — координата коня на шахматной доске по горизонтальной оси
#     vertical — координата коня на шахматной доске по вертикальной оси
#     color — цвет коня
# Класс Knight должен иметь четыре метода экземпляра:
#     get_char() — метод, возвращающий символ N
#     can_move() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и возвращающий True, если конь может переместиться на клетку с данными координатами, или False в противном случае
#     move_to() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и заменяющий текущие координаты коня на переданные. Если конь из текущей клетки не может переместиться на клетку с указанными координатами, его координаты должны остаться неизменными
#     draw_board() — метод, печатающий шахматное поле, отмечающий на этом поле коня и клетки, на которые может переместиться конь. Пустые клетки должны быть отображены символом ., конь — символом N, клетки, на которые может переместиться конь, — символом *
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Circle
#
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:

#     radius — радиус круга

# Экземпляр класса Circle должен иметь три атрибута:

#     _radius — радиус круга
#     _diameter — диаметр круга
#     _area — площадь круга

# Класс Circle должен иметь три метода экземпляра:

#     get_radius() — метод, возвращающий радиус круга
#     get_diameter() — метод, возвращающий диаметр круга
#     get_area() — метод, возвращающий площадь круга

# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.

# Примечание 2. Импортировать константу ππ можно из модуля math:

# ---------------------------------------------------------------


class Circle:
    def __init__(self, radius: int) -> None:
        self._radius = radius
        self._diameter = 2 * radius
        self._area = math.pi * radius**2

    def get_radius(self) -> int:
        '''метод, возвращающий радиус круга'''
        return self._radius

    def get_diameter(self) -> int:
        '''метод, возвращающий диаметр круга'''
        return self._diameter

    def get_area(self) -> int:
        '''метод, возвращающий площадь круга'''
        return self._area
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BankAccount
# 949
# Реализуйте класс BankAccount, описывающий банковский счет. При создании экземпляра класс должен принимать один аргумент:
#     balance — баланс счета, по умолчанию имеет значение 0
# Экземпляр класса BankAccount должен иметь один атрибут:
#     _balance — баланс счета
# Класс BankAccount должен иметь четыре метода экземпляра:
#     get_balance() — метод, возвращающий актуальный баланс счета
#     deposit() — метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount
#     withdraw() — метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
#     transfer() — метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

# from typing import Self

# class BankAccount:
#     def __init__(self, balance=0: int | float) -> None:
#         self._balance = balance

#     def get_balance(self) -> int | float:
#         '''метод, возвращающий актуальный баланс счета'''
#         return self._balance

#     def deposit(self, amount: int | float):
#         '''метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount'''
#         self._balance += amount

#     def withdraw(self, amount: int | float):
#         '''метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением: На счете недостаточно средств'''
#         if self._balance > amount:
#             self._balance -= amount
#         else:
#             print('На счете недостаточно средств')
#             raise ValueError

#     # def transfer(self: Self, account: Self, amount: int) -> None:
#     def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
#         '''метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: '''
#         self.withdraw(amount)        
#         self.account = account
#         self.account.deposit(amount)       
  


# account1 = BankAccount(100)
# account2 = BankAccount(200)

# account1.transfer(account2, 50)
# print(account1.get_balance())
# print(account2.get_balance())
# ---------------------------------------------------------------
    # def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
    #     '''метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: '''
    #     self.withdraw(amount)        
    #     self.account = account
    #     self.account.deposit(amount)    
# ---------------------------------------------------------------


# Класс User
# 937
# Реализуйте класс User, описывающий интернет-пользователя. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя пользователя. Если name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     age — возраст пользователя. Если age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Экземпляр класса User должен иметь два атрибута:
#     _name — имя пользователя
#     _age — возраст пользователя
# Класс User должен иметь четыре метода экземпляра:
#     get_name() — метод, возвращающий имя пользователя
#     set_name() — метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     get_age() — метод, возвращающий возраст пользователя
#     set_age() — метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Примечание 1. Если при создании экземпляра класса User имя и возраст одновременно являются некорректными, должно быть возбуждено исключение, связанное с именем.
# ---------------------------------------------------------------
class User:
    def __init__(self, name: str, age: int) -> None:        
        
        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже. 
        self.set_name(name)
        self.set_age(age)
        
        self._name = name
        self._age = age


    def get_name(self):
        '''метод, возвращающий имя пользователя'''
        return self._name

    def get_age(self):
        '''метод, возвращающий возраст пользователя'''
        return self._age



    # Сеттер1
    def set_name(self, new_name: str):
        '''метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом: '''
        if isinstance(new_name, str) and new_name.isalpha():
            self._name = new_name
        else:
            raise ValueError('Некорректное имя')
    

    # Сеттер2
    def set_age(self, new_age: int): 
        '''метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом: '''
        if isinstance(new_age, int) and 0 <=new_age <=110:
            self._age = new_age
        else:            
            raise ValueError('Некорректный возраст')
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 949
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь два свойства:
#     perimeter — свойство, доступное только для чтения, возвращающее периметр прямоугольника
#     area — свойство, доступное только для чтения, возвращающее площадь прямоугольника
# Примечание 1. При изменении сторон прямоугольника должны изменяться его периметр и площадь.
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length, width):
        self._length = length
        self._width = width

    # --------------------------------------------------------
    def get_length(self):
        '''геттер - возвращает значение длины'''
        return self._length

    def set_length(self, length):
        '''сеттер - меняет значение длины'''
        self._length = length

    # --------------------------------------------------------
    def get_width(self):
        '''геттер -  возвращает значение ширины'''
        return self._width

    def set_width(self, width):
        '''сеттер - меняет значение ширины'''
        self._width = width

    # --------------------------------------------------------
    def get_perimeter(self):
        '''геттер - возвращает значение периметра'''
        return 2 * (self._length + self._width)    

    # --------------------------------------------------------
    def get_area(self):
        '''геттер -  возвращает значение площади'''
        return self._length * self._width     
    # --------------------------------------------------------


    length = property(get_length, set_length)
    width = property(get_width, set_width)
    perimeter = property(get_perimeter)
    area = property(get_area)


rectangle = Rectangle(4, 5)

print(rectangle.length)
print(rectangle.width)
print(rectangle.perimeter)
print(rectangle.area)

# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def get_perimeter(self):
        return 2*(self.length + self.width)
        
    def get_area(self):
        return self.length * self.width
    
    perimeter = property(get_perimeter)
    area = property(get_area)
# ---------------------------------------------------------------


# Класс HourClock
# 958
# Реализуйте класс HourClock, описывающий часы с одной лишь часовой стрелкой. При создании экземпляра класс должен принимать один аргумент:
#     hours — количество часов. Если hours не является целым числом, принадлежащим диапазону [1; 12], должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Класс HourClock должен иметь одно свойство:
#     hours — свойство, доступное для чтения и записи, возвращающее текущее количество часов. При изменении свойство должно проверять, что новое значение является целым числом, принадлежащим диапазону [1; 12], в противном случае должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Примечание 1. Никаких ограничений касательно реализации класса HourClock нет, она может быть произвольной.
# ---------------------------------------------------------------
class HourClock:
    def __init__(self, hours: int) -> None:
        
        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже. 
        self.set_hours(hours)

        

    def get_hours(self) -> int:
        '''геттер возвращает текущее количество часов'''
        
        return self._hours



    def set_hours(self, hours: int) -> None:
        '''cеттер изменяет и проверяет на корректность новое количество часов'''
        
        if not (isinstance(hours, int) and 1 <= hours <= 12):
            raise ValueError('Некорректное время')
        self._hours = hours

   
 
    hours = property(get_hours, set_hours)


time = HourClock(7)

print(time.hours)
time.hours = 9
print(time.hours)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Person
# 962
# Реализуйте класс Person, описывающий человека. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person должен иметь два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person должен иметь одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self.set_person(name, surname)
        

    def get_name(self) -> str:
        '''геттер возвращает имя'''
        return self._name

    def get_surname(self) -> str:
        '''геттер возвращает фамилию'''
        return self._surname
    
    def set_name(self, name) -> None:
        '''сеттер изменяет имя'''
        self._name = name        
    
    def set_surname(self, surname: str) -> None:
        '''сеттер изменяет фамилию'''       
        self._surname = surname
    
    def get_person(self) -> str:
        '''возвращающее полное имя человека в виде строки'''
        return f"{self.get_name()} {self.get_surname()}"

    def set_person(self, *args: str) -> None:
        if len(args) == 1:
            l1 = args[0].split()
            self._name = l1[0]
            self._surname = l1[1]
        else:
            self._name, self._surname = args

    
    name = property(get_name, set_name)
    surname = property(get_surname, set_surname)  
    fullname = property(get_person, set_person)   



person = Person('Джон', 'Маккарти')

person.fullname = 'Алан Тьюринг'
print(person.name)
print(person.surname)

# -----------короче---------------------------------------
class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname
        
    def get_fullname(self):
        return self.name + ' ' + self.surname
    
    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()
        
    fullname = property(get_fullname, set_fullname)
# ---------------------------------------------------------------



#  Person
#
# Вам доступен класс Person, описывающий человека. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person имеет два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person имеет одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Реализуйте свойство fullname класса Person с помощью декоратора @property.
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self._name = name
        self._surname = surname

    @property
    def fullname(self):
        return "{} {}".format(self.name, self.surname)   

    @fullname.setter
    def fullname(self, fullname):
        self.name, self.surname = fullname.split()
        
# БЕЗ ДЕКОРАТОРА

class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def get_fullname(self):
        return self.name + ' ' + self.surname

    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()

    fullname = property(get_fullname, set_fullname)


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Account
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Account нет, она может быть произвольной.
# ---------------------------------------------------------------


class Account:
    def __init__(self, login, password) -> None:
        self._login = login
        self._password = hash_function(password)    
    

    # ---------------------------------------------------------------
    @property
    def login(self):        # свойство доступно только для чтения (сеттер выдаст ошибку при попытке изменить логин)
        return self._login

    @login.setter
    def login(self, login):       
        raise AttributeError('Изменение логина невозможно')
    # ---------------------------------------------------------------

    @property
    def password(self):        # свойство доступно для чтения и записи
        return self._password

    @password.setter
    def password(self, password):        
        self._password = hash_function(password)
        
        
def hash_function(password):
    '''ф-я принимает в качестве аргумента пароль и возвращает его хеш-значение.'''
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10**9






account = Account('timyr-guev', 'lovebeegeek')

print(account.password)
account.password = 'verylovebeegeek'
print(account.password)

# ------------------препод-------------------------------------
def hash_function(password):
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10 ** 9


class Account:
    def __init__(self, login, password):
        self._login = login
        self.password = password

    @property
    def login(self):
        return self._login

    @login.setter
    def login(self, login):
        raise AttributeError('Изменение логина невозможно')
            
    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, password):
        self._password = hash_function(password)
# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------


# from typing import Tuple

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @property
    def x1(self) -> float | None:
        ''' свойство, доступное только для чтения, возвращающее корень1 квадратного трехчлена,'''
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b - descriminant**0.5) / (2 * self.a)

    @property
    def x2(self) -> float | None:
        ''' свойство, доступное только для чтения, возвращающее корень2 квадратного трехчлена'''
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b + descriminant**0.5) / (2 * self.a)
        

    @property
    def view(self) -> str:
        ''' свойство, доступное только для чтения, возвращающее строку вида ax^2 + bx + c'''
        signs = ''
        for i in self.coefficients:
            if i >= 0:
                signs += '+'
            else:
                signs += '-'             
        signs = signs[1:]        
        
        res = '{a}x^2 {} {b}x {} {c}'.format(*signs, a=self.a, b=abs(self.b), c=abs(self.c))        
        return res
    
    @property
    def coefficients(self) -> Tuple[int | float]:
        '''геттер, доступ для чтения, возвращающее кортеж вида: (a, b, c)'''      
        return (self.a, self.b, self.c)

    @coefficients.setter
    def coefficients(self, coefficients1) -> Tuple[int | float]:
        '''сеттер изменяющий коэффициенты'''
        self.a, self.b, self.c = coefficients1


polynom = QuadraticPolynomial(1, 2, -3)

polynom.coefficients = (1, -5, 6)
print(polynom.x1)
print(polynom.x2)
print(polynom.view)
# -----------------препод---------------------------------------
class QuadraticPolynomial:
    def __init__(self, a, b, c):
        self.a, self.b, self.c = a, b, c

    @property
    def d(self):
        return self.b ** 2 - 4 * self.a * self.c

    @property
    def x1(self):
        # короткая запись if else
        return (-self.b - self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def x2(self):
        return (-self.b + self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def view(self):
        b, sign_b = abs(self.b), '-' if self.b < 0 else '+'
        c, sign_c = abs(self.c), '-' if self.c < 0 else '+'
        return f'{self.a}x^2 {sign_b} {b}x {sign_c} {c}'

    @property
    def coefficients(self):
        return self.a, self.b, self.c

    @coefficients.setter
    def coefficients(self, coeff):
        a, b, c = coeff
        self.a, self.b, self.c = a, b, c
# ---------------------------------------------------------------


# Класс Color
# 873
# Для кодирования цвета часто используется шестнадцатеричное значение цвета. Оно записывается в формате #RRGGBB, где RR (красный), GG (зеленый) и BB (синий) являются шестнадцатеричными целыми числами в диапазоне [00; FF] (или [0; 255] в десятичной системе счисления), которые указывают интенсивность соответствующих цветов. Например, #0000FF представляет чистый синий цвет, так как синий компонент имеет наивысшее значение (FF), а остальные — 00.
# Реализуйте класс Color, описывающий цвет. При создании экземпляра класс должен принимать один аргумент:
#     hexcode — шестнадцатеричное значение цвета 
# Экземпляр класса Color должен иметь три атрибута:
#     r — интенсивность красного компонента цвета в виде десятичного числа
#     g — интенсивность зеленого компонента цвета в виде десятичного числа
#     b — интенсивность синего компонента цвета в виде десятичного числа
# Класс Color должен иметь одно свойство:
#     hexcode — свойство, доступное для чтения и записи, возвращающее шестнадцатеричное значение цвета
# Примечание 1. При изменении шестнадцатеричного значения цвета значения атрибутов r, g и b также должны изменяться.
# Примечание 2. Гарантируется, что для записи шестнадцатеричных чисел используются только заглавные латинские буквы.
# ---------------------------------------------------------------


class Color:
    def __init__(self, hexcode: str) -> None:
        self._hexcode = hexcode            
        self.r = hex_to_ten(self._hexcode[:2])
        self.g = hex_to_ten(self._hexcode[2:4])
        self.b = hex_to_ten(self._hexcode[4:])
    
    # ---------------------------------------------------------------
    @property
    def hexcode(self) -> str:
        '''геттер, возвращает шестнадцатеричное значение цвета'''
        return self._hexcode

    @hexcode.setter
    def hexcode(self, hexcode: str) -> None:
        '''сеттер, для изменения цвета'''        
        self._hexcode = hexcode
        self.r = hex_to_ten(hexcode[:2])
        self.g = hex_to_ten(hexcode[2:4])
        self.b = hex_to_ten(hexcode[4:])
    # ---------------------------------------------------------------
    
    
    
# оказывается :) функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое    
def hex_to_ten(hex_num: str) -> int:
    '''ф-я принимает шестнадцатеричное значение цвета и возвращает цвет в виде десятичного числа'''
    dict_hex = {'0': 0, 
                '1': 1, 
                '2': 2, 
                '3': 3,
                '4': 4, 
                '5': 5, 
                '6': 6, 
                '7': 7, 
                '8': 8, 
                '9': 9,
                "A": 10, 
                "B": 11, 
                "C": 12, 
                "D": 13, 
                "E": 14, 
                "F": 15}
        
    return sum((dict_hex[num_hex]) * 16**pow_index  for pow_index, num_hex in enumerate(reversed(hex_num)))



color = Color('0000FF')

color.hexcode = 'A782E3'
print(color.hexcode)
print(color.r)
print(color.g)
print(color.b)
# -----------------препод--------------------------------------
class Color:
    def __init__(self, hexcode):
        self.hexcode = hexcode
    
    @property
    def hexcode(self):
        return self._hexcode
    
    @hexcode.setter
    def hexcode(self, hexcode):
        self._hexcode = hexcode

        # функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое 
        self.r = int(hexcode[0:2], 16)
        self.g = int(hexcode[2:4], 16)
        self.b = int(hexcode[4:6], 16)
# ---------------------------------------------------------------


# Класс Circle
# 950
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь один атрибут:
#     radius — радиус круга
# Класс Circle должен иметь один метод класса:
#     from_diameter() — метод, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра
# ---------------------------------------------------------------
class Circle:
    def __init__(self, radius: int | float) -> None:
        self.radius = radius

    @classmethod
    def from_diameter(cls, diametr: int | float) -> int | float:
        '''метод класса, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра'''

        return  cls(diametr / 2)


circle = Circle.from_diameter(10)
print(circle.radius)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 965
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь один метод класса:
#     square() — метод, принимающий в качестве аргумента число side и возвращающий экземпляр класса Rectangle c длиной и шириной, равными side
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length: int | float, width: int | float) -> None:
        self.length = length
        self.width = width

    @classmethod
    def square(cls, side: int | float) -> 'Rectangle':
        ''' метод класса, принимающий в качестве аргумента число side и возвращающий экземпляр класса '''
        return cls(side, side)


rectangle = Rectangle.square(5)

print(rectangle.length)
print(rectangle.width)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 916
# вадратный трехчлен — это многочлен вида ax2+bx+cax2+bx+c, где a≠0a=0. Например:
# x2+1x2−5x+6Реализуйте класс QuadraticPolynomial, описывающий квадратный трехчлен. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Экземпляр класса QuadraticPolynomial должен иметь три атрибута:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Класс QuadraticPolynomial должен иметь два метода класса:
#     from_iterable() — метод, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов
#     from_str() — метод, принимающий в качестве аргумента строку, которая содержит коэффициенты a, b и c квадратного трехчлена, записанные через пробел. Метод должен возвращать экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов, предварительно преобразованных в экземпляры класса float 
# ---------------------------------------------------------------

# from typing import TypeVar

# TMyClass = TypeVar("TMyClass", bound="MyClass")

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @classmethod
    def from_iterable(cls, iterable) -> 'QuadraticPolynomial':
        '''метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов'''
        return cls(*iterable)

    @classmethod
    def from_str(cls, string) -> 'QuadraticPolynomial':
        '''метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов'''
        iterable = map(float, string.split())
        return cls(iterable)
# ---------------------------------------------------------------


# Класс Pet
# 926
# Реализуйте класс Pet, описывающий домашнее животное. При создании экземпляра класс должен принимать один аргумент:
#     name — имя домашнего животного
# Экземпляр класса Pet должен иметь один атрибут:
#     name — имя домашнего животного
# Класс Pet должен иметь три метода класса:
#     first_pet() — метод, возвращающий самый первый созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     last_pet() — метод, возвращающий самый последний созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     num_of_pets() — метод, возвращающий количество созданных экземпляров класса Pet
# ---------------------------------------------------------------
class Pet:

    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)   # передаём весь экземпляр
        
      
    @classmethod
    def first_pet(cls): # в методах класса нужно брать его из списка
        if cls.pets:
            return cls.pets[0]    

    @classmethod
    def last_pet(cls):
        if cls.pets:
            return cls.pets[-1]   

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)
        
# ----------------------------------------
class Pet:
    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)

    @classmethod
    def first_pet(cls):
        return cls.pets[0] if cls.pets else None

    @classmethod
    def last_pet(cls):
        return cls.pets[-1] if cls.pets else None

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)
# ---------------------------------------------------------------


# Класс StrExtension
#
# Реализуйте класс StrExtension, описывающий набор функций для работы со строками. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс StrExtension должен иметь три статических метода:
#     remove_vowels() — метод, который принимает в качестве аргумента строку, удаляет из нее все гласные латинские буквы без учета регистра и возвращает полученный результат
#     leave_alpha() — метод, который принимает в качестве аргумента строку, удаляет из нее все символы, не являющиеся латинскими буквами, и возвращает полученный результат
#     replace_all() — метод, который принимает три строковых аргумента string, chars и char, заменяет в строке string все символы из chars на char с учетом регистра и возвращает полученный результат.
# Примечание 1. Гарантируется, что все буквенные символы относятся к латинскому алфавиту.
# Примечание 2. Латинские гласные буквы: a, e, i, o, u, y.
# ---------------------------------------------------------------
import string

class StrExtension:

    @staticmethod
    def remove_vowels(string1):
        vowels = ('a', 'e', 'i', 'o', 'u', 'y')
        str_off_vowels = (char for char in string1 if char.lower() not in vowels) 
        return ''.join(str_off_vowels)


    @staticmethod
    def leave_alpha(string1):
        symbols = (char for char in string1 if char.lower() not in string.ascii_lowercase)    
        return ''.join(symbols)


    @staticmethod
    def replace_all(string1: str, chars, char):
        
        for char_old in chars:
            string1 = string1.replace(char_old, char)
        
        return string1
     
# -----------------c регулярками-------------------------------
import re


class StrExtension:
    __VOWELS = re.compile(r'[aeiouy]', flags=re.I)
    __ALPHABET = re.compile(r'[^a-zA-Z]')

    @staticmethod
    def remove_vowels(string):
        return StrExtension.__VOWELS.sub('', string)

    @staticmethod
    def leave_alpha(string):
        return StrExtension.__ALPHABET.sub('', string)

    @staticmethod
    def replace_all(string, chars, char):
        return re.sub(fr'[{chars}]', char, string)
# ---------------------------------------------------------------


# Класс CaseHelper 🌶️
# 783
# Snake Case — стиль написания составных слов, при котором несколько слов разделяются символом нижнего подчеркивания (_) и не имеют пробелов в записи, причём каждое слово пишется с маленькой буквы. Например, bee_geek и hello_world.
# Upper Camel Case — стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с заглавной буквы. Например, BeeGeek и HelloWorld.
# Реализуйте класс CaseHelper, описывающий набор функций для работы со строками в стилях Snake Case и Upper Camel Case. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс CaseHelper должен иметь четыре статических метода:
#     is_snake() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Snake Case, или False в противном случае
#     is_upper_camel() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Upper Camel Case, или False в противном случае
#     to_snake() — метод, который принимает в качестве аргумента строку в стиле Upper Camel Case, записывает ее в стиле Snake Case и возвращает полученный результат
#     to_upper_camel() — метод, который принимает в качестве аргумента строку в стиле Snake Case, записывает ее в стиле Upper Camel Case и возвращает полученный результат
# ---------------------------------------------------------------

# class CaseHelper:


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Processor
# 937
# Вам доступен класс Processor. При создании экземпляра класс не принимает никаких аргументов.
# Класс Processor имеет один статический метод:
#     process() — метод, который принимает в качестве аргумента произвольный объект, преобразует его в зависимости от его типа и возвращает полученный результат. Если тип переданного объекта не поддерживается методом, возбуждается исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Перепишите метод process() класса Processor с использованием декоратора @singledispatchmethod, чтобы он выполнял ту же задачу.
# Примечание 1. Примеры преобразования объектов всех поддерживаемых типов показаны в методе process() класса Processor.
# # ---------------------------------------------------------------
# class Processor:
#     @staticmethod
#     def process(data):
#         if isinstance(data, (int, float)):
#             return data * 2
#         elif isinstance(data, str):
#             return data.upper()
#         elif isinstance(data, list):
#             return sorted(data)
#         elif isinstance(data, tuple):
#             return tuple(sorted(data))
#         raise TypeError('Аргумент переданного типа не поддерживается')
# ---------------------------------------------------------------

from functools import singledispatchmethod

class Processor:    
    @singledispatchmethod
    @staticmethod
    def process(data):     
        raise TypeError('Аргумент переданного типа не поддерживается')
        

    @process.register(tuple)
    @staticmethod
    def _tuple_process(data):
        return  tuple(sorted(data))

    @process.register(list)
    @staticmethod
    def _list_process(data):
        return sorted(data)

    @process.register(str)
    @staticmethod
    def _str_process(data):
        return data.upper()

    
    @process.register(int)
    @process.register(float) # @process.register(int | float)    # В Python 3.11 можно так
    @staticmethod
    def _numeric_process(data):
        return data * 2 
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Negator
# 953
# Реализуйте класс Negator. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Negator должен иметь один статический метод:
#     neg() — метод, принимающий в качестве аргумента объект и возвращающий его противоположное значение. Если методу передается целое или вещественное число, он должен возвращать это число, взятое с противоположным знаком. Если методу в качестве аргумента передается булево значение, он должен возвращать булево значение, противоположное переданному. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

from functools import singledispatchmethod

class Negator:
    @singledispatchmethod
    @staticmethod
    def neg(object):
        raise TypeError('Аргумент переданного типа не поддерживается')


    @neg.register(int)
    @neg.register(float)
    @staticmethod
    def _str_neg(object):
        return object * (-1)

    @neg.register(bool)
    @staticmethod
    def _str_neg(object):
        return not object        
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Formatter
# 917
# Реализуйте класс Formatter. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Formatter должен иметь один статический метод:
#     format() — метод, принимающий в качестве аргумента объект типа int, float, tuple, list или dict и выводящий информацию о переданном объекте в формате, зависящем от его типа. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Примеры форматирования объектов всех типов показаны в тестовых данных.
# Примечание 2. Обратите внимание, что метод format() должен обрамлять апострофами строковые элементы коллекций.
# ---------------------------------------------------------------

from functools import singledispatchmethod

class Formatter:
    
    @singledispatchmethod
    @staticmethod
    def format(arg):
        raise TypeError('Аргумент переданного типа не поддерживается')


    @format.register(int)
    def _(arg):
        print(f"Целое число: {arg}")

    @format.register(float)
    def _(arg):
        print(f"Вещественное число: {arg}")

    @format.register(tuple)
    def _(arg):        
        print("Элементы кортежа: ", end='')
        print(*arg, sep=', ' )

    @format.register(list)
    def _(arg):
        print("Элементы списка: ", end='')    # print(f'Элементы списка: {", ".join([str(obj) for obj in data])}')
        print(*arg, sep=', ' )
                
    @format.register(dict)
    def _(arg):
        print("Пары словаря: ", end='')     # print(f'Пары словаря: {", ".join([str(pair) for pair in data.items()])}')
        print(*arg.items(), sep=', ' )
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BirthInfo 🌶️
# 782
# Реализуйте класс BirthInfo, описывающий данные о дате рождения. При создании экземпляра класс должен принимать один аргумент:
#     birth_date — дата рождения, представленная в одном из следующих вариантов:
#     экземпляр класса date
#     строка с датой в ISO формате
#     список или кортеж из трех целых чисел: года, месяца и дня
# Если дата рождения является некорректной или представлена в каком-либо другом формате, должно быть возбуждено исключение TypeError с текстом:
# Аргумент переданного типа не поддерживается
# Экземпляр класса BirthInfo должен иметь один атрибут:
#     birth_date — дата рождения в виде экземпляра класса date
# Класс BirthInfo должен иметь одно свойство:
#     age — свойство, доступное только для чтения, возвращающее текущий возраст в годах, то есть количество полных лет, прошедших с даты рождения на сегодняшний день
# Примечание 1. Возраст в годах должен вычисляться так же, как и обычный возраст человека, то есть в день рождения его возраст увеличивается на один год.
# ---------------------------------------------------------------
from functools import singledispatchmethod
from datetime import date, timedelta
import re

class BirthInfo:

      
    @singledispatchmethod
    def __init__(self, birth_date) -> None:
        raise TypeError('Аргумент переданного типа не поддерживается')

    @__init__.register(date)
    def _(self, birth_date):
        self.birth_date = birth_date
        
    @__init__.register(str)
    def _(self, birth_date):
        # try:
        #     self.birth_date = date.fromisoformat(birth_date) 
        # except:
        #     raise TypeError('Аргумент переданного типа не поддерживается') 

        if not re.fullmatch(r'\d{4}-\d{2}-\d{2}', birth_date):
            raise TypeError('Аргумент переданного типа не поддерживается')
        self.birth_date = date.fromisoformat(birth_date)

    @__init__.register(list)
    @__init__.register(tuple)
    def _(self, birth_date):
        self.birth_date = date(*birth_date)
    
    
    
    @property
    def age(self):
        age = date.today().year - self.birth_date.year - 1
        age += (date.today().month, date.today().day) >= (self.birth_date.month, self.birth_date.day)
        return age
# ---------------------------------------------------------------

from dateutil.relativedelta import relativedelta

relativedelta(date1, date2).years
# ---------------------------------------------------------------


# Класс Config
#
# Реализуйте класс Config, который соответствует шаблону синглтон и описывает конфигурационный объект с фиксированными параметрами. При создании экземпляра класс не должен принимать никаких аргументов.
# При первом вызове класса Config должен создаваться и возвращаться экземпляр этого класса, а при последующих вызовах должен возвращаться экземпляр, созданный при первом вызове.
# Экземпляр класса Config должен иметь четыре атрибута:
#     program_name — атрибут со строковым значением GenerationPy
#     environment — атрибут со строковым значением release
#     loglevel — атрибут со строковым значением verbose
#     version — атрибут со строковым значением 1.0.0
# ---------------------------------------------------------------

class Config:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance                      

    def __init__(self) -> None:
        self.program_name = 'GenerationPy'
        self.environment = 'release'
        self.loglevel = 'verbose'
        self.version = '1.0.0'


config = Config()

print(config.program_name)
print(config.environment)
print(config.loglevel)
print(config.version)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Book
# 949
# Требовалось реализовать класс Book, описывающий книгу. При создании экземпляра класс должен был принимать три аргумента в следующем порядке:
#     title — название книги
#     author — автор книги
#     year — год выпуска книги
# Предполагалось, что экземпляры класса Book будут иметь следующее формальное строковое представление:
# Book('<название книги>', '<автор книги>', <год выпуска книги>)
# И следующее неформальное строковое представление:
# <название книги> (<автор книги>, <год выпуска книги>)
# Программист торопился и решил задачу неправильно. Исправьте приведенный ниже код и реализуйте класс Book правильно.
# ---------------------------------------------------------------

class Book:
    def __init__(self, title, author, year) -> None:
        self.title = title
        self.author = author
        self.year = year

    def __str__(self):
        return f'{self.title} ({self.author}, {self.year})'

    def __repr__(self) -> str:
        return f"Book('{self.title}', '{self.author}', {self.year})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 972
# Вам доступен класс Rectangle, описывающий прямоугольник. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Реализуйте для экземпляров класса Rectangle следующее формальное и неформальное строковое представление:
# Rectangle(<длина прямоугольника>, <ширина прямоугольника>)
# ---------------------------------------------------------------

class Rectangle:
    def __init__(self, length, width) -> None:
        self.length = length
        self.width = width

    def __repr__(self) -> str:
        return f"Rectangle({self.length}, {self.width})" 
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 966
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# И следующее неформальное строковое представление:
# Вектор на плоскости с координатами (<координата x>, <координата y>)
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x, y) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})" 

    def __str__(self) -> str:
        return f"Вектор на плоскости с координатами ({self.x}, {self.y})"     
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс IPAddress
# 950
# IP-адрес — это уникальный адрес, идентифицирующий устройство в интернете или локальной сети. IP-адреса представляют собой набор из четырех целых чисел, разделенных точками. Например, 192.158.1.38. Каждое число в наборе принадлежит интервалу от 0 до 255. Таким образом, полный диапазон IP-адресации — это адреса от 0.0.0.0 до 255.255.255.255.
# Реализуйте класс IPAddress, описывающий IP-адрес. При создании экземпляра класс должен принимать один аргумент:
#     ipaddress — IP-адрес, представленный в одном из следующих вариантов:
#     строка из четырех целых чисел, разделенных точками
#     список или кортеж из четырех целых чисел
# Экземпляр класса IPAddress должен иметь следующее формальное строковое представление:
# IPAddress('<IP-адрес в виде четырех целых чисел, разделенных точками>')
# И следующее неформальное строковое представление:
# <IP-адрес в виде четырех целых чисел, разделенных точками>
# ---------------------------------------------------------------

from functools import singledispatchmethod

class IPAddress:
    
    @singledispatchmethod
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ipaddress

    @__init__.register(tuple)
    @__init__.register(list)
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ''.join(ipaddress)


    def __repr__(self) -> str:
        return f"IPAddress('{self.ipaddress}')"
    
    
    def __str__(self) -> str:
        return f"{self.ipaddress}" 
   
# ----------------if else------------------------------------------
class IPAddress:
    def __init__(self, ipadress):
        if isinstance(ipadress, str):
            self.ipadress = ipadress
        elif isinstance(ipadress, (list, tuple)):
            self.ipadress = '.'.join(map(str, ipadress))
            
    def __str__(self):
        return self.ipadress
    
    def __repr__(self):
        return f"{self.__class__.__name__}('{self.ipadress}')"

# -------------------property-------------------------------------
class IPAddress:
    def __init__(self, ipaddress: str | tuple):
        self.ipaddress = ipaddress

    @property
    def ipaddress(self):
        return self._ipaddress

    @ipaddress.setter
    def ipaddress(self, data: str | tuple | list):
        self._ipaddress = data if isinstance(data, str) else '.'.join(map(str, data))

    def __str__(self):
        return self._ipaddress

    def __repr__(self):
        return f"{type(self).__name__}('{self._ipaddress}')"



# Класс PhoneNumber
# 932 
# ализуйте класс PhoneNumber, описывающий телефонный номер. При создании экземпляра класс должен принимать один аргумент:
#     phone_number — телефонный номер, представляющий строку из десяти цифр в одном из следующих форматов:
#     dddddddddd
#     ddd ddd dddd
# Экземпляр класса PhoneNumber должен иметь следующее формальное строковое представление:
# PhoneNumber('<телефонный номер в формате dddddddddd>')
# И следующее неформальное строковое представление:
# <телефонный номер в формате (ddd) ddd-dddd>
# ---------------------------------------------------------------

import re

class PhoneNumber:
    def __init__(self, phone_number: str) -> None:        
        self.tel_number = re.findall('(\d{3})\s*(\d{3})\s*(\d{4})', phone_number)[0]
        
    def __repr__(self) -> str:
        return f"PhoneNumber('{''.join(self.tel_number)}')"

    def __str__(self) -> str:
        return "({}) {}-{}".format(*self.tel_number)


phone = PhoneNumber('9173963385')

print(str(phone))
print(repr(phone))
# -------------------replace-----------------------------------

class PhoneNumber:
    def __init__(self, phone_number):
        self.phone_number = phone_number.replace(' ', '')
        
    def __str__(self):
        return f'({self.phone_number[:3]}) {self.phone_number[3:6]}-{self.phone_number[6:]}'
    
    def __repr__(self):
        return f"PhoneNumber('{self.phone_number}')"


# ---------------------------------------------------------------


# Класс AnyClass
# 867
# Реализуйте класс AnyClass. При создании экземпляра класс должен принимать произвольное количество именованных аргументов и устанавливать их в качестве атрибутов создаваемому экземпляру.
# Экземпляр класса AnyClass должен иметь следующее формальное строковое представление:
# AnyClass(<имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...)
# И следующее неформальное строковое представление:
# AnyClass: <имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...
# Примечание 1. Обратите внимание, что значения атрибутов, которые принадлежат типу str, должны быть обрамлены апострофами.
# ---------------------------------------------------------------
class AnyClass:
    def __init__(self, **kwargs) -> None:
        self.kwargs = kwargs

        for key, value in self.kwargs.items():
            if isinstance(value, str):
                



                 '{}={!r}'.format(key, value)

        self.l1 = ((f"{key}='{value}'") for key, value in self.kwargs.items() if isinstance(value, str))  )

    def __repr__(self) -> str:
        s = f"AnyClass({('{}, ' * len(self.l1))[:-2]})"
        return s.format(*self.l1)
        
        return "AnyClass({})".format(*self.l1)

    def __str__(self) -> str:
        s = f"AnyClass: {('{}, ' * len(self.l1))[:-2]}"
        return s.format(*self.l1)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# ---------------------------------------------------------------
