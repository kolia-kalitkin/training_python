
# ████─████─████
# █──█─█──█─█──█
# █──█─█──█─█──█
# █──█─█──█─█──█
# ████─████─█──█


# Класс Circle
#  977
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь три атрибута:
#     radius — радиус круга
#     diameter — диаметр круга
#     area — площадь круга
# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.
# Примечание 2. Импортировать константу ππ можно из модуля math:
# from math import pi
# ---------------------------------------------------------------

# import math


from dateutil.relativedelta import relativedelta
from datetime import date, timedelta
from functools import singledispatchmethod
import re
import string
from typing import Self
import math
import copy


class Circle:
    def __init__(self, radius) -> None:
        self.radius = radius
        self.diameter = 2 * radius
        self.area = math.pi * radius**2


circle = Circle(5)

print(circle.radius)
print(circle.diameter)
print(circle.area)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#  Класс Bee
#
# Реализуйте класс Bee, описывающий пчелку, которая перемещается по координатной плоскости в четырех направлениях: вверх, вниз, влево и вправо. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата пчелки по оси xx, по умолчанию имеет значение 0
#     y — координата пчелки по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Bee должен иметь два атрибута:
#     x — координата пчелки по оси xx
#     y — координата пчелки по оси yy
# Класс Bee должен иметь четыре метода экземпляра:
#     move_up() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси yy на n
#     move_down() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси yy на n
#     move_right() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси xx на n
#     move_left() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси xx на n
# ---------------------------------------------------------------
class Bee:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def move_up(self, n):
        self.y += n

    def move_down(self, n):
        self.y -= n

    def move_right(self, n):
        self.x += n

    def move_left(self, n):
        self.x -= n


bee = Bee()

bee.move_right(2)
bee.move_right(2)
bee.move_up(3)
bee.move_left(1)
bee.move_down(1)

print(bee.x, bee.y)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Gun
# 979
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь один метод экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.pif = 'pif'
        self.paf = 'paf'
        self.cnt = 0

    def shoot(self):
        if self.cnt % 2 == 0:
            print(self.pif)
        else:
            print(self.paf)
        self.cnt += 1


gun = Gun()

gun.shoot()
gun.shoot()
gun.shoot()
gun.shoot()

# ---------------------------------------------------------------


class Gun:
    def __init__(self):
        self.shoots = 0

    def shoot(self):
        self.shoots += 1
        print(('paf', 'pif')[self.shoots % 2])
# ---------------------------------------------------------------

# from itertools import cycle


# class Gun:
#     def __init__(self):
#         self.sounds = cycle(('pif', 'paf'))

#     def shoot(self):
#         print(next(self.sounds))


# Класс Gun2
# 973
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь три метода экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
#     shots_count() — метод, возвращающий актуальное количество вызовов метода shoot()
#     shots_reset() — метод, сбрасывающий количество вызовов метода shoot() до нуля
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.cnt_call_method_shoot = 0

    def shoot(self):
        self.cnt_call_method_shoot += 1
        # print(('paf', 'pif')[self.cnt_call_method_shoot % 2])
        print('pif' if self.cnt_call_method_shoot % 2 else 'paf')

    def shots_count(self):
        return self.cnt_call_method_shoot

    def shots_reset(self):
        self.cnt_call_method_shoot = 0
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Scales
# 970
# Реализуйте класс Scales, описывающий весы с двумя чашами. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Scales должен иметь три метода экземпляра:
#     add_right() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на правую чашу весов этот груз
#     add_left() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на левую чашу весов этот груз
#     get_result() — метод, возвращающий строку Весы в равновесии, если массы грузов на чашах совпадают, Правая чаша тяжелее — если правая чаша тяжелее, Левая чаша тяжелее — если левая чаша тяжелее
# Примечание 1. Пустые весы всегда находятся в равновесии.
# ---------------------------------------------------------------
class Scales:
    def __init__(self) -> None:
        self.cap_right = 0
        self.cap_left = 0

    def add_right(self, cargo_mass_right):
        self.cap_right += cargo_mass_right

    def add_left(self, cargo_mass_left):
        self.cap_left += cargo_mass_left

    def get_result(self):
        if self.cap_left == self.cap_right:
            message = 'Весы в равновесии'
        elif self.cap_left < self.cap_right:
            message = 'Правая чаша тяжелее'
        elif self.cap_left > self.cap_right:
            message = 'Левая чаша тяжелее'

        return message
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 964
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx, по умолчанию имеет значение 0
#     y — координата вектора по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Vector должен иметь два атрибута:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Класс Vector должен иметь один метод экземпляра:
#     abs() — метод, возвращающий модуль вектора
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def abs(self):
        return (self.x**2 + self.y**2)**0.5
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# Класс Numbers
# 963
# Реализуйте класс Numbers, описывающий изначально пустой расширяемый набор целых чисел. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Numbers должен иметь три метода экземпляра:
#     add_number() — метод, принимающий в качестве аргумента целое число и добавляющий его в набор
#     get_even() — метод, возвращающий список всех четных чисел из набора
#     get_odd() — метод, возвращающий список всех нечетных чисел из набора
# Примечание 1. Числа в списках, возвращаемых методами get_even() и get_odd(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------


class Numbers:
    def __init__(self) -> None:
        self.lst = []

    def add_number(self, num):
        self.lst.append(num)

    def get_even(self):
        return list(filter(lambda x: x % 2, self.lst))

    def get_odd(self):
        return list(filter(lambda x: not x % 2, self.lst))


numbers = Numbers()

numbers.add_number(1)
numbers.add_number(3)
numbers.add_number(1)

print(numbers.get_even())
print(numbers.get_odd())
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс TextHandler
# 944
# Будем называть словом любую последовательность из одной или более букв. Текстом будем считать набор слов, разделенных пробельными символами.
# Реализуйте класс TextHandler, описывающий изначально пустой расширяемый набор слов. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса TextHandler должен иметь три метода:
#     add_words() — метод, принимающий в качестве аргумента текст и добавляющий слова из данного текста в набор
#     get_shortest_words() — метод, возвращающий актуальный список самых коротких слов в наборе
#     get_longest_words() — метод, возвращающий актуальный список самых длинных слов в наборе
# Примечание 1. Слова в списках, возвращаемых методами get_shortest_words() и get_longest_words(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------
class TextHandler:
    def __init__(self) -> None:
        self.words = []

    def add_words(self, text):
        for word in text.split():
            self.words.append(word)

    def get_shortest_words(self):
        short = min(self.words, key=len, default=None)

        if short:
            return list(filter(lambda x: len(x) == len(short), self.words))
        return []

    def get_longest_words(self):
        long = max(self.words, key=len, default=None)

        if long:
            return list(filter(lambda x: len(x) == len(long), self.words))
        return []
# -------------------ПРЕПОД--------------------------------------


class TextHandler:
    def __init__(self):
        self.words = []
        self.shortest = 0
        self.longest = 0

    def add_words(self, words):
        words = words.split()
        self.words.extend(words)
        self.shortest = min(map(len, self.words))
        self.longest = max(map(len, self.words))

    def get_shortest_words(self):
        return [w for w in self.words if len(w) == self.shortest]

    def get_longest_words(self):
        return [w for w in self.words if len(w) == self.longest]
# ---------------------------------------------------------------


# Класс Todo
# 941
# Реализуйте класс Todo, описывающий список дел. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Todo должен иметь один атрибут:
#     things — изначально пустой список дел, которые нужно выполнить
# Класс Todo должен иметь четыре метода экземпляра:
#     add() — метод, принимающий название дела и его приоритет (целое число) и добавляющий данное дело в список дел в виде кортежа:
#     (<название дела>, <приоритет>)
#     get_by_priority() — метод, принимающий в качестве аргумента целое число n и возвращающий список названий дел, имеющих приоритет n
#     get_low_priority() — метод, возвращающий список названий дел, имеющих самый низкий приоритет
#     get_high_priority() — метод, возвращающий список названий дел, имеющих самый высокий приоритет
# Примечание 1. Названия дел в списках, возвращаемых методами get_by_priority(), get_low_priority() и get_high_priority(), должны располагаться в том порядке, в котором они были добавлены в список.
# ---------------------------------------------------------------
class Todo:
    def __init__(self) -> None:
        self.things = []
        self.priority_lst = []

    def add(self, case_name, priority):
        self.things.append((case_name, priority))
        self.priority_lst.append(priority)

    def get_by_priority(self, n):
        self.priority_lst.append(n)
        return [w[0] for w in self.things if w[1] == n]

    def get_low_priority(self):
        low_low_priority = min(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == low_low_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)

    def get_high_priority(self):
        high_priority = max(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == high_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)


todo = Todo()

todo.add('Ответить на вопросы', 5)
todo.add('Сделать картинки', 1)
todo.add('Доделать задачи', 4)
todo.add('Дописать конспект', 5)

print(todo.get_low_priority())
print(todo.get_high_priority())
print(todo.get_by_priority(3))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Postman
# 910
# Реализуйте класс Postman, описывающий почтальона. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Postman должен иметь один атрибут:
#     delivery_data — изначально пустой список адресов, по которым следует доставить письма
# Экземпляр класса Postman должен иметь три метода экземпляра:
#     add_delivery() — метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:
#     (<улица>, <дом>, <квартира>)
#     get_houses_for_street() — метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма
#     get_flats_for_house() — метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма
# Примечание 1. Дома и квартиры в списках, возвращаемых методами get_houses_for_street() и get_flats_for_house(), должны располагаться в том порядке, в котором они были добавлены.
# ---------------------------------------------------------------

class Postman:
    def __init__(self) -> None:
        # """изначально пустой список адресов, по которым следует доставить письма"""
        self.delivery_data = []

    def add_delivery(self, street, house, flat):
        """метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:  """
        self.delivery_data.append((street, house, flat))

    def get_houses_for_street(self, street):
        """метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма"""
        gen1 = (i[1] for i in self.delivery_data if i[0] == street)
        # удаляет дубликат списка
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)
        # sorted(set(x), key=lambda d: x.index(d))
        # функцию drop_duplicates из пандаса
        # збавиться от дубликатов, сохранив порядок можно через словарь
        return l1

    def get_flats_for_house(self, street, house):
        """метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма"""
        gen1 = (i[2] for i in self.delivery_data if i[0]
                == street and i[1] == house)
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)

        return l1
# ---------------------препод--через словарь---------------------------------


class Postman:
    def __init__(self):
        self.delivery_data = []

    def add_delivery(self, street, house, apartment):
        self.delivery_data.append((street, house, apartment))

    def get_houses_for_street(self, street):
        return list({h: None for s, h, _ in self.delivery_data if s == street})

    def get_flats_for_house(self, street, house):
        return list({a: None for s, h, a in self.delivery_data if s == street and h == house})
# ---------------------------------------------------------------


#  Класс Wordplay
# 850
# Будем называть словом любую последовательность из одной или более латинских букв.
# Реализуйте класс Wordplay, описывающий расширяемый набор слов. При создании экземпляра класс должен принимать один аргумент:
#     words — список, определяющий начальный набор слов. Если не передан, начальный набор слов считается пустым
# Экземпляр класса Wordplay должен иметь один атрибут:
#     words — список, содержащий набор слов
# Класс Wordplay должен иметь четыре метода экземпляра:
#     add_word() — метод, принимающий в качестве аргумента слово и добавляющий его в набор. Если слово уже есть в наборе, метод ничего не должен делать
#     words_with_length() — метод, принимающий в качестве аргумента натуральное число n и возвращающий список слов из набора, длина которых равна n
#     only() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из набора, которые включают в себя только переданные буквы
#     avoid() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из списка words, которые не содержат ни одну из этих букв
# Примечание 1. Слова в списках, возвращаемых методами words_with_length(), only() и avoid(), должны располагаться в том порядке, в котором они были добавлены.
# Примечание 2. Экземпляр класса Wordplay не должен зависеть от списка, на основе которого он был создан. Другими словами, если исходный список изменится, то экземпляр класса Wordplay измениться не должен.
# ---------------------------------------------------------------


class Wordplay:
    def __init__(self, words=None) -> None:
        if words is None:
            words = []
        words2 = copy.copy(words)
        self.words = words2

    def add_word(self, new_word):
        if new_word not in self.words:
            self.words.append(new_word)

    def words_with_length(self, n):
        return [word for word in self.words if len(word) == n]

    def only(self, *args):
        return [word for word in self.words if set(args) >= set(word)]

    def avoid(self, *args):
        return [word for word in self.words if set(args).isdisjoint(set(word))]


words = ['Лейбниц', 'Бэббидж', 'Нейман', 'Джобс', 'да_Винчи', 'Касперский']
wordplay = Wordplay(words)

words.extend(['Гуев', 'Харисов', 'Светкин'])
print(words)
print(wordplay.words)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Knight ♞
#
# Реализуйте класс Knight, описывающий шахматного коня. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     horizontal — координата коня по горизонтальной оси, представленная латинской буквой от a до h
#     vertical — координата коня по вертикальной оси, представленная целым числом от 1 до 8 включительно
#     color — цвет коня (black или white)
# Экземпляр класса Knight должен иметь три атрибута:
#     horizontal — координата коня на шахматной доске по горизонтальной оси
#     vertical — координата коня на шахматной доске по вертикальной оси
#     color — цвет коня
# Класс Knight должен иметь четыре метода экземпляра:
#     get_char() — метод, возвращающий символ N
#     can_move() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и возвращающий True, если конь может переместиться на клетку с данными координатами, или False в противном случае
#     move_to() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и заменяющий текущие координаты коня на переданные. Если конь из текущей клетки не может переместиться на клетку с указанными координатами, его координаты должны остаться неизменными
#     draw_board() — метод, печатающий шахматное поле, отмечающий на этом поле коня и клетки, на которые может переместиться конь. Пустые клетки должны быть отображены символом ., конь — символом N, клетки, на которые может переместиться конь, — символом *
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Circle
#
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:

#     radius — радиус круга

# Экземпляр класса Circle должен иметь три атрибута:

#     _radius — радиус круга
#     _diameter — диаметр круга
#     _area — площадь круга

# Класс Circle должен иметь три метода экземпляра:

#     get_radius() — метод, возвращающий радиус круга
#     get_diameter() — метод, возвращающий диаметр круга
#     get_area() — метод, возвращающий площадь круга

# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.

# Примечание 2. Импортировать константу ππ можно из модуля math:

# ---------------------------------------------------------------


class Circle:
    def __init__(self, radius: int) -> None:
        self._radius = radius
        self._diameter = 2 * radius
        self._area = math.pi * radius**2

    def get_radius(self) -> int:
        """метод, возвращающий радиус круга"""
        return self._radius

    def get_diameter(self) -> int:
        """метод, возвращающий диаметр круга"""
        return self._diameter

    def get_area(self) -> int:
        """метод, возвращающий площадь круга"""
        return self._area
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BankAccount
# 949
# Реализуйте класс BankAccount, описывающий банковский счет. При создании экземпляра класс должен принимать один аргумент:
#     balance — баланс счета, по умолчанию имеет значение 0
# Экземпляр класса BankAccount должен иметь один атрибут:
#     _balance — баланс счета
# Класс BankAccount должен иметь четыре метода экземпляра:
#     get_balance() — метод, возвращающий актуальный баланс счета
#     deposit() — метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount
#     withdraw() — метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
#     transfer() — метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

# from typing import Self

# class BankAccount:
#     def __init__(self, balance=0: int | float) -> None:
#         self._balance = balance

#     def get_balance(self) -> int | float:
#         """метод, возвращающий актуальный баланс счета"""
#         return self._balance

#     def deposit(self, amount: int | float):
#         """метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount"""
#         self._balance += amount

#     def withdraw(self, amount: int | float):
#         """метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением: На счете недостаточно средств"""
#         if self._balance > amount:
#             self._balance -= amount
#         else:
#             print('На счете недостаточно средств')
#             raise ValueError

#     # def transfer(self: Self, account: Self, amount: int) -> None:
#     def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
#         """метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: """
#         self.withdraw(amount)
#         self.account = account
#         self.account.deposit(amount)


# account1 = BankAccount(100)
# account2 = BankAccount(200)

# account1.transfer(account2, 50)
# print(account1.get_balance())
# print(account2.get_balance())
# ---------------------------------------------------------------
    # def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
    #     """метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: """
    #     self.withdraw(amount)
    #     self.account = account
    #     self.account.deposit(amount)
# ---------------------------------------------------------------


# Класс User
# 937
# Реализуйте класс User, описывающий интернет-пользователя. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя пользователя. Если name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     age — возраст пользователя. Если age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Экземпляр класса User должен иметь два атрибута:
#     _name — имя пользователя
#     _age — возраст пользователя
# Класс User должен иметь четыре метода экземпляра:
#     get_name() — метод, возвращающий имя пользователя
#     set_name() — метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     get_age() — метод, возвращающий возраст пользователя
#     set_age() — метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Примечание 1. Если при создании экземпляра класса User имя и возраст одновременно являются некорректными, должно быть возбуждено исключение, связанное с именем.
# ---------------------------------------------------------------
class User:
    def __init__(self, name: str, age: int) -> None:

        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже.
        self.set_name(name)
        self.set_age(age)

        self._name = name
        self._age = age

    def get_name(self):
        """метод, возвращающий имя пользователя"""
        return self._name

    def get_age(self):
        """метод, возвращающий возраст пользователя"""
        return self._age

    # Сеттер1

    def set_name(self, new_name: str):
        """метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом: """
        if isinstance(new_name, str) and new_name.isalpha():
            self._name = new_name
        else:
            raise ValueError('Некорректное имя')

    # Сеттер2
    def set_age(self, new_age: int):
        """метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом: """
        if isinstance(new_age, int) and 0 <= new_age <= 110:
            self._age = new_age
        else:
            raise ValueError('Некорректный возраст')
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 949
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь два свойства:
#     perimeter — свойство, доступное только для чтения, возвращающее периметр прямоугольника
#     area — свойство, доступное только для чтения, возвращающее площадь прямоугольника
# Примечание 1. При изменении сторон прямоугольника должны изменяться его периметр и площадь.
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length, width):
        self._length = length
        self._width = width

    # --------------------------------------------------------
    def get_length(self):
        """геттер - возвращает значение длины"""
        return self._length

    def set_length(self, length):
        """сеттер - меняет значение длины"""
        self._length = length

    # --------------------------------------------------------
    def get_width(self):
        """геттер -  возвращает значение ширины"""
        return self._width

    def set_width(self, width):
        """сеттер - меняет значение ширины"""
        self._width = width

    # --------------------------------------------------------
    def get_perimeter(self):
        """геттер - возвращает значение периметра"""
        return 2 * (self._length + self._width)

    # --------------------------------------------------------
    def get_area(self):
        """геттер -  возвращает значение площади"""
        return self._length * self._width
    # --------------------------------------------------------

    length = property(get_length, set_length)
    width = property(get_width, set_width)
    perimeter = property(get_perimeter)
    area = property(get_area)


rectangle = Rectangle(4, 5)

print(rectangle.length)
print(rectangle.width)
print(rectangle.perimeter)
print(rectangle.area)

# ---------------------------------------------------------------


class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def get_perimeter(self):
        return 2*(self.length + self.width)

    def get_area(self):
        return self.length * self.width

    perimeter = property(get_perimeter)
    area = property(get_area)
# ---------------------------------------------------------------


# Класс HourClock
# 958
# Реализуйте класс HourClock, описывающий часы с одной лишь часовой стрелкой. При создании экземпляра класс должен принимать один аргумент:
#     hours — количество часов. Если hours не является целым числом, принадлежащим диапазону [1; 12], должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Класс HourClock должен иметь одно свойство:
#     hours — свойство, доступное для чтения и записи, возвращающее текущее количество часов. При изменении свойство должно проверять, что новое значение является целым числом, принадлежащим диапазону [1; 12], в противном случае должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Примечание 1. Никаких ограничений касательно реализации класса HourClock нет, она может быть произвольной.
# ---------------------------------------------------------------
class HourClock:
    def __init__(self, hours: int) -> None:

        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже.
        self.set_hours(hours)

    def get_hours(self) -> int:
        """геттер возвращает текущее количество часов"""

        return self._hours

    def set_hours(self, hours: int) -> None:
        """cеттер изменяет и проверяет на корректность новое количество часов"""

        if not (isinstance(hours, int) and 1 <= hours <= 12):
            raise ValueError('Некорректное время')
        self._hours = hours

    hours = property(get_hours, set_hours)


time = HourClock(7)

print(time.hours)
time.hours = 9
print(time.hours)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Person
# 962
# Реализуйте класс Person, описывающий человека. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person должен иметь два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person должен иметь одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self.set_person(name, surname)

    def get_name(self) -> str:
        """геттер возвращает имя"""
        return self._name

    def get_surname(self) -> str:
        """геттер возвращает фамилию"""
        return self._surname

    def set_name(self, name) -> None:
        """сеттер изменяет имя"""
        self._name = name

    def set_surname(self, surname: str) -> None:
        """сеттер изменяет фамилию"""
        self._surname = surname

    def get_person(self) -> str:
        """возвращающее полное имя человека в виде строки"""
        return f"{self.get_name()} {self.get_surname()}"

    def set_person(self, *args: str) -> None:
        if len(args) == 1:
            l1 = args[0].split()
            self._name = l1[0]
            self._surname = l1[1]
        else:
            self._name, self._surname = args

    name = property(get_name, set_name)
    surname = property(get_surname, set_surname)
    fullname = property(get_person, set_person)


person = Person('Джон', 'Маккарти')

person.fullname = 'Алан Тьюринг'
print(person.name)
print(person.surname)

# -----------короче---------------------------------------


class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def get_fullname(self):
        return self.name + ' ' + self.surname

    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()

    fullname = property(get_fullname, set_fullname)
# ---------------------------------------------------------------


#  Person
#
# Вам доступен класс Person, описывающий человека. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person имеет два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person имеет одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Реализуйте свойство fullname класса Person с помощью декоратора @property.
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self._name = name
        self._surname = surname

    @property
    def fullname(self):
        return "{} {}".format(self.name, self.surname)

    @fullname.setter
    def fullname(self, fullname):
        self.name, self.surname = fullname.split()

# БЕЗ ДЕКОРАТОРА


class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def get_fullname(self):
        return self.name + ' ' + self.surname

    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()

    fullname = property(get_fullname, set_fullname)


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Account
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Account нет, она может быть произвольной.
# ---------------------------------------------------------------


class Account:
    def __init__(self, login, password) -> None:
        self._login = login
        self._password = hash_function(password)

    # ---------------------------------------------------------------

    @property
    def login(self):        # свойство доступно только для чтения (сеттер выдаст ошибку при попытке изменить логин)
        return self._login

    @login.setter
    def login(self, login):
        raise AttributeError('Изменение логина невозможно')
    # ---------------------------------------------------------------

    @property
    def password(self):        # свойство доступно для чтения и записи
        return self._password

    @password.setter
    def password(self, password):
        self._password = hash_function(password)


def hash_function(password):
    """ф-я принимает в качестве аргумента пароль и возвращает его хеш-значение."""
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10**9


account = Account('timyr-guev', 'lovebeegeek')

print(account.password)
account.password = 'verylovebeegeek'
print(account.password)

# ------------------препод-------------------------------------


def hash_function(password):
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10 ** 9


class Account:
    def __init__(self, login, password):
        self._login = login
        self.password = password

    @property
    def login(self):
        return self._login

    @login.setter
    def login(self, login):
        raise AttributeError('Изменение логина невозможно')

    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, password):
        self._password = hash_function(password)
# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------


# from typing import Tuple

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @property
    def x1(self) -> float | None:
        """ свойство, доступное только для чтения, возвращающее корень1 квадратного трехчлена,"""
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b - descriminant**0.5) / (2 * self.a)

    @property
    def x2(self) -> float | None:
        """ свойство, доступное только для чтения, возвращающее корень2 квадратного трехчлена"""
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b + descriminant**0.5) / (2 * self.a)

    @property
    def view(self) -> str:
        """ свойство, доступное только для чтения, возвращающее строку вида ax^2 + bx + c"""
        signs = ''
        for i in self.coefficients:
            if i >= 0:
                signs += '+'
            else:
                signs += '-'
        signs = signs[1:]

        res = '{a}x^2 {} {b}x {} {c}'.format(
            *signs, a=self.a, b=abs(self.b), c=abs(self.c))
        return res

    @property
    def coefficients(self) -> Tuple[int | float]:
        """геттер, доступ для чтения, возвращающее кортеж вида: (a, b, c)"""
        return (self.a, self.b, self.c)

    @coefficients.setter
    def coefficients(self, coefficients1) -> Tuple[int | float]:
        """сеттер изменяющий коэффициенты"""
        self.a, self.b, self.c = coefficients1


polynom = QuadraticPolynomial(1, 2, -3)

polynom.coefficients = (1, -5, 6)
print(polynom.x1)
print(polynom.x2)
print(polynom.view)
# -----------------препод---------------------------------------


class QuadraticPolynomial:
    def __init__(self, a, b, c):
        self.a, self.b, self.c = a, b, c

    @property
    def d(self):
        return self.b ** 2 - 4 * self.a * self.c

    @property
    def x1(self):
        # короткая запись if else
        return (-self.b - self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def x2(self):
        return (-self.b + self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def view(self):
        b, sign_b = abs(self.b), '-' if self.b < 0 else '+'
        c, sign_c = abs(self.c), '-' if self.c < 0 else '+'
        return f'{self.a}x^2 {sign_b} {b}x {sign_c} {c}'

    @property
    def coefficients(self):
        return self.a, self.b, self.c

    @coefficients.setter
    def coefficients(self, coeff):
        a, b, c = coeff
        self.a, self.b, self.c = a, b, c
# ---------------------------------------------------------------


# Класс Color
# 873
# Для кодирования цвета часто используется шестнадцатеричное значение цвета. Оно записывается в формате #RRGGBB, где RR (красный), GG (зеленый) и BB (синий) являются шестнадцатеричными целыми числами в диапазоне [00; FF] (или [0; 255] в десятичной системе счисления), которые указывают интенсивность соответствующих цветов. Например, #0000FF представляет чистый синий цвет, так как синий компонент имеет наивысшее значение (FF), а остальные — 00.
# Реализуйте класс Color, описывающий цвет. При создании экземпляра класс должен принимать один аргумент:
#     hexcode — шестнадцатеричное значение цвета
# Экземпляр класса Color должен иметь три атрибута:
#     r — интенсивность красного компонента цвета в виде десятичного числа
#     g — интенсивность зеленого компонента цвета в виде десятичного числа
#     b — интенсивность синего компонента цвета в виде десятичного числа
# Класс Color должен иметь одно свойство:
#     hexcode — свойство, доступное для чтения и записи, возвращающее шестнадцатеричное значение цвета
# Примечание 1. При изменении шестнадцатеричного значения цвета значения атрибутов r, g и b также должны изменяться.
# Примечание 2. Гарантируется, что для записи шестнадцатеричных чисел используются только заглавные латинские буквы.
# ---------------------------------------------------------------


class Color:
    def __init__(self, hexcode: str) -> None:
        self._hexcode = hexcode
        self.r = hex_to_ten(self._hexcode[:2])
        self.g = hex_to_ten(self._hexcode[2:4])
        self.b = hex_to_ten(self._hexcode[4:])

    # ---------------------------------------------------------------
    @property
    def hexcode(self) -> str:
        """геттер, возвращает шестнадцатеричное значение цвета"""
        return self._hexcode

    @hexcode.setter
    def hexcode(self, hexcode: str) -> None:
        """сеттер, для изменения цвета"""
        self._hexcode = hexcode
        self.r = hex_to_ten(hexcode[:2])
        self.g = hex_to_ten(hexcode[2:4])
        self.b = hex_to_ten(hexcode[4:])
    # ---------------------------------------------------------------


# оказывается :) функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое
def hex_to_ten(hex_num: str) -> int:
    """ф-я принимает шестнадцатеричное значение цвета и возвращает цвет в виде десятичного числа"""
    dict_hex = {'0': 0,
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                '6': 6,
                '7': 7,
                '8': 8,
                '9': 9,
                "A": 10,
                "B": 11,
                "C": 12,
                "D": 13,
                "E": 14,
                "F": 15}

    return sum((dict_hex[num_hex]) * 16**pow_index for pow_index, num_hex in enumerate(reversed(hex_num)))


color = Color('0000FF')

color.hexcode = 'A782E3'
print(color.hexcode)
print(color.r)
print(color.g)
print(color.b)
# -----------------препод--------------------------------------


class Color:
    def __init__(self, hexcode):
        self.hexcode = hexcode

    @property
    def hexcode(self):
        return self._hexcode

    @hexcode.setter
    def hexcode(self, hexcode):
        self._hexcode = hexcode

        # функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое
        self.r = int(hexcode[0:2], 16)
        self.g = int(hexcode[2:4], 16)
        self.b = int(hexcode[4:6], 16)
# ---------------------------------------------------------------


# Класс Circle
# 950
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь один атрибут:
#     radius — радиус круга
# Класс Circle должен иметь один метод класса:
#     from_diameter() — метод, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра
# ---------------------------------------------------------------
class Circle:
    def __init__(self, radius: int | float) -> None:
        self.radius = radius

    @classmethod
    def from_diameter(cls, diametr: int | float) -> int | float:
        """метод класса, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра"""

        return cls(diametr / 2)


circle = Circle.from_diameter(10)
print(circle.radius)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 965
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь один метод класса:
#     square() — метод, принимающий в качестве аргумента число side и возвращающий экземпляр класса Rectangle c длиной и шириной, равными side
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length: int | float, width: int | float) -> None:
        self.length = length
        self.width = width

    @classmethod
    def square(cls, side: int | float) -> 'Rectangle':
        """ метод класса, принимающий в качестве аргумента число side и возвращающий экземпляр класса """
        return cls(side, side)


rectangle = Rectangle.square(5)

print(rectangle.length)
print(rectangle.width)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 916
# вадратный трехчлен — это многочлен вида ax2+bx+cax2+bx+c, где a≠0a=0. Например:
# x2+1x2−5x+6Реализуйте класс QuadraticPolynomial, описывающий квадратный трехчлен. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Экземпляр класса QuadraticPolynomial должен иметь три атрибута:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Класс QuadraticPolynomial должен иметь два метода класса:
#     from_iterable() — метод, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов
#     from_str() — метод, принимающий в качестве аргумента строку, которая содержит коэффициенты a, b и c квадратного трехчлена, записанные через пробел. Метод должен возвращать экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов, предварительно преобразованных в экземпляры класса float
# ---------------------------------------------------------------

# from typing import TypeVar

# TMyClass = TypeVar("TMyClass", bound="MyClass")

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @classmethod
    def from_iterable(cls, iterable) -> 'QuadraticPolynomial':
        """метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов"""
        return cls(*iterable)

    @classmethod
    def from_str(cls, string) -> 'QuadraticPolynomial':
        """метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов"""
        iterable = map(float, string.split())
        return cls(iterable)
# ---------------------------------------------------------------


# Класс Pet
# 926
# Реализуйте класс Pet, описывающий домашнее животное. При создании экземпляра класс должен принимать один аргумент:
#     name — имя домашнего животного
# Экземпляр класса Pet должен иметь один атрибут:
#     name — имя домашнего животного
# Класс Pet должен иметь три метода класса:
#     first_pet() — метод, возвращающий самый первый созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     last_pet() — метод, возвращающий самый последний созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     num_of_pets() — метод, возвращающий количество созданных экземпляров класса Pet
# ---------------------------------------------------------------
class Pet:

    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)   # передаём весь экземпляр

    @classmethod
    def first_pet(cls):  # в методах класса нужно брать его из списка
        if cls.pets:
            return cls.pets[0]

    @classmethod
    def last_pet(cls):
        if cls.pets:
            return cls.pets[-1]

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)

# ----------------------------------------


class Pet:
    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)

    @classmethod
    def first_pet(cls):
        return cls.pets[0] if cls.pets else None

    @classmethod
    def last_pet(cls):
        return cls.pets[-1] if cls.pets else None

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)
# ---------------------------------------------------------------


# Класс StrExtension
#
# Реализуйте класс StrExtension, описывающий набор функций для работы со строками. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс StrExtension должен иметь три статических метода:
#     remove_vowels() — метод, который принимает в качестве аргумента строку, удаляет из нее все гласные латинские буквы без учета регистра и возвращает полученный результат
#     leave_alpha() — метод, который принимает в качестве аргумента строку, удаляет из нее все символы, не являющиеся латинскими буквами, и возвращает полученный результат
#     replace_all() — метод, который принимает три строковых аргумента string, chars и char, заменяет в строке string все символы из chars на char с учетом регистра и возвращает полученный результат.
# Примечание 1. Гарантируется, что все буквенные символы относятся к латинскому алфавиту.
# Примечание 2. Латинские гласные буквы: a, e, i, o, u, y.
# ---------------------------------------------------------------


class StrExtension:

    @staticmethod
    def remove_vowels(string1):
        vowels = ('a', 'e', 'i', 'o', 'u', 'y')
        str_off_vowels = (
            char for char in string1 if char.lower() not in vowels)
        return ''.join(str_off_vowels)

    @staticmethod
    def leave_alpha(string1):
        symbols = (char for char in string1 if char.lower()
                   not in string.ascii_lowercase)
        return ''.join(symbols)

    @staticmethod
    def replace_all(string1: str, chars, char):

        for char_old in chars:
            string1 = string1.replace(char_old, char)

        return string1


# -----------------c регулярками-------------------------------


class StrExtension:
    __VOWELS = re.compile(r'[aeiouy]', flags=re.I)
    __ALPHABET = re.compile(r'[^a-zA-Z]')

    @staticmethod
    def remove_vowels(string):
        return StrExtension.__VOWELS.sub('', string)

    @staticmethod
    def leave_alpha(string):
        return StrExtension.__ALPHABET.sub('', string)

    @staticmethod
    def replace_all(string, chars, char):
        return re.sub(fr'[{chars}]', char, string)
# ---------------------------------------------------------------


# Класс CaseHelper 🌶️
# 783
# Snake Case — стиль написания составных слов, при котором несколько слов разделяются символом нижнего подчеркивания (_) и не имеют пробелов в записи, причём каждое слово пишется с маленькой буквы. Например, bee_geek и hello_world.
# Upper Camel Case — стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с заглавной буквы. Например, BeeGeek и HelloWorld.
# Реализуйте класс CaseHelper, описывающий набор функций для работы со строками в стилях Snake Case и Upper Camel Case. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс CaseHelper должен иметь четыре статических метода:
#     is_snake() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Snake Case, или False в противном случае
#     is_upper_camel() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Upper Camel Case, или False в противном случае
#     to_snake() — метод, который принимает в качестве аргумента строку в стиле Upper Camel Case, записывает ее в стиле Snake Case и возвращает полученный результат
#     to_upper_camel() — метод, который принимает в качестве аргумента строку в стиле Snake Case, записывает ее в стиле Upper Camel Case и возвращает полученный результат
# ---------------------------------------------------------------

# class CaseHelper:


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Processor
# 937
# Вам доступен класс Processor. При создании экземпляра класс не принимает никаких аргументов.
# Класс Processor имеет один статический метод:
#     process() — метод, который принимает в качестве аргумента произвольный объект, преобразует его в зависимости от его типа и возвращает полученный результат. Если тип переданного объекта не поддерживается методом, возбуждается исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Перепишите метод process() класса Processor с использованием декоратора @singledispatchmethod, чтобы он выполнял ту же задачу.
# Примечание 1. Примеры преобразования объектов всех поддерживаемых типов показаны в методе process() класса Processor.
# # ---------------------------------------------------------------
# class Processor:
#     @staticmethod
#     def process(data):
#         if isinstance(data, (int, float)):
#             return data * 2
#         elif isinstance(data, str):
#             return data.upper()
#         elif isinstance(data, list):
#             return sorted(data)
#         elif isinstance(data, tuple):
#             return tuple(sorted(data))
#         raise TypeError('Аргумент переданного типа не поддерживается')
# ---------------------------------------------------------------


class Processor:
    @singledispatchmethod
    @staticmethod
    def process(data):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @process.register(tuple)
    @staticmethod
    def _tuple_process(data):
        return tuple(sorted(data))

    @process.register(list)
    @staticmethod
    def _list_process(data):
        return sorted(data)

    @process.register(str)
    @staticmethod
    def _str_process(data):
        return data.upper()

    @process.register(int)
    # @process.register(int | float)    # В Python 3.11 можно так
    @process.register(float)
    @staticmethod
    def _numeric_process(data):
        return data * 2
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Negator
# 953
# Реализуйте класс Negator. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Negator должен иметь один статический метод:
#     neg() — метод, принимающий в качестве аргумента объект и возвращающий его противоположное значение. Если методу передается целое или вещественное число, он должен возвращать это число, взятое с противоположным знаком. Если методу в качестве аргумента передается булево значение, он должен возвращать булево значение, противоположное переданному. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------


class Negator:
    @singledispatchmethod
    @staticmethod
    def neg(object):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @neg.register(int)
    @neg.register(float)
    @staticmethod
    def _str_neg(object):
        return object * (-1)

    @neg.register(bool)
    @staticmethod
    def _str_neg(object):
        return not object
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Formatter
# 917
# Реализуйте класс Formatter. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Formatter должен иметь один статический метод:
#     format() — метод, принимающий в качестве аргумента объект типа int, float, tuple, list или dict и выводящий информацию о переданном объекте в формате, зависящем от его типа. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Примеры форматирования объектов всех типов показаны в тестовых данных.
# Примечание 2. Обратите внимание, что метод format() должен обрамлять апострофами строковые элементы коллекций.
# ---------------------------------------------------------------


class Formatter:

    @singledispatchmethod
    @staticmethod
    def format(arg):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @format.register(int)
    def _(arg):
        print(f"Целое число: {arg}")

    @format.register(float)
    def _(arg):
        print(f"Вещественное число: {arg}")

    @format.register(tuple)
    def _(arg):
        print("Элементы кортежа: ", end='')
        print(*arg, sep=', ')

    @format.register(list)
    def _(arg):
        # print(f'Элементы списка: {", ".join([str(obj) for obj in data])}')
        print("Элементы списка: ", end='')
        print(*arg, sep=', ')

    @format.register(dict)
    def _(arg):
        # print(f'Пары словаря: {", ".join([str(pair) for pair in data.items()])}')
        print("Пары словаря: ", end='')
        print(*arg.items(), sep=', ')
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BirthInfo 🌶️
# 782
# Реализуйте класс BirthInfo, описывающий данные о дате рождения. При создании экземпляра класс должен принимать один аргумент:
#     birth_date — дата рождения, представленная в одном из следующих вариантов:
#     экземпляр класса date
#     строка с датой в ISO формате
#     список или кортеж из трех целых чисел: года, месяца и дня
# Если дата рождения является некорректной или представлена в каком-либо другом формате, должно быть возбуждено исключение TypeError с текстом:
# Аргумент переданного типа не поддерживается
# Экземпляр класса BirthInfo должен иметь один атрибут:
#     birth_date — дата рождения в виде экземпляра класса date
# Класс BirthInfo должен иметь одно свойство:
#     age — свойство, доступное только для чтения, возвращающее текущий возраст в годах, то есть количество полных лет, прошедших с даты рождения на сегодняшний день
# Примечание 1. Возраст в годах должен вычисляться так же, как и обычный возраст человека, то есть в день рождения его возраст увеличивается на один год.
# ---------------------------------------------------------------


class BirthInfo:

    @singledispatchmethod
    def __init__(self, birth_date) -> None:
        raise TypeError('Аргумент переданного типа не поддерживается')

    @__init__.register(date)
    def _(self, birth_date):
        self.birth_date = birth_date

    @__init__.register(str)
    def _(self, birth_date):
        # try:
        #     self.birth_date = date.fromisoformat(birth_date)
        # except:
        #     raise TypeError('Аргумент переданного типа не поддерживается')

        if not re.fullmatch(r'\d{4}-\d{2}-\d{2}', birth_date):
            raise TypeError('Аргумент переданного типа не поддерживается')
        self.birth_date = date.fromisoformat(birth_date)

    @__init__.register(list)
    @__init__.register(tuple)
    def _(self, birth_date):
        self.birth_date = date(*birth_date)

    @property
    def age(self):
        age = date.today().year - self.birth_date.year - 1
        age += (date.today().month,
                date.today().day) >= (self.birth_date.month, self.birth_date.day)
        return age
# ---------------------------------------------------------------


relativedelta(date1, date2).years
# ---------------------------------------------------------------


# Класс Config
#
# Реализуйте класс Config, который соответствует шаблону синглтон и описывает конфигурационный объект с фиксированными параметрами. При создании экземпляра класс не должен принимать никаких аргументов.
# При первом вызове класса Config должен создаваться и возвращаться экземпляр этого класса, а при последующих вызовах должен возвращаться экземпляр, созданный при первом вызове.
# Экземпляр класса Config должен иметь четыре атрибута:
#     program_name — атрибут со строковым значением GenerationPy
#     environment — атрибут со строковым значением release
#     loglevel — атрибут со строковым значением verbose
#     version — атрибут со строковым значением 1.0.0
# ---------------------------------------------------------------

class Config:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        self.program_name = 'GenerationPy'
        self.environment = 'release'
        self.loglevel = 'verbose'
        self.version = '1.0.0'


config = Config()

print(config.program_name)
print(config.environment)
print(config.loglevel)
print(config.version)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Book
# 949
# Требовалось реализовать класс Book, описывающий книгу. При создании экземпляра класс должен был принимать три аргумента в следующем порядке:
#     title — название книги
#     author — автор книги
#     year — год выпуска книги
# Предполагалось, что экземпляры класса Book будут иметь следующее формальное строковое представление:
# Book('<название книги>', '<автор книги>', <год выпуска книги>)
# И следующее неформальное строковое представление:
# <название книги> (<автор книги>, <год выпуска книги>)
# Программист торопился и решил задачу неправильно. Исправьте приведенный ниже код и реализуйте класс Book правильно.
# ---------------------------------------------------------------

class Book:
    def __init__(self, title, author, year) -> None:
        self.title = title
        self.author = author
        self.year = year

    def __str__(self):
        return f'{self.title} ({self.author}, {self.year})'

    def __repr__(self) -> str:
        return f"Book('{self.title}', '{self.author}', {self.year})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 972
# Вам доступен класс Rectangle, описывающий прямоугольник. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Реализуйте для экземпляров класса Rectangle следующее формальное и неформальное строковое представление:
# Rectangle(<длина прямоугольника>, <ширина прямоугольника>)
# ---------------------------------------------------------------

class Rectangle:
    def __init__(self, length, width) -> None:
        self.length = length
        self.width = width

    def __repr__(self) -> str:
        return f"Rectangle({self.length}, {self.width})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 966
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# И следующее неформальное строковое представление:
# Вектор на плоскости с координатами (<координата x>, <координата y>)
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x, y) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __str__(self) -> str:
        return f"Вектор на плоскости с координатами ({self.x}, {self.y})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс IPAddress
# 950
# IP-адрес — это уникальный адрес, идентифицирующий устройство в интернете или локальной сети. IP-адреса представляют собой набор из четырех целых чисел, разделенных точками. Например, 192.158.1.38. Каждое число в наборе принадлежит интервалу от 0 до 255. Таким образом, полный диапазон IP-адресации — это адреса от 0.0.0.0 до 255.255.255.255.
# Реализуйте класс IPAddress, описывающий IP-адрес. При создании экземпляра класс должен принимать один аргумент:
#     ipaddress — IP-адрес, представленный в одном из следующих вариантов:
#     строка из четырех целых чисел, разделенных точками
#     список или кортеж из четырех целых чисел
# Экземпляр класса IPAddress должен иметь следующее формальное строковое представление:
# IPAddress('<IP-адрес в виде четырех целых чисел, разделенных точками>')
# И следующее неформальное строковое представление:
# <IP-адрес в виде четырех целых чисел, разделенных точками>
# ---------------------------------------------------------------


class IPAddress:

    @singledispatchmethod
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ipaddress

    @__init__.register(tuple)
    @__init__.register(list)
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ''.join(ipaddress)

    def __repr__(self) -> str:
        return f"IPAddress('{self.ipaddress}')"

    def __str__(self) -> str:
        return f"{self.ipaddress}"

# ----------------if else------------------------------------------


class IPAddress:
    def __init__(self, ipadress):
        if isinstance(ipadress, str):
            self.ipadress = ipadress
        elif isinstance(ipadress, (list, tuple)):
            self.ipadress = '.'.join(map(str, ipadress))

    def __str__(self):
        return self.ipadress

    def __repr__(self):
        return f"{self.__class__.__name__}('{self.ipadress}')"

# -------------------property-------------------------------------


class IPAddress:
    def __init__(self, ipaddress: str | tuple):
        self.ipaddress = ipaddress

    @property
    def ipaddress(self):
        return self._ipaddress

    @ipaddress.setter
    def ipaddress(self, data: str | tuple | list):
        self._ipaddress = data if isinstance(
            data, str) else '.'.join(map(str, data))

    def __str__(self):
        return self._ipaddress

    def __repr__(self):
        return f"{type(self).__name__}('{self._ipaddress}')"


# Класс PhoneNumber
# 932
# ализуйте класс PhoneNumber, описывающий телефонный номер. При создании экземпляра класс должен принимать один аргумент:
#     phone_number — телефонный номер, представляющий строку из десяти цифр в одном из следующих форматов:
#     dddddddddd
#     ddd ddd dddd
# Экземпляр класса PhoneNumber должен иметь следующее формальное строковое представление:
# PhoneNumber('<телефонный номер в формате dddddddddd>')
# И следующее неформальное строковое представление:
# <телефонный номер в формате (ddd) ddd-dddd>
# ---------------------------------------------------------------


class PhoneNumber:
    def __init__(self, phone_number: str) -> None:
        self.tel_number = re.findall(
            '(\d{3})\s*(\d{3})\s*(\d{4})', phone_number)[0]

    def __repr__(self) -> str:
        return f"PhoneNumber('{''.join(self.tel_number)}')"

    def __str__(self) -> str:
        return "({}) {}-{}".format(*self.tel_number)


phone = PhoneNumber('9173963385')

print(str(phone))
print(repr(phone))
# -------------------replace-----------------------------------


class PhoneNumber:
    def __init__(self, phone_number):
        self.phone_number = phone_number.replace(' ', '')

    def __str__(self):
        return f'({self.phone_number[:3]}) {self.phone_number[3:6]}-{self.phone_number[6:]}'

    def __repr__(self):
        return f"PhoneNumber('{self.phone_number}')"


# ---------------------------------------------------------------


# Класс AnyClass
# 867
# Реализуйте класс AnyClass. При создании экземпляра класс должен принимать произвольное количество именованных аргументов и устанавливать их в качестве атрибутов создаваемому экземпляру.
# Экземпляр класса AnyClass должен иметь следующее формальное строковое представление:
# AnyClass(<имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...)
# И следующее неформальное строковое представление:
# AnyClass: <имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...
# Примечание 1. Обратите внимание, что значения атрибутов, которые принадлежат типу str, должны быть обрамлены апострофами.
# ---------------------------------------------------------------
class AnyClass:
    def __init__(self, **kwargs) -> None:
        self.kwargs = kwargs

        for key, value in self.kwargs.items():
            if isinstance(value, str):

                 '{}={!r}'.format(key, value)

        self.l1 = ((f"{key}='{value}'") for key, value in self.kwargs.items() if isinstance(value, str)))

    def __repr__(self) -> str:
        s=f"AnyClass({('{}, ' * len(self.l1))[:-2]})"
        return s.format(*self.l1)

        return "AnyClass({})".format(*self.l1)

    def __str__(self) -> str:
        s=f"AnyClass: {('{}, ' * len(self.l1))[:-2]}"
        return s.format(*self.l1)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 939
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# Также экземпляры класса Vector должны поддерживать операции сравнения с помощью операторов == и!=. Два вектора считаются равными, если их координаты по обеим осям совпадают. Методы, реализующие операции сравнения, должны уметь сравнивать как два вектора между собой, так и вектор с кортежем из двух чисел, представляющих координаты xx и yy.
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int | float, y: int | float) -> None:
        self.x=x
        self.y=y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __eq__(self, __o: object | tuple) -> bool:
        if isinstance(__o, Vector):
            return self.x == __o.x and self.y == __o.y
        elif isinstance(__o, tuple) == __o and len(__o) == 2:
            return (self.x, self.y) == __o
        return NotImplemented
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Word
# 956
# Будем называть словом любую последовательность из одной или более латинских букв.
# Реализуйте класс Word, описывающий слово. При создании экземпляра класс должен принимать один аргумент:
#     word — слово
# Экземпляр класса Word должен иметь следующее формальное строковое представление:
# Word('<слово в исходном виде>')
# И следующее неформальное строковое представление:
# <слово, в котором первая буква заглавная, а все остальные строчные>
# Также экземпляры класса Word должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два слова считаются равными, если их длины совпадают. Слово считается больше другого слова, если его длина больше.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

from functools import total_ordering

@ total_ordering
class Word:
    def __init__(self, word: str) -> None:
        self.word=word

    def __repr__(self) -> str:
        return "Word('{}')".format(self.word)

    def __str__(self) -> str:
        return self.word.title()

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Word):
            return len(self.word) == len(__o.word)
        return NotImplemented

    def __lt__(self, __o: object) -> bool:
        if isinstance(__o, Word):
            return len(self.word) < len(__o.word)
        return NotImplemented



# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Month
# 938
# Реализуйте класс Month, описывающий месяц. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     year — год
#     month — порядковый номер месяца
# Экземпляр класса Month должен иметь следующее формальное строковое представление:
# Month(<год>, <порядковый номер месяца>)
# И следующее неформальное строковое представление:
# <год>-<порядковый номер месяца>
# Также экземпляры класса Month должны поддерживать все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два Month объекта считаются равными, если их годы и порядковые номера месяцев совпадают. Month объект считается больше другого Month объекта, если его год больше. В случае если два Month объекта имеют равные года, большим считается тот, чей месяц больше. Методы, реализующие операции сравнения, должны уметь сравнивать как два Month объекта между собой, так и Month объект с кортежем из двух чисел, представляющих год и месяц.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
from functools import total_ordering
from typing import Tuple

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Version
# 886
# Реализуйте класс Version, описывающий версию программного обеспечения. При создании экземпляра класс должен принимать один аргумент:
#     version — строка из трех целых чисел, разделенных точками и описывающих версию ПО. Например, 2.8.1. Если одно из чисел не указано, оно считается равным нулю. Например, версия 2 равнозначна версии 2.0.0, а версия 2.8 равнозначна версии 2.8.0
# Экземпляр класса Version должен иметь следующее формальное строковое представление:
# Version('<версия ПО в виде трех целых чисел, разделенных точками>')
# И следующее неформальное строковое представление:
# <версия ПО в виде трех целых чисел, разделенных точками>
# Также экземпляры класса Version должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два Version объекта считаются равными, если все три числа в их версиях совпадают. Version объект считается больше другогоVersion объекта, если первое число в его версии больше. Или если второе число в его версии больше, если первые числа совпадают. Или если третье число в его версии больше, если первые и вторые числа совпадают.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from functools import total_ordering
from itertools import zip_longest


@ total_ordering
class Version:
    def __init__(self, version: str) -> None:

        nums_version=map(int, version.split('.'))
        index_elem=range(3)

        # заполняю недостающие цифры нулями и добавляю только первые элементы кортежей
        gen1=(i[0] for i in zip_longest(nums_version, index_elem, fillvalue=0))

        self.write_full_version='.'.join(map(str, gen1))
        self.num1, self.num2, self.num3=(
            int(char) for char in self.write_full_version.split('.'))




    def __repr__(self) -> str:
        return f"Version('{self.write_full_version}')"

    def __str__(self) -> str:
        return self.write_full_version

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Version):
            return (self.num1, self.num2, self.num3) == (__o.num1, __o.num2, __o.num3)
        return NotImplemented

    def __lt__(self, __o: object) -> bool:
        if isinstance(__o, Version):
            return (self.num1, self.num2, self.num3) < (__o.num1, __o.num2, __o.num3)
        return NotImplemented



versions=[Version('2'), Version('2.1'), Version('1.9.1')]

print(sorted(versions))
print(min(versions))
print(max(versions))


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ReversibleString
#
# Реализуйте класс ReversibleString, описывающий строку. При создании экземпляра класс должен принимать один аргумент:
#     string — значение строки
# Экземпляр класса ReversibleString должен иметь следующее неформальное строковое представление:
# <значение строки>
# Также экземпляр класса ReversibleString должен поддерживать унарный оператор -, результатом которого должен являться новый экземпляр класса ReversibleString со значением строки в обратном порядке.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# --------------------------------------------------------------
class ReversibleString:
    def __init__(self, string: str) -> None:
        self.string=string

    def __str__(self) -> str:
        return f'{self.string}'


    def __neg__(self):
        return ReversibleString(''.join(reversed(self.string)))

string=ReversibleString('python')

print(string)
print(-string)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Money
# 972
# Реализуйте класс Money, описывающий денежную сумму в рублях. При создании экземпляра класс должен принимать один аргумент:
#     amount — количество денег
# Экземпляр класса Money должен иметь следующее неформальное строковое представление:
# <количество денег> руб.
# Также экземпляр класса Money должен поддерживать унарные операторы + и -:
#     результатом унарного + должен являться новый экземпляр класса Money с неотрицательным количеством денег
#     результатом унарного - должен являться новый экземпляр класса Money с отрицательным количеством денег
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class Money:
    def __init__(self, amount: int | float) -> None:
        self.amount=amount

    def __str__(self) -> str:
        return f'{self.amount} руб.'

    def __neg__(self):
        return Money(-abs(self.amount))

    def __pos__(self):
        return Money(abs(self.amount))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 959
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# И следующее неформальное строковое представление:
# (<координата вектора по оси x>, <координата вектора по оси y>)
# Также экземпляр класса Vector должен поддерживать унарные операторы + и -:
#     результатом унарного + должен являться новый экземпляр класса Vector с исходными координатами
#     результатом унарного - должен являться новый экземпляр класса Vector с координатами, взятыми с противоположным знаком
# Наконец, при передаче экземпляра класса Vector в функцию abs() должен возвращаться его модуль.
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x, y) -> None:
        self.x=x
        self.y=y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __str__(self) -> str:
        return f'({self.x}, {self.y})'


    def __pos__(self):
        return Vector(self.x, self.y)

    def __neg__(self):
        return Vector(-self.x, -self.y)


    def __abs__(self):
        return (self.x**2 + self.y**2)**0.5

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ColoredPoint
# 939
# Реализуйте класс ColoredPoint, описывающий цветную точку на плоскости. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     color — цвет в формате RGB, представленный кортежем из трех целых чисел в диапазоне [0; 255], по умолчанию имеет значение (0, 0, 0)
# Экземпляр класса ColoredPoint должен иметь три атрибута:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     color — цвет в формате RGB, представленный кортежем из трех целых чисел от 0 до 255
# Также экземпляр класса ColoredPoint должен иметь следующее формальное строковое представление:
# ColoredPoint(<координата x>, <координата y>, <цвет точки в виде трехэлементного кортежа>)
# И следующее неформальное строковое представление:
# (<координата x>, <координата y>)
# Наконец, экземпляр класса ColoredPoint должен поддерживать унарные операторы +, - и ~:
#     результатом унарного + должен являться новый экземпляр класса ColoredPoint c исходными координатами и цветом
#     результатом унарного - должен являться новый экземпляр класса ColoredPoint c координатами, умноженными на минус единицу, и исходным цветом
#     результатом унарного ~ должен являться новый экземпляр класса ColoredPoint c координатами, переставленными местами, и инвертированным цветом: значение каждой компоненты цвета отнимается от 255
# ---------------------------------------------------------------
class ColoredPoint:
    def __init__(self, x, y, color = (0, 0, 0)) -> None:
        self.x, self.y, self.color=x, y, color

    def __repr__(self) -> str:
        return f"ColoredPoint({self.x}, {self.y}, {self.color})"

    def __str__(self) -> str:
        return f"({self.x}, {self.y})"

    def __pos__(self):
        return ColoredPoint(self.x, self.y, self.color)

    def __neg__(self):
        return ColoredPoint(-self.x, -self.y, self.color)

    def __invert__(self):
        a, b, c=self.color
        return ColoredPoint(self.y, self.x, (255 - a, 255 - b, 255 - c))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Matrix 🌶️🌶️
#
# Реализуйте класс Matrix, описывающий двумерную матрицу. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     rows — количество строк в матрице
#     cols — количество столбцов в матрице
#     value — начальное значение для элементов матрицы, по умолчанию имеет значение 0
# Экземпляр класса Matrix должен иметь два атрибута:
#     rows — количество строк в матрице
#     cols — количество столбцов в матрице
# Класс Matrix должен иметь два метода экземпляра:
#     get_value() — метод, принимающий в качестве аргументов строку row и столбец col и возвращающий элемент матрицы со строкой row и столбцом col
#     set_value() — метод, принимающий в качестве аргументов строку row, столбец col и значение value и устанавливающий в качестве значения элемента матрицы со строкой row и столбцом col значение value
# Экземпляр класса Matrix должен иметь следующее формальное строковое представление:
# Matrix(<количество строк в матрице>, <количество столбцов в матрице>)
# Неформальным строковым представлением должна быть строка, в которой перечислены все элементы матрицы. Элементы строки матрицы должны быть разделены пробелом, строки матрицы должны быть разделены символом переноса строки \n. Например, для объекта Matrix(2, 3) неформальным строковым представлением должна быть строка 0 0 0\n0 0 0, которая при выводе будет отображаться следующим образом:
# 0 0 0
# 0 0 0
# Также экземпляр класса Matrix должен поддерживать унарные операторы +, - и ~:
#     результатом унарного + должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с исходными элементами
#     результатом унарного - должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с элементами, взятыми с противоположным знаком
#     результатом унарного ~ должен являться новый экземпляр класса Matrix, представляющий транспонированную матрицу
# Наконец, при передаче экземпляра класса Matrix в функцию round() должен возвращаться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с элементами, округленными с помощью функции round(). Во время передачи в функцию round() должна быть возможность в качестве второго необязательного аргумента указать целое число, определяющее количество знаков после запятой при округлении.
# Примечание 1. Индексация строк и столбцов в матрице начинается с нуля.
# ---------------------------------------------------------------

class Matrix:
    def __init__(self, rows: int, cols: int, value = 0) -> None:
        self.rows=rows
        self.cols=cols

        self.matrix=[[value] * cols for _ in range(rows)]


    def get_value(self, row, col) -> int | float:
        """метод, принимающий в качестве аргументов строку row и столбец col и возвращающий элемент матрицы со строкой row и столбцом col"""
        return self.matrix[row][col]

    def set_value(self, row, col, value) -> None:
        """метод, принимающий в качестве аргументов строку row, столбец col и значение value и устанавливающий в качестве значения элемента матрицы со строкой row и столбцом col значение value"""
        self.matrix[row][col]=value



    def __repr__(self) -> str:
        return f"Matrix({self.rows}, {self.cols})"

    def __str__(self) -> str:
        l1=[' '.join(map(str, rows)) for rows in self.matrix]
        return '\n'.join(l1)



    def __pos__(self) -> "Matrix":
        new_intance=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                # используем сеттер и геттер
                new_intance.set_value(i, j, self.get_value(i, j))

        return new_intance


    def __neg__(self) -> "Matrix":
        new_intance=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                # используем сеттер и геттер
                new_intance.set_value(i, j, -self.get_value(i, j))

        return new_intance


    def __invert__(self) -> "Matrix":
        new_intance1=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                # используем сеттер и геттер
                new_intance1.set_value(i, j, self.get_value(i, j))

        new_intance2=Matrix(new_intance1.cols, new_intance1.rows)

        transponse=zip(*new_intance1.matrix)  # транспонируем new_intance1
        new_intance2.matrix=transponse

        return new_intance2


    def __round__(self, n = None) -> "Matrix":
        new_intance=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                if n is None:
                    new_intance.set_value(i, j, round(self.get_value(i, j)))
                new_intance.set_value(i, j, round(self.get_value(i, j), n))

        return new_intance


# ------тест---
matrix=Matrix(5, 10)

floats=[[7125.900408, 633.354471, -9237.8575119, 2865.3825158, 5509.2609336, 8712.260779, 8317.523947, 2512.4736075,
           -3087.5496014, 3861.68814],
          [-7852.451832, 376.465911, -8142.7867326, -6921.8371407, 3735.7516227, -3322.8019034, 7115.79968,
           -8949.9313078, -7032.4347679, -5217.8236385],
          [-7817.9657992, -4319.716346, -1038.6294521, -2959.8970273, -9263.5713405, 9358.607686, 1429.6576196,
           -9484.68116, 639.6343972, 3444.9938213],
          [-2844.2405153, -2078.2441427, 6812.1367017, 112.3910618, -1116.8662449, 5042.7026276, -5981.6930342,
           4370.9173164, -8851.7648474, 8990.6896422],
          [90.8102435, 5256.6137481, -9743.8477321, -131.5501688, -5920.5976176, 4963.8336619, -4907.3622526,
           8531.2015615, -244.3630074, 3421.8817151]]

for r in range(5):
    for c in range(10):
        matrix.set_value(r, c, floats[r][c])

print('НАЧАЛЬНАЯ')
print(matrix)
print()
print('+++++')
print(+matrix)
print()
print('-------')
print(-matrix)
print()
print('ТРАНСПОНИРОВАНАЯ')
print(~matrix)
print()
print('ОКРУГЛЕНИЕ')
print(round(matrix, 2))
# ---------------------------------------------------------------

# ---------------------------------------------------------------

   
# Класс FoodInfo
# 943
# Реализуйте класс FoodInfo, описывающий пищевую ценность продуктов. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     proteins — количество белков в граммах
#     fats — количество жиров в граммах
#     carbohydrates — количество углеводов в граммах
# Экземпляр класса FoodInfo должен иметь три атрибута:
#     proteins — количество белков в граммах
#     fats — количество жиров в граммах
#     carbohydrates — количество углеводов в граммах
# И следующее формальное строковое представление:
# FoodInfo(<количество белков>, <количество жиров>, <количество углеводов>)
# Также экземпляры класса FoodInfo должны поддерживать между собой операцию сложения с помощью оператора +, результатом которой должен являться новый экземпляр класса FoodInfo с суммарным количеством белков, жиров и углеводов исходных экземпляров.
# Наконец, экземпляр класса FoodInfo должен поддерживать операции умножения, деления и деления нацело на число n с помощью операторов *, / и // соответственно:
#     результатом умножения должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого умножены на n
#     результатом деления должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого поделены на n
#     результатом деления нацело должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого поделены нацело на n
# Примечание 1. Числами будем считать экземпляры классов int и float. Также будем гарантировать, что экземпляр класса FoodInfo всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import TypeVar

Self = TypeVar("Self", bound="FoodInfo")



class FoodInfo:
    def __init__(self, proteins: int | float, fats: int | float, carbohydrates: int | float) -> None:
        self.proteins = proteins
        self.fats = fats
        self.carbohydrates = carbohydrates


    def __repr__(self) -> str:
        return f"FoodInfo({self.proteins}, {self.fats}, {self.carbohydrates})"

    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, FoodInfo):
            return FoodInfo(self.proteins + other.proteins, self.fats + other.fats, self.carbohydrates + other.carbohydrates)
        return NotImplemented

    def __mul__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins * other, self.fats * other, self.carbohydrates * other)
        return NotImplemented
   
    def __truediv__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins / other, self.fats / other, self.carbohydrates / other)
        return NotImplemented

    def __floordiv__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins // other, self.fats // other, self.carbohydrates // other)
        return NotImplemented

#--------tests----------
pfc = [(751.26, 778.77, 947.51), (597.41, 508.5, 532.96), (800.55, 617.5, 525.14), (741.99, 785.53, 664.71),
       (525.69, 892.41, 541.41), (888.8, 802.56, 868.78), (609.65, 855.43, 949.44), (705.25, 592.28, 738.72),
       (514.88, 617.22, 557.5), (948.62, 938.7, 817.17), (783.98, 628.32, 686.38), (894.9, 815.81, 715.19),
       (586.79, 826.68, 637.5), (670.53, 683.69, 841.56), (583.9, 607.34, 853.35), (954.67, 950.76, 822.19),
       (718.94, 658.12, 537.2), (556.53, 686.17, 622.61), (699.8, 872.49, 908.3), (622.3, 920.97, 801.17)]

FoodInfo.__round__ = lambda instance: FoodInfo(
    round(instance.proteins, 2),
    round(instance.fats, 2),
    round(instance.carbohydrates, 2)
)

food1 = FoodInfo(1000, 2000, 3000)
for p, f, c in pfc:
    food2 = FoodInfo(p, f, c)
    add_food = food1 + food2
    mul_food = food1 * p
    truediv_food = food1 // c
    print(round(add_food), round(mul_food), round(truediv_food))

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
#
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# Также экземпляры класса Vector должны поддерживать между собой операции сложения и вычитания с помощью операторов + и - соответственно:
#     результатом сложения должен являться новый экземпляр класса Vector, координата по оси xx которого равна сумме координат по оси xx исходных векторов, координата по оси yy — сумме координат по оси yy исходных векторов
#     результатом вычитания должен являться новый экземпляр класса Vector координата по оси xx которого равна разности координат по оси xx исходных векторов с учетом порядка, координата по оси yy — разности координат по оси yy исходных векторов с учетом порядка
# Наконец, экземпляр класса Vector должен поддерживать операции умножения и деления на число n с помощью операторов * и / соответственно:
#     результатом умножения должен являться новый экземпляр класса Vector, координаты которого умножены на n
#     результатом деления должен являться новый экземпляр класса Vector, координаты которого поделены на n
# Операция умножения должна быть выполнима независимо от порядка операндов, то есть должна быть возможность умножить как вектор на число, так и число на вектор.
# Примечание 1. Числами будем считать экземпляры классов int и float. Также будем гарантировать, что экземпляр класса Vector всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int, y: int) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented

    
    
    def __truediv__(self, n):
        if isinstance(n, (int, float)):
            return Vector(self.x / n, self.y / n)
        return NotImplemented
    
    def __rtruediv__(self, n):
        if isinstance(n, (int, float)):
            return Vector(n / self.x, n / self.y)
        return NotImplemented


    def __mul__(self, n):
        if isinstance(n, (int, float)):
            return Vector(self.x * n, self.y * n)
        return NotImplemented
    
    def __rmul__(self, n):
        if isinstance(n, (int, float)):
            return Vector(n * self.x, n * self.y)
        return NotImplemented


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс SuperString
# 893
# Реализуйте класс SuperString, описывающий строку. При создании экземпляра класс должен принимать один аргумент:
#     string — значение строки
# Экземпляр класса SuperString должен иметь следующее неформальное строковое представление:
# <значение строки>
# Помимо этого, экземпляры класса SuperString должны поддерживать между собой операцию сложения с помощью оператора +, результатом которой должен являться новый экземпляр класса SuperString, представляющий конкатенацию исходных.
# Также экземпляр класса SuperString должен поддерживать операции умножения, деления, побитового сдвига влево и побитового сдвига вправо на целое число n с помощью операторов *, /, << и >> соответственно:
#     результатом умножения должен являться новый экземпляр класса SuperString, представляющий исходную строку, умноженную на n
#     результатом деления должен являться новый экземпляр класса SuperString, представляющий строку из первых m символов исходной строки, где m — длина исходной строки, поделенная нацело на n
#     результатом побитового сдвига влево должен являться новый экземпляр класса SuperString, представляющий исходную строку без последних n символов. Если n больше или равно длине исходной строки, результатом должен являться экземпляр класса SuperString, представляющий пустую строку
#     результатом побитового сдвига вправо должен являться новый экземпляр класса SuperString, представляющий исходную строку без первых n символов. Если n больше или равно длине исходной строки, результатом должен являться экземпляр класса SuperString, представляющий пустую строку
# Операция умножения должна быть выполнима независимо от порядка операндов, то есть должна быть возможность умножить как строку на число, так и число на строку.
# Примечание 1. Будем гарантировать, что экземпляр класса SuperString всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class SuperString:
    def __init__(self, string: str) -> None:
        self.string = string

    def __str__(self) -> str:
        return self.string

    def __add__(self, other):
        if isinstance(other, SuperString):
            return SuperString(self.string + other.string) 
        return NotImplemented

    
    def __mul__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            return SuperString(self.string * n)
        return NotImplemented

    def __rmul__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            return SuperString(n * self.string)
        return NotImplemented

    def __truediv__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            s = len(self.string) // n
            return SuperString(self.string[:s])
        return NotImplemented

    
    
    def __lshift__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            if n <= len(self.string):
                if n == 0:
                    return SuperString(self.string)
                return SuperString(self.string[:-n])
            else:
                return SuperString('')
        return NotImplemented

    def __rshift__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            if n <= len(self.string):
                return SuperString(self.string[n:])
            else:
                return SuperString('')
        return NotImplemented

# ---------------------------------------------------------------


# Класс Time
# 880
# Реализуйте класс Time, описывающий время на цифровых часах. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     hours — количество часов; каждые 24 часа должны преобразовываться в 0 часов
#     minutes — количество минут; каждые 60 минут должны преобразовываться в 1 час
# Экземпляр класса Time должен иметь следующее неформальное строковое представление:
# <количество часов в формате HH>:<количество минут в формате MM>
# Также экземпляры класса Time должны поддерживать между собой операцию сложения с помощью операторов + и +=:
#     результатом сложения с помощью оператора + должен являться новый экземпляр класса Time, количество часов которого равно сумме часов исходных экземпляров класса Time, количество минут — сумме минут исходных экземпляров класса Time
#     результатом сложения с помощью оператора += должен являться левый экземпляр класса Time, количество часов которого увеличено на количество часов правого экземпляра класса Time, количество минут — на количество минут правого экземпляра класса Time
# Примечание 1. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import TypeVar

Self = TypeVar("Self", bound="Time")

class Time:
    def __init__(self, hours: int, minutes: int) -> None:
        # устанавливаем корректное время сеттером
        self.set_correct_hours(hours)
        self.set_correct_minutes(minutes)
        
    
    def get_correct_hours(self):
        """получить кол-во часов"""        
        return self.hours
    
    def set_correct_hours(self, hours):
        """сеттер, устанавливает корректное кол-во часов"""
        self.hours = hours % 24
        


    def get_correct_minutes(self):
        """получить кол-во минут"""
        return self.minutes

    def set_correct_min(self, minutes):
        """сеттер, устанавливает корректное кол-во минут"""     
        time_min = divmod(minutes, 60)        
        self.minutes = time_min[1]
        self.hours += time_min[0]
    
    
    
    def __str__(self) -> str:
        return f"{str(self.hours).zfill(2)}:{str(self.minutes).zfill(2)}"

    
    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, Time):
            return Time(self.hours + other.hours, self.minutes + other.minutes)
        return NotImplemented

    def __radd__(self, other: Self) -> Self:
        if isinstance(other, Time):
            return Time(other.hours + self.hours, other.minutes + self.minutes)
        return NotImplemented

    def __iadd__(self, other: Self) -> Self:
        if isinstance(other, Time):
            self.hours += other.hours
            self.minutes += other.minutes
            
            # устанавливаем корректное время после +=
            self.set_correct_hours(self.get_correct_hours())
            self.set_correct_minutes(self.get_correct_minutes())            
            return self
        
        return NotImplemented


# -----------препод---------------------------------------------
class Time:
    def __init__(self, hours, minutes):
        self.hours, self.minutes = Time.normalize(hours, minutes)
    
    @staticmethod
    def normalize(hours, minutes):
        return (hours + minutes // 60) % 24, minutes % 60
    
    def __str__(self):
        return f'{self.hours}:{self.minutes}'
        
    def __add__(self, other):
        if isinstance(other, Time):
            return Time(*Time.normalize(self.hours + other.hours, self.minutes + other.minutes))
        return NotImplemented
    
    def __iadd__(self, other):
        if isinstance(other, Time):
            self.hours, self.minutes = Time.normalize(self.hours + other.hours, self.minutes + other.minutes)
            return self
        return NotImplemented


# ---------------------------------------------------------------


# Класс Queue 🌶️
# 831
# Очередь — абстрактный тип данных с дисциплиной доступа к элементам "первый пришёл — первый вышел". Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.
# Реализуйте класс Queue, описывающий очередь. При создании экземпляра класс должен принимать произвольное количество позиционных аргументов, каждый из которых является элементом очереди. Порядок следования аргументов образует порядок элементов в очереди, то есть первый аргумент — первый элемент очереди, второй аргумент — второй элемент очереди, и так далее.
# Класс Queue должен иметь два метода экземпляра:
#     add() — метод, принимающий произвольное количество позиционных аргументов и добавляющий их в конец очереди в том порядке, в котором они были переданы
#     pop() — метод, удаляющий из очереди первый элемент и возвращающий его. Если очередь пуста, метод должен вернуть значение None
# Экземпляр класса Queue должен иметь следующее неформальное строковое представление:
# <первый элемент очереди> -> <второй элемент очереди> -> <третий элемент очереди> -> ...
# Помимо этого, экземпляры класса Queue должны поддерживать между собой операции сравнения с помощью операторов == и!=. Две очереди считаются равными, если они имеют равную длину и содержат равные элементы на равных позициях.
# Также экземпляры класса Queue должны поддерживать между собой операцию сложения с помощью операторов + и +=:
#     результатом сложения с помощью оператора + должен являться новый экземпляр класса Queue, представляющий очередь со всеми элементами исходных очередей: сначала все элементы левой очереди, затем все элементы правой очереди
#     результатом сложения с помощью оператора += должен являться левый экземпляр класса Queue, представляющий очередь, к которой добавлены все элементы правой очереди
# Наконец, экземпляр класса Queue должен поддерживать операцию побитового сдвига вправо на целое число n с помощью оператора >>, результатом которой должен являться новый экземпляр класса Queue, представляющий исходную очередь без первых n элементов. Если n больше или равно длине исходной очереди, результатом должен являться экземпляр класса Queue, представляющий пустую очередь.
# Примечание 1. Если объект, с которым выполняется операция сравнения или арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import Self

class Queue:  
        
    def __init__(self, *args) -> None:
        self.l1 = list(args)

    
    def add(self, *args) -> None:
        for arg in args:
            self.l1.append(arg)

    def pop(self):
        if self.l1:
            return self.l1.pop(0)



    def __str__(self) -> str:        
        return ' -> '.join(map(str,self.l1))



    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Queue):
            return self.l1== __o.l1
        return NotImplemented

    def __ne__(self, __o: object) -> bool:
        if isinstance(__o, Queue):
            return self.l1 != __o.l1
        return NotImplemented


    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, Queue):            
            return Queue(*(self.l1 + other.l1))            
        return NotImplemented

    def __iadd__(self, other: Self) -> Self:
        if isinstance(other, Queue):
            self.l1 += other.l1 
            return self
        return NotImplemented



    def __rshift__(self, n: int | float) -> Self:
        """побитовый сдвиг вправо на целое число n с помощью оператора >>, результатом которого должен являться новый экземпляр класса Queue, представляющий исходную очередь без первых n элементов. Если n больше или равно длине исходной очереди, результатом должен являться экземпляр класса Queue, представляющий пустую очередь."""
        if isinstance(n, (int, float)):
            if n <= len(self.l1):
                return Queue(*self.l1[n:])
            else:
                return Queue()
        return NotImplemented

#     def __rshift__(self, n):
#         if isinstance(n, int):
#             return Queue(*self.queue[n:])
#         return NotImplemented    
# # -------------------:--------------------------------------------

# ---------------------------------------------------------------


# Класс Calculator
# 949
# Реализуйте класс Calculator, экземпляры которого позволяют выполнять различные арифметические операции с двумя числами. При создании экземпляра класс не должен принимать никаких аргументов.

# Экземпляр класса Calculator должен являться вызываемым объектом и принимать три аргумента:
#     a — число
#     b — число
#     operation — один из символов +, -, * и /
# Если operation равняется +, экземпляр класса Calculator должен вернуть сумму a и b, если - — разность a и b, если * — произведение a и b, если / — частное a и b. При попытке выполнить деление на ноль должно быть возбуждено исключение ValueError с текстом:
# Деление на ноль невозможно
# Примечание 1. Числами будем считать экземпляры классов int и float.
# ---------------------------------------------------------------

from typing import Any

class Calculator:
    def __call__(self, a: int, b: int, operation: str) -> Any:
        if operation == '+':
            result = a + b
        elif operation == '-':
            result = a - b
        elif operation == '*':
            result = a * b
        elif operation == '/':
            try:
                result = a / b
            except ZeroDivisionError:
                raise ValueError('Деление на ноль невозможно')
        return result
# -----------------препод1-----------------------------------------
class Calculator:
    def __call__(self, a, b, operation):
        match operation:
            case '+':
                return a + b
            case '-':
                return a - b
            case '*':
                return a * b
            case '/':
                if b == 0:
                    raise ValueError('Деление на ноль невозможно')
                return a / b
# -----------------препод2----------------------------------------------
class Calculator:
    def __call__(self, a, b, operation):
        if operation == '/' and b == 0:
            raise ValueError('Деление на ноль невозможно')
        return eval(f'{a}{operation}{b}')
# ---------------------------------------------------------------



# Класс RaiseTo
# 977
# Реализуйте класс RaiseTo, экземпляры которого позволяют возводить числа в фиксированную степень. При создании экземпляра класс должен принимать один аргумент:
#     degree — показатель степени
# Экземпляр класса RaiseTo должен являться вызываемым объектом и принимать один аргумент:
#     x — число
# Экземпляр класса RaiseTo должен возвращать значение x в степени degree.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса RaiseTo нет, она может быть произвольной.
# ---------------------------------------------------------------

from typing import Any

class RaiseTo:
    def __init__(self, degree) -> None:
        self.degree = degree

    def __call__(self, x: int) -> Any:
        return x**self.degree    
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Dice
# 981
# Реализуйте класс Dice, описывающий игральный кубик с определенным количеством граней. При создании экземпляра класс должен принимать один аргумент:
#     sides — количество граней игрального кубика
# Экземпляр класса Dice должен являться вызываемым объектом и не принимать никаких аргументов. При вызове он должен возвращать значение случайной грани игрального кубика. Например, если кубик имеет 6 граней, экземпляр класса Dice должен вернуть случайное число из диапазона [1; 6].
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
import random

class Dice:
    def __init__(self, sides) -> None:
        self.sides = sides

    def __call__(self):
        return random.randint(1, self.sides)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 971
# Реализуйте класс QuadraticPolynomial, описывающий квадратный трехчлен. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Экземпляр класса QuadraticPolynomial должен являться вызываемым объектом и принимать один аргумент:
#     x — число
# Экземпляр класса QuadraticPolynomial должен возвращать значение выражения ax2+bx+cax2+bx+c, где a,ba,b и cc — коэффициенты квадратного трехчлена.
# Приечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса QuadraticPolynomial нет, она может быть произвольной.
# ---------------------------------------------------------------
from typing import Any

class QuadraticPolynomial:
    def __init__(self, a, b, c) -> None:
        self.a = a
        self.b = b
        self.c = c


    def __call__(self, x) -> Any:
        return self.a * x**2 + self.b * x + self.c
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Strip
# 973
# Реализуйте класс Strip, экземпляры которого позволяют удалять из начала и конца строки определенные символы. При создании экземпляра класс должен принимать один аргумент:
#     chars — строка, в которой перечислены удаляемые символы
# Экземпляр класса Strip должен являться вызываемым объектом и принимать один аргумент:
#     string — строка
# Экземпляр класса Strip должен удалять из начала и конца строки string все символы, перечисленные в chars, и возвращать полученный результат.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Strip нет, она может быть произвольной.
# ---------------------------------------------------------------

from typing import Any

class Strip:
    def __init__(self, chars) -> None:
        self.chars = chars

    def __call__(self, string) -> Any:
        return string.strip(self.chars)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Filter
# 966
# Реализуйте класс Filter, описывающий объект для фильтрации элементов итерируемых объектов. При создании экземпляра класс должен принимать один аргумент:
#     predicate — функция-предикат; если имеет значение None, то работает аналогично функции bool()
# Экземпляр класса Filter должен являться вызываемым объектом и принимать один аргумент:
#     iterable — итерируемый объект
# Экземпляр класса Filter должен возвращать список, элементами которого являются элементы итерируемого объекта iterable, для которых функция predicate вернула значение True.
# Примечание 1. Предикат — это функция, которая возвращает True или False в зависимости от переданного в качестве аргумента значения.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 3. Никаких ограничений касательно реализации класса Filter нет, она может быть произвольной.
# ---------------------------------------------------------------
class Filter:
    def __init__(self, predicate) -> None:
        self.predicate = predicate

    def __call__(self, iterable) -> Any:
        return list(filter(self.predicate, iterable))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс DateFormatter
# 932
# Нередко в разных странах используются разные форматы дат. Рассмотрим часть из них:
# код страны 	формат даты
# ru 	DD.MM.YYYY
# us 	MM-DD-YYYY
# ca 	YYYY-MM-DD
# br 	DD/MM/YYYY
# fr 	DD.MM.YYYY
# pt 	DD-MM-YYYY
# Реализуйте класс DateFormatter, экземпляры которого позволяют преобразовывать даты в формат определенной страны из таблицы выше. При создании экземпляра класс должен принимать один аргумент:
#     country_code — код страны
# Экземпляр класса DateFormatter должен являться вызываемым объектом и принимать один аргумент:
#     d — дата (тип date)
# Экземпляр класса DateFormatter должен возвращать строку с датой d в формате страны с кодом country_code.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса DateFormatter нет, она может быть произвольной.
# ---------------------------------------------------------------

from datetime import date

class DateFormatter:
    
    pattern_date = {
        "ru": r"%d.%m.%Y",
        "us": r"%m-%d-%Y",
        "ca": r"%Y-%m-%d",
        "br": r"%d/%m/%Y",
        "fr": r"%d.%m.%Y",
        "pt": r"%d-%m-%Y"
    }
    
    def __init__(self, country_code: str) -> None:
        self.country_code = self.pattern_date[country_code]

    def __call__(self, d: date) -> str:
        return d.strftime(self.country_code)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Декоратор @CountCalls
# 953
# # Реализуйте декоратор @CountCalls, который считает количество вызовов декорируемой функции. Счетчик вызовов должен быть доступен по атрибуту calls.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимый декоратор @CountCalls, но не код, вызывающий его.
# ---------------------------------------------------------------

# import functools


# def CountCalls(func):
#     @functools.wraps(func)
#     def wrapper(*args, **kwargs):
#         wrapper.num += 1
#         return func(*args, **kwargs)
#     wrapper.num = 0    
#     return wrapper
# ---------------------------------------------------------------
from typing import Any

class CountCalls:
    def __init__(self, func) -> None:
        self.func = func
        self.calls = 0

    def __call__(self, *args: Any, **kwargs: Any) -> None:
        self.calls += 1
        return self.func(*args, **kwargs)

# ---------------------------------------------------------------


# Декоратор @CachedFunction
# 882
# # Реализуйте декоратор @CachedFunction, который кэширует вычисленные значения декорируемой функции. Кэш должен быть доступен по атрибуту cache и представлять собой словарь, ключом в котором является кортеж с аргументами, а значением — возвращаемое значение декорируемой функции при вызове с этими аргументами.
# Примечание 1. Для однозначного кеширования гарантируется, что декорируемая функция принимает только позиционные аргументы.
# ---------------------------------------------------------------
class CachedFunction:
    def __init__(self, func) -> None:
        self.func = func
        self.cache = {}

    def __call__(self, *args, **kwargs) -> int:
               
        if args in self.cache:
            return self.cache[args]
        else:
            result_func = self.func(*args, **kwargs)
            self.cache[args] = result_func
            return result_func
# ---------------------------------------------------------------
class CachedFunction:
    def __init__(self, func):
        self.func = func
        self.cache = {}

    def __call__(self, *args):
        result = self.cache.get(args) or self.func(*args)
        self.cache.setdefault(args, result)
        return result
# ---------------------------------------------------------------


#  Класс SortKey 🌶️
# 798
# Нередко во время сортировки объектов мы используем дополнительную функцию, которая описывает правило сортировки. Например, если нам нужно отсортировать список экземпляров некоторого класса на основе значений определенного атрибута, мы можем реализовать функцию, которая принимает в качестве аргумента этот экземпляр и возвращает значение необходимого атрибута.
# Приведенный ниже код:
# class User:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def __repr__(self):
#         return f'User({self.name}, {self.age})'
# users = [User('Gvido', 67), User('Timur', 30), User('Arthur', 20)]
# print(sorted(users, key=lambda user: user.age))

# выводит:
# [User(Arthur, 20), User(Timur, 30), User(Gvido, 67)]
# Удобно было бы иметь класс SortKey, позволяющий сортировать объекты на основе значений различных атрибутов, лишь перечисляя имена этих атрибутов.
# Чтобы приведенный ниже код:
# class User:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def __repr__(self):
#         return f'User({self.name}, {self.age})'
# users = [User('Gvido', 67), User('Timur', 30), User('Arthur', 20)]
# print(sorted(users, key=SortKey('age')))            # сортировка на основе атрибута age
# print(sorted(users, key=SortKey('name', 'age')))    # сортировка на основе атрибута name, а затем age
# выводил:
# [User(Arthur, 20), User(Timur, 30), User(Gvido, 67)]
# [User(Arthur, 20), User(Gvido, 67), User(Timur, 30)]
# Реализуйте класс SortKey, описывающий ключ для сортировки объектов на основе значений их определенных атрибутов. При создании экземпляра класс должен принимать произвольное количество позиционных аргументов, каждый из которых представляет имя атрибута, участвующего в сортировке.
# Примечание 1. Имена атрибутов при создании экземпляра класса SortKey передаются в порядке приоритета, то есть при сортировке сначала должно учитываться значение первого атрибута, затем второго, и так далее.
# ---------------------------------------------------------------
class SortKey:
    def __init__(self, *args) -> None:
        self.attributes = args        

    def __call__(self, object):        
        return [object.__dict__[attributes] for attributes in self.attributes]

#--------тест-----------------
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f'User({self.name}, {self.age})'

users = [User('Gvido', 67), User('Timur', 30), User('Arthur', 20), User('Timur', 45), User('Gvido', 60)]

print(sorted(users, key=SortKey('name')))
print(sorted(users, key=SortKey('name', 'age')))
print(sorted(users, key=SortKey('age')))
print(sorted(users, key=SortKey('age', 'name')))


# ---------------------------------------------------------------
class SortKey:
    def __init__(self, *attributes):
        self.attributes = attributes

    def __call__(self, instance):
        return [getattr(instance, attribute) for attribute in self.attributes]
# ---------------------------------------------------------------


# Класс Vector
# 943
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее неформальное строковое представление:
# (<координата x>, <координата y>)
# Также экземпляр класса Vector должен поддерживать приведение к типам bool, int, float и complex:
#     при приведении к типу bool значением вектора должно являться значение True, если хотя бы одна его координата не равна нулю, или False в противном случае
#     при приведении к типу int значением вектора должен являться его модуль в виде целого числа с отброшенной дробной частью
#     при приведении к типу float значением вектора должен являться его модуль в виде вещественного числа
#     при приведении к типу complex значением вектора должно являться комплексное число, вещественная часть которого равна координате вектора по оси xx, мнимая часть — координате вектора по оси yy
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int | float, y: int | float) -> None:
        self.x = x
        self.y = y

    def __str__(self) -> str:
        return f"({self.x}, {self.y})"

    def __bool__(self):
        return self.x != 0 or self.y != 0

    def __int__(self) -> int:
        return int((self.x**2 + self.y**2)**0.5)

    def __float__(self) -> float:
        return (self.x**2 + self.y**2)**0.5

    def __complex__(self) -> complex:
        return complex(self.x, self.y)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Temperature
# 936
# Реализуйте класс Temperature, описывающий температуру в градусах по шкале Цельсия. При создании экземпляра класс должен принимать один аргумент:
#     temperature — температура в градусах по шкале Цельсия
# Класс Temperature должен иметь один метод экземпляра:
#     to_fahrenheit() — метод, возвращающий температуру по шкале Фаренгейта
# Класс Temperature должен иметь один метод класса:
#     from_fahrenheit() — метод, принимающий в качестве аргумента температуру по шкале Фаренгейта и возвращающий экземпляр класса Temperature, созданный на основе переданной температуры
# Экземпляр класса Temperature должен иметь следующее неформальное строковое представление:
# <температура в градусах по шкале Цельсия с округлением до двух знаков после запятой>°C
# Также экземпляр класса Temperature должен поддерживать приведение к типам bool, int и float:
#     при приведении к типу bool значением экземпляра класса Temperature должно являться значение True, если его температура выше нуля, или False в противном случае
#     при приведении к типу int значением экземпляра класса Temperature должна являться его температура в виде целого числа с отброшенной дробной частью
#     при приведении к типу float значением экземпляра класса Temperature должна являться его температура в виде вещественного числа
# Примечание 1. Перевести температуру из шкалы Фаренгейта в шкалу Цельсия позволяет формула:
# tC=59(tF – 32)
# tC​=95​(tF​–32)где tCtC​ — температура в градусах по шкале Цельсия, tFtF​ — температура в градусах по шкале Фаренгейта.

class Temperature:
    def __init__(self, temperature) -> None:
        self.temperature = temperature
    
    def to_fahrenheit(self):
        """метод, возвращающий температуру по шкале Фаренгейта"""
        return 9/5 * self.temperature + 32

    @classmethod
    def from_fahrenheit(cls, temper_f: int | float) -> 'Temperature':
        """метод, принимающий в качестве аргумента температуру по шкале Фаренгейта и возвращающий экземпляр класса Temperature, созданный на основе переданной температуры """
        return Temperature(5/9 * (temper_f - 32))


    def __str__(self) -> str:
        return f"{round(self.temperature, 2)}°C" # return f'{self.temperature.__round__(2)}°C'
         


    def __bool__(self) -> bool:
        return self.temperature > 0

    def __int__(self) -> int:
        return int(self.temperature)

    def __float__(self) -> float:
        return float(self.temperature)
        
# ---------------------------------------------------------------


# Класс RomanNumeral🌶️🌶️
# 743
# Реализуйте класс RomanNumeral, описывающий число в римской системе счисления. При создании экземпляра класс должен принимать один аргумент:
#     number — число в римской системе счисления. Например, IV
# Экземпляр класса RomanNumeral должен иметь следующее неформальное строковое представление:
# <число в римской системе счисления>
# Помимо этого, экземпляр класса RomanNumeral должен поддерживать приведение к типу int, при приведении к которому его значением должно являться целое число в десятичной системе счисления, которому он соответствует.
# Также экземпляры класса RomanNumeral должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=.
# Наконец, экземпляры класса RomanNumeral должны поддерживать между собой операции сложения и вычитания с помощью операторов + и - соответственно:
#     результатом сложения должен являться новый экземпляр класса RomanNumeral, представляющий сумму исходных
#     результатом вычитания должен являться новый экземпляр класса RomanNumeral, представляющий разность исходных
# Примечание 1. Гарантируется, что из римского числа всегда вычитается строго меньшее римское число.
# Примечание 2. Подробнее про римскую систему счисления можно почитать по ссылке.
# Примечание 3. Не забывайте, что именно константу NotImplemented рекомендуется возвращать в методах, реализующих арифметические операции или операции сравнения, если эти операции для объектов каких-либо типов не определены.
# ---------------------------------------------------------------

from functools import total_ordering

@total_ordering
class RomanNumeral:
    def __init__(self, number: str) -> None:
        self.number = number    
    
    
    #=======================================================================
    # формируем словарь из всех римских чисел и новых комбинаций
    all_roman = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]
    
    @staticmethod
    def rim_to_dec(rom: str) -> int:
        """функция перевода римского числа в десятичную систему счисления"""
        
        # на старте десятичное число равно нулю
        dec = 0
        # перебираем все пары из словаря
        for i, r in RomanNumeral.all_roman:
            # пока римское число начинается буквы из словаря
            while rom.startswith(r):
                # увеличиваем десятичное число на соответствующее значение из словаря
                dec += i
                # убираем найденную букву из римского числа
                rom = rom[len(r):]
        # как все циклы закончились — возвращаем десятичное число
        return dec
    #=======================================================================
    
    @staticmethod    
    def dec_to_roman(num: int) -> str:
        """функция перевода чисел в римскую систему счисления"""
        # на старте в римском числе ничего нет
        roman = ''
        # пока наше число больше нуля
        while num > 0:
            # перебираем все пары из словаря
            for i, r in RomanNumeral.all_roman:
                # пока наше число больше или равно числу из словаря
                while num >= i:
                    # добавляем соответствующую букву в римское число
                    roman += r
                    # вычитаем словарное число из нашего числа
                    num -= i
        # как все циклы закончились — возвращаем римское число
        return roman
    #=======================================================================
    
    
    def __str__(self) -> str:
        return f"{self.number}"

    def __int__(self) -> int:
        return RomanNumeral.rim_to_dec(self.number)


    
    def __eq__(self, other) -> bool:
        if isinstance(other, RomanNumeral):
            return self.rim_to_dec(self.number) == self.rim_to_dec(other.number)
        return NotImplemented

    def __lt__(self, other) -> bool:
        if isinstance(other, RomanNumeral):
            return self.rim_to_dec(self.number) < self.rim_to_dec(other.number)
        return NotImplemented



    def __add__(self, other):
        if isinstance(other, RomanNumeral):
            a = self.rim_to_dec(self.number)
            b = self.rim_to_dec(other.number)
            return RomanNumeral(RomanNumeral.dec_to_roman(a + b)) 
        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, RomanNumeral):
            return RomanNumeral((self.rim_to_dec(self.number) - self.rim_to_dec(other.number))) 
        return NotImplemented



# -------тест-----
number = RomanNumeral('X') - RomanNumeral('VI')

print(number)
print(int(number))

# ----------------препод-----------------------------------------
from functools import total_ordering

@total_ordering
class RomanNumeral:
    def __init__(self, number):
        self.number = number
        
    def __str__(self):
        return self.number
    
    def __int__(self):
        return RomanNumeral.roman_to_int(self.number)
    
    def __add__(self, other):
        if isinstance(other, RomanNumeral):
            num1 = int(self)
            num2 = int(other)
            return RomanNumeral(RomanNumeral.int_to_roman(num1 + num2))
        else:
            return NotImplemented
    
    def __sub__(self, other):
        if isinstance(other, RomanNumeral):
            num1 = int(self)
            num2 = int(other)
            return RomanNumeral(RomanNumeral.int_to_roman(num1 - num2))
        else:
            return NotImplemented
    
    def __eq__(self, other):
        if isinstance(other, RomanNumeral):
            return self.number == other.number
        else:
            return NotImplemented
        
    def __gt__(self, other):
        if isinstance(other, RomanNumeral):
            return RomanNumeral.roman_to_int(self.number) > RomanNumeral.roman_to_int(other.number)
        else:
            return NotImplemented
    
    @staticmethod
    def int_to_roman(number):
        int_roman = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 
                     10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 
                     100: 'C', 400: 'CD',  500: 'D', 900: 'CM', 1000: 'M'}
        result = ''
        for n in (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1):
            while n <= number:
                result += int_roman[n]
                number -= n
        return result
     
    @staticmethod
    def roman_to_int(number):
        roman_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        summ = 0
        for i in range(len(number) - 1, -1, -1):
            num = roman_int[number[i]]
            if 3*num < summ: 
                summ -= num
            else: 
                summ += num
        return summ
# ---------------------------------------------------------------


# Класс Item
# 950
# Требовалось реализовать класс Item, описывающий предмет. При создании экземпляра класс должен был принимать три аргумента в следующем порядке:
#     name — название предмета
#     price — цена предмета в рублях
#     quantity — количество предметов
# Предполагалось, что при обращении к атрибуту name экземпляра класса Item будет возвращаться его название с заглавной буквы, а при обращении к атрибуту total — произведение цены предмета на его количество.
# Программист торопился и решил задачу неправильно. Дополните приведенный ниже код и реализуйте правильный класс Item.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class Item:
    def __init__(self, name, price, quantity):
        self.name = name.title()
        self.price = price
        self.quantity = quantity

    def __getattr__(self, attr):
        if attr == 'total': 
            return self.price * self.quantity
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Logger
# 971
# Требовалось реализовать класс Logger. При создании экземпляра класс не должен был принимать никаких аргументов.
# Предполагалось, что при установке или изменении значения атрибута экземпляра класса Logger будет выводиться текст:
# Изменение значения атрибута <имя атрибута> на <новое значение атрибута>
# Также планировалось, что при удалении атрибута будет выводиться текст:
# Удаление атрибута <имя атрибута>
# Программист торопился и решил задачу неправильно. Дополните приведенный ниже код и реализуйте правильный класс Logger.
# Примечание. Никаких ограничений касательно реализации класса Logger нет, она может быть произвольной.
# ---------------------------------------------------------------
class Logger:
    
    def __getattribute__(self, name):       
        return object.__getattribute__(self, name)      # получение значения атрибута attr объекта self

    def __setattr__(self, name, value):
        print(f'Изменение значения атрибута {name} на {value}')
        self.__dict__[name] = value

    def __delattr__(self, name):
        print(f'Удаление атрибута {name}')
        del self.__dict__[name]
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Ord
# Реализуйте класс Ord. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Ord должен выступать в качестве альтернативы функции ord(). При обращении к атрибуту экземпляра, именем которого является одиночный символ, должна возвращаться его позиция в таблице символов Unicode.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Ord нет, она может быть произвольной.
# Примечание 3. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------
class Ord:    
    def __getattr__(self, attr):
        return ord(attr)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс DefaultObject
# 964
# # Реализуйте класс DefaultObject. При создании экземпляра класс должен принимать один именованный аргумент default, имеющий значение по умолчанию None, а после произвольное количество именованных аргументов. Аргументы, передаваемые после default, должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# При обращении к несуществующему атрибуту экземпляра класса DefaultObject должно возвращаться значение default.
# ---------------------------------------------------------------
class DefaultObject:
    def __init__(self, default=None, **kwargs) -> None:
        self.default = default
                
        for attribut_name, attribut_value in kwargs.items():
            object.__setattr__(self, attribut_name, attribut_value)
    
    def __getattribute__(self, attr):   # мы обращаемся к методу __getattribute__() класса object и передаем ему в качестве аргумента объект и имя атрибута, значение по которому хотим получить. Метод __getattribute__() класса object возвращает значение атрибута по указанному имени или возбуждает исключение AttributeError, если атрибут с указанными именем не был найден.      
        return object.__getattribute__(self, attr) 
    
    def __getattr__(self, attr):      # возврат значения по умолчанию при обращении к несуществующему атрибуту      
        if attr in self.kwargs:
            return self.__dict__[attr]
        return self.default
    
    
    def __setattr__(self, attr, value):   # установка атрибута или изменение его значения внутри метода __setattr__() происходит напрямую через словарь атрибутов __dict__    
        self.__dict__[attr] = value
        # object.__setattr__(self, attr, value)     #  Вместо обращения к словарю атрибутов __dict__, метод __setattr__() может использовать свою базовую реализацию из класса object
# ----------------препод---------------------------------------
class DefaultObject:
    def __init__(self, default=None, **kwargs):
        self.default = default
        self.__dict__.update(kwargs)
        
    def __getattr__(self, name):
        return self.default
# ---------------------------------------------------------------


# Класс NonNegativeObject
# 964
# Реализуйте класс NonNegativeObject. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов, причем если значением атрибута является отрицательное число, оно должно быть взято с противоположным знаком.
# Примечание 1. Числами будем считать экземпляры классов int и float.
# ---------------------------------------------------------------
class NonNegativeObject:
    def __init__(self, **kwargs) -> None:
                
        for key, value in kwargs.items():
            if isinstance(value, (int, float)):
                self.__dict__.update({key: abs(value)})
            self.__dict__.update({key: value})

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс AttrsNumberObject
# 940
# Реализуйте класс AttrsNumberObject. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# Экземпляр класса AttrsNumberObject должен иметь один атрибут:
#     attrs_num — количество атрибутов, которыми обладает экземпляр класса AttrsNumberObject на данный момент, включая сам атрибут attrs_num

# -------------имитация атрибута  attrs_num----------------------------------------
class AttrsNumberObject:
    def __init__(self, **kwargs) -> None:          
          
        self.__dict__.update(kwargs) # Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов
        # self.__dict__ |= kwargs
 
    def __getattr__(self, name): 
        if name == 'attrs_num':
            return len(self.__dict__) + 1


music_group = AttrsNumberObject(name='Woodkid', genre='pop')

print(music_group.attrs_num)
music_group.country = 'France' # создать атрибут экземпляра
print(music_group.attrs_num)

# ----------------наличие атрибута-  attrs_num----------------------------------
class AttrsNumberObject:
    def __init__(self, attrs_num=0, **kwargs) -> None:
        self.__dict__.update(kwargs) # Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов
        self.attrs_num = attrs_num

    def __setattr__(self, attr, value):
        self.__dict__[attr] = value
        self.__dict__['attrs_num'] = len(self.__dict__)

    def __delattr__(self, attr):
        del self.__dict__[attr]
        self.__dict__['attrs_num'] = len(self.__dict__)

music_group = AttrsNumberObject(name='Woodkid', genre='pop')

print(music_group.attrs_num)
music_group.country = 'France'   # создать атрибут экземпляра

print(music_group.attrs_num)
# ---------------------------------------------------------------

# Класс Const
# 949
# Реализуйте класс Const. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# Класс Const должен разрешать устанавливать атрибуты своим экземплярам и получать их значения, но не разрешать изменять значения этих атрибутов, а также удалять их. При попытке изменить значение атрибута должно возбуждаться исключение AttributeError с текстом:
# Изменение значения атрибута невозможно
# При попытке удалить атрибут должно возбуждаться исключение AttributeError с текстом:
# Удаление атрибута невозможно
# ---------------------------------------------------------------
class Const:
    def __init__(self, **kwargs) -> None:
        self.__dict__.update(kwargs) 
    
    def __getattr__(self, attr):
        return self.__dict__[attr]
    
    def __setattr__(self, attr, value):
        if attr in self.__dict__:
            raise AttributeError('Изменение значения атрибута невозможно')
        else:
            self.__dict__[attr] = value
                    
    def __delattr__(self, attr):        
        raise AttributeError ('Удаление атрибута невозможно')   
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ProtectedObject
# 874
# Будем считать атрибут защищенным, если его имя начинается с символа нижнего подчеркивания (_). Например, _password, __email и __dict__.
# Реализуйте класс ProtectedObject. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# Класс ProtectedObject должен запрещать получать и изменять значения защищенных атрибутов своих экземпляров, а также удалять эти атрибуты. При попытке получить или изменить значение защищенного атрибута, а также попытке удалить атрибут, должно возбуждаться исключение AttributeError с текстом:
# Доступ к защищенному атрибуту невозможен
# ---------------------------------------------------------------
class ProtectedObject:
    def __init__(self, **kwargs) -> None:
        for attr, value in kwargs.items():     
             object.__setattr__(self, attr, value)
        # или вместо цикла
        # object.__getattribute__(self, '__dict__').update(kwargs)     
        
    def __getattribute__(self, attr):
        if attr[0] == '_':  #  if name.startswith('_'):
            raise AttributeError('Доступ к защищенному атрибуту невозможен')        
        else:
            return object.__getattribute__(self, attr)    
    
    # Метод __getattr__() реализовывать необязательно
            
    def __setattr__(self, attr, value):     
        if attr[0] == '_': #  if name.startswith('_'):
            raise AttributeError('Доступ к защищенному атрибуту невозможен')               
        else: 
            object.__setattr__(self, attr, value)             
        
    
    def __delattr__(self, attr):
        if attr[0] == '_': #  if name.startswith('_'):
            raise AttributeError('Доступ к защищенному атрибуту невозможен')
        else:
            object.__delattr__(self, attr)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Функция hash_function()
# 837
# Реализуйте функцию hash_function(), которая принимает один аргумент:
#     obj — произвольный объект
# Функция должна вычислять хеш-значение объекта obj согласно следующему алгоритму:
#     вычисление значения выражения:
#     ord(obj[0]) * ord(obj[-1]) + ord(obj[1]) * ord(obj[-2]) + ord(obj[2]) * ord(obj[-3]) + ...
#     где obj — объект, преобразованный в строку с помощью функции str(). Обратите внимание, что суммироваться должны произведения первого и последнего элементов, второго и предпоследнего, и так далее до середины. Если obj имеет нечетное количество символов, то серединный элемент должен прибавляться без перемножения
#     вычисление значения выражения:
#     ord(obj[0]) * 1 - ord(obj[1]) * 2 + ord(obj[2]) * 3 - ord(obj[3]) * 4 + ...
#     где obj — объект, преобразованный в строку с помощью функции str()
#     вычисление значения выражения:
#     (temp1 * temp2) % 123456791
#     где temp1 — значение, полученное в первом шаге, temp2 — значение, полученное во втором шаге
# и возвращать значение, полученное в третьем шаге.
# ---------------------------------------------------------------
def hash_function(obj):
    
    if not isinstance(obj, str):
        obj = str(obj)
    
    # шаг 1
    if len(obj) % 2:
        # нечет
        l1 = obj[:len(obj)//2]
        middle_el = obj[len(obj)//2]
        l2 = reversed(obj[len(obj)//2 + 1:])
      
        res = [ord(i) * ord(j) for i, j in zip(l1, l2)]
        res.append(ord(middle_el))        
    else:
        # чет
        l1 = obj[:len(obj)//2]
        l2 = reversed(obj[len(obj)//2:])
           
        res = [ord(i) * ord(j) for i, j in zip(l1, l2)]    

    temp1 = sum(res) 

    #---------------------------------------------
    # шаг 2
    l3 = [(ord(elem) * index) * (-1)**(index + 1) for index, elem in enumerate(obj , 1)]        
    
    temp2 = sum(l3)    
       
    
    return (temp1 * temp2) % 123456791 

    
# ---------------------------------------------------------------

# ---------------------------------------------------------------


    
    
# Функция limited_hash() 🌶️
# Реализуйте функцию limited_hash(), которая принимает три аргумента в следующем порядке:
#     left — целое число
#     right — целое число
#     hash_function — хеш-функция, по умолчанию равняется встроенной функции hash()
# Функция должна возвращать новую функцию, которая принимает в качестве аргумента произвольный объект, вычисляет его хеш-значение с помощью функции hash_function(), преобразует его в число, принадлежащее диапазону [left; right], и возвращает полученный результат.
# Если вычисленное хеш-значение уже принадлежит диапазону [left; right], то функция должна возвращать его без преобразования. Если вычисленное хеш-значение равняется right + 1, то функция перед возвратом должна преобразовать его в left, если right + 2 — в left + 1, если right + 3 — в left + 2, и так далее. Аналогичные преобразования, но в другую сторону, должны выполняться для хеш-значений, которые меньше left. Преобразования должны выполняться циклично при очередном выходе из диапазона.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию limited_hash(), но не код, вызывающий ее.
# 722
# ---------------------------------------------------------------

def limited_hash(left, right, hash_function=hash):
    def wrapper(*args, **kwargs):
        
        return hash_function(*args, **kwargs)    
    
    return wrapper


hash_function = limited_hash(10, 15)

print(hash_function(9))
print(hash_function(8))
print(hash_function(4))
print(hash_function(3))
print(hash_function(2))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# ---------------------------------------------------------------
