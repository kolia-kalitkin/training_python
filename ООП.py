
# ████─████─████
# █──█─█──█─█──█
# █──█─█──█─█──█
# █──█─█──█─█──█
# ████─████─█──█


# Класс Circle
#  977
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь три атрибута:
#     radius — радиус круга
#     diameter — диаметр круга
#     area — площадь круга
# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.
# Примечание 2. Импортировать константу ππ можно из модуля math:
# from math import pi
# ---------------------------------------------------------------

# import math


from dateutil.relativedelta import relativedelta
from datetime import date, timedelta
from functools import singledispatchmethod
import re
import string
from typing import Self
import math
import copy


class Circle:
    def __init__(self, radius) -> None:
        self.radius = radius
        self.diameter = 2 * radius
        self.area = math.pi * radius**2


circle = Circle(5)

print(circle.radius)
print(circle.diameter)
print(circle.area)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#  Класс Bee
#
# Реализуйте класс Bee, описывающий пчелку, которая перемещается по координатной плоскости в четырех направлениях: вверх, вниз, влево и вправо. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата пчелки по оси xx, по умолчанию имеет значение 0
#     y — координата пчелки по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Bee должен иметь два атрибута:
#     x — координата пчелки по оси xx
#     y — координата пчелки по оси yy
# Класс Bee должен иметь четыре метода экземпляра:
#     move_up() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси yy на n
#     move_down() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси yy на n
#     move_right() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси xx на n
#     move_left() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси xx на n
# ---------------------------------------------------------------
class Bee:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def move_up(self, n):
        self.y += n

    def move_down(self, n):
        self.y -= n

    def move_right(self, n):
        self.x += n

    def move_left(self, n):
        self.x -= n


bee = Bee()

bee.move_right(2)
bee.move_right(2)
bee.move_up(3)
bee.move_left(1)
bee.move_down(1)

print(bee.x, bee.y)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Gun
# 979
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь один метод экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.pif = 'pif'
        self.paf = 'paf'
        self.cnt = 0

    def shoot(self):
        if self.cnt % 2 == 0:
            print(self.pif)
        else:
            print(self.paf)
        self.cnt += 1


gun = Gun()

gun.shoot()
gun.shoot()
gun.shoot()
gun.shoot()

# ---------------------------------------------------------------


class Gun:
    def __init__(self):
        self.shoots = 0

    def shoot(self):
        self.shoots += 1
        print(('paf', 'pif')[self.shoots % 2])
# ---------------------------------------------------------------

# from itertools import cycle


# class Gun:
#     def __init__(self):
#         self.sounds = cycle(('pif', 'paf'))

#     def shoot(self):
#         print(next(self.sounds))


# Класс Gun2
# 973
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь три метода экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
#     shots_count() — метод, возвращающий актуальное количество вызовов метода shoot()
#     shots_reset() — метод, сбрасывающий количество вызовов метода shoot() до нуля
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.cnt_call_method_shoot = 0

    def shoot(self):
        self.cnt_call_method_shoot += 1
        # print(('paf', 'pif')[self.cnt_call_method_shoot % 2])
        print('pif' if self.cnt_call_method_shoot % 2 else 'paf')

    def shots_count(self):
        return self.cnt_call_method_shoot

    def shots_reset(self):
        self.cnt_call_method_shoot = 0
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Scales
# 970
# Реализуйте класс Scales, описывающий весы с двумя чашами. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Scales должен иметь три метода экземпляра:
#     add_right() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на правую чашу весов этот груз
#     add_left() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на левую чашу весов этот груз
#     get_result() — метод, возвращающий строку Весы в равновесии, если массы грузов на чашах совпадают, Правая чаша тяжелее — если правая чаша тяжелее, Левая чаша тяжелее — если левая чаша тяжелее
# Примечание 1. Пустые весы всегда находятся в равновесии.
# ---------------------------------------------------------------
class Scales:
    def __init__(self) -> None:
        self.cap_right = 0
        self.cap_left = 0

    def add_right(self, cargo_mass_right):
        self.cap_right += cargo_mass_right

    def add_left(self, cargo_mass_left):
        self.cap_left += cargo_mass_left

    def get_result(self):
        if self.cap_left == self.cap_right:
            message = 'Весы в равновесии'
        elif self.cap_left < self.cap_right:
            message = 'Правая чаша тяжелее'
        elif self.cap_left > self.cap_right:
            message = 'Левая чаша тяжелее'

        return message
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 964
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx, по умолчанию имеет значение 0
#     y — координата вектора по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Vector должен иметь два атрибута:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Класс Vector должен иметь один метод экземпляра:
#     abs() — метод, возвращающий модуль вектора
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def abs(self):
        return (self.x**2 + self.y**2)**0.5
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# Класс Numbers
# 963
# Реализуйте класс Numbers, описывающий изначально пустой расширяемый набор целых чисел. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Numbers должен иметь три метода экземпляра:
#     add_number() — метод, принимающий в качестве аргумента целое число и добавляющий его в набор
#     get_even() — метод, возвращающий список всех четных чисел из набора
#     get_odd() — метод, возвращающий список всех нечетных чисел из набора
# Примечание 1. Числа в списках, возвращаемых методами get_even() и get_odd(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------


class Numbers:
    def __init__(self) -> None:
        self.lst = []

    def add_number(self, num):
        self.lst.append(num)

    def get_even(self):
        return list(filter(lambda x: x % 2, self.lst))

    def get_odd(self):
        return list(filter(lambda x: not x % 2, self.lst))


numbers = Numbers()

numbers.add_number(1)
numbers.add_number(3)
numbers.add_number(1)

print(numbers.get_even())
print(numbers.get_odd())
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс TextHandler
# 944
# Будем называть словом любую последовательность из одной или более букв. Текстом будем считать набор слов, разделенных пробельными символами.
# Реализуйте класс TextHandler, описывающий изначально пустой расширяемый набор слов. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса TextHandler должен иметь три метода:
#     add_words() — метод, принимающий в качестве аргумента текст и добавляющий слова из данного текста в набор
#     get_shortest_words() — метод, возвращающий актуальный список самых коротких слов в наборе
#     get_longest_words() — метод, возвращающий актуальный список самых длинных слов в наборе
# Примечание 1. Слова в списках, возвращаемых методами get_shortest_words() и get_longest_words(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------
class TextHandler:
    def __init__(self) -> None:
        self.words = []

    def add_words(self, text):
        for word in text.split():
            self.words.append(word)

    def get_shortest_words(self):
        short = min(self.words, key=len, default=None)

        if short:
            return list(filter(lambda x: len(x) == len(short), self.words))
        return []

    def get_longest_words(self):
        long = max(self.words, key=len, default=None)

        if long:
            return list(filter(lambda x: len(x) == len(long), self.words))
        return []
# -------------------ПРЕПОД--------------------------------------


class TextHandler:
    def __init__(self):
        self.words = []
        self.shortest = 0
        self.longest = 0

    def add_words(self, words):
        words = words.split()
        self.words.extend(words)
        self.shortest = min(map(len, self.words))
        self.longest = max(map(len, self.words))

    def get_shortest_words(self):
        return [w for w in self.words if len(w) == self.shortest]

    def get_longest_words(self):
        return [w for w in self.words if len(w) == self.longest]
# ---------------------------------------------------------------


# Класс Todo
# 941
# Реализуйте класс Todo, описывающий список дел. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Todo должен иметь один атрибут:
#     things — изначально пустой список дел, которые нужно выполнить
# Класс Todo должен иметь четыре метода экземпляра:
#     add() — метод, принимающий название дела и его приоритет (целое число) и добавляющий данное дело в список дел в виде кортежа:
#     (<название дела>, <приоритет>)
#     get_by_priority() — метод, принимающий в качестве аргумента целое число n и возвращающий список названий дел, имеющих приоритет n
#     get_low_priority() — метод, возвращающий список названий дел, имеющих самый низкий приоритет
#     get_high_priority() — метод, возвращающий список названий дел, имеющих самый высокий приоритет
# Примечание 1. Названия дел в списках, возвращаемых методами get_by_priority(), get_low_priority() и get_high_priority(), должны располагаться в том порядке, в котором они были добавлены в список.
# ---------------------------------------------------------------
class Todo:
    def __init__(self) -> None:
        self.things = []
        self.priority_lst = []

    def add(self, case_name, priority):
        self.things.append((case_name, priority))
        self.priority_lst.append(priority)

    def get_by_priority(self, n):
        self.priority_lst.append(n)
        return [w[0] for w in self.things if w[1] == n]

    def get_low_priority(self):
        low_low_priority = min(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == low_low_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)

    def get_high_priority(self):
        high_priority = max(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == high_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)


todo = Todo()

todo.add('Ответить на вопросы', 5)
todo.add('Сделать картинки', 1)
todo.add('Доделать задачи', 4)
todo.add('Дописать конспект', 5)

print(todo.get_low_priority())
print(todo.get_high_priority())
print(todo.get_by_priority(3))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Postman
# 910
# Реализуйте класс Postman, описывающий почтальона. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Postman должен иметь один атрибут:
#     delivery_data — изначально пустой список адресов, по которым следует доставить письма
# Экземпляр класса Postman должен иметь три метода экземпляра:
#     add_delivery() — метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:
#     (<улица>, <дом>, <квартира>)
#     get_houses_for_street() — метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма
#     get_flats_for_house() — метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма
# Примечание 1. Дома и квартиры в списках, возвращаемых методами get_houses_for_street() и get_flats_for_house(), должны располагаться в том порядке, в котором они были добавлены.
# ---------------------------------------------------------------

class Postman:
    def __init__(self) -> None:
        # """изначально пустой список адресов, по которым следует доставить письма"""
        self.delivery_data = []

    def add_delivery(self, street, house, flat):
        """метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:  """
        self.delivery_data.append((street, house, flat))

    def get_houses_for_street(self, street):
        """метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма"""
        gen1 = (i[1] for i in self.delivery_data if i[0] == street)
        # удаляет дубликат списка
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)
        # sorted(set(x), key=lambda d: x.index(d))
        # функцию drop_duplicates из пандаса
        # збавиться от дубликатов, сохранив порядок можно через словарь
        return l1

    def get_flats_for_house(self, street, house):
        """метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма"""
        gen1 = (i[2] for i in self.delivery_data if i[0]
                == street and i[1] == house)
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)

        return l1
# ---------------------препод--через словарь---------------------------------


class Postman:
    def __init__(self):
        self.delivery_data = []

    def add_delivery(self, street, house, apartment):
        self.delivery_data.append((street, house, apartment))

    def get_houses_for_street(self, street):
        return list({h: None for s, h, _ in self.delivery_data if s == street})

    def get_flats_for_house(self, street, house):
        return list({a: None for s, h, a in self.delivery_data if s == street and h == house})
# ---------------------------------------------------------------


#  Класс Wordplay
# 850
# Будем называть словом любую последовательность из одной или более латинских букв.
# Реализуйте класс Wordplay, описывающий расширяемый набор слов. При создании экземпляра класс должен принимать один аргумент:
#     words — список, определяющий начальный набор слов. Если не передан, начальный набор слов считается пустым
# Экземпляр класса Wordplay должен иметь один атрибут:
#     words — список, содержащий набор слов
# Класс Wordplay должен иметь четыре метода экземпляра:
#     add_word() — метод, принимающий в качестве аргумента слово и добавляющий его в набор. Если слово уже есть в наборе, метод ничего не должен делать
#     words_with_length() — метод, принимающий в качестве аргумента натуральное число n и возвращающий список слов из набора, длина которых равна n
#     only() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из набора, которые включают в себя только переданные буквы
#     avoid() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из списка words, которые не содержат ни одну из этих букв
# Примечание 1. Слова в списках, возвращаемых методами words_with_length(), only() и avoid(), должны располагаться в том порядке, в котором они были добавлены.
# Примечание 2. Экземпляр класса Wordplay не должен зависеть от списка, на основе которого он был создан. Другими словами, если исходный список изменится, то экземпляр класса Wordplay измениться не должен.
# ---------------------------------------------------------------


class Wordplay:
    def __init__(self, words=None) -> None:
        if words is None:
            words = []
        words2 = copy.copy(words)
        self.words = words2

    def add_word(self, new_word):
        if new_word not in self.words:
            self.words.append(new_word)

    def words_with_length(self, n):
        return [word for word in self.words if len(word) == n]

    def only(self, *args):
        return [word for word in self.words if set(args) >= set(word)]

    def avoid(self, *args):
        return [word for word in self.words if set(args).isdisjoint(set(word))]


words = ['Лейбниц', 'Бэббидж', 'Нейман', 'Джобс', 'да_Винчи', 'Касперский']
wordplay = Wordplay(words)

words.extend(['Гуев', 'Харисов', 'Светкин'])
print(words)
print(wordplay.words)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Knight ♞
#
# Реализуйте класс Knight, описывающий шахматного коня. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     horizontal — координата коня по горизонтальной оси, представленная латинской буквой от a до h
#     vertical — координата коня по вертикальной оси, представленная целым числом от 1 до 8 включительно
#     color — цвет коня (black или white)
# Экземпляр класса Knight должен иметь три атрибута:
#     horizontal — координата коня на шахматной доске по горизонтальной оси
#     vertical — координата коня на шахматной доске по вертикальной оси
#     color — цвет коня
# Класс Knight должен иметь четыре метода экземпляра:
#     get_char() — метод, возвращающий символ N
#     can_move() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и возвращающий True, если конь может переместиться на клетку с данными координатами, или False в противном случае
#     move_to() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и заменяющий текущие координаты коня на переданные. Если конь из текущей клетки не может переместиться на клетку с указанными координатами, его координаты должны остаться неизменными
#     draw_board() — метод, печатающий шахматное поле, отмечающий на этом поле коня и клетки, на которые может переместиться конь. Пустые клетки должны быть отображены символом ., конь — символом N, клетки, на которые может переместиться конь, — символом *
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Circle
#
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:

#     radius — радиус круга

# Экземпляр класса Circle должен иметь три атрибута:

#     _radius — радиус круга
#     _diameter — диаметр круга
#     _area — площадь круга

# Класс Circle должен иметь три метода экземпляра:

#     get_radius() — метод, возвращающий радиус круга
#     get_diameter() — метод, возвращающий диаметр круга
#     get_area() — метод, возвращающий площадь круга

# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.

# Примечание 2. Импортировать константу ππ можно из модуля math:

# ---------------------------------------------------------------


class Circle:
    def __init__(self, radius: int) -> None:
        self._radius = radius
        self._diameter = 2 * radius
        self._area = math.pi * radius**2

    def get_radius(self) -> int:
        """метод, возвращающий радиус круга"""
        return self._radius

    def get_diameter(self) -> int:
        """метод, возвращающий диаметр круга"""
        return self._diameter

    def get_area(self) -> int:
        """метод, возвращающий площадь круга"""
        return self._area
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BankAccount
# 949
# Реализуйте класс BankAccount, описывающий банковский счет. При создании экземпляра класс должен принимать один аргумент:
#     balance — баланс счета, по умолчанию имеет значение 0
# Экземпляр класса BankAccount должен иметь один атрибут:
#     _balance — баланс счета
# Класс BankAccount должен иметь четыре метода экземпляра:
#     get_balance() — метод, возвращающий актуальный баланс счета
#     deposit() — метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount
#     withdraw() — метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
#     transfer() — метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

# from typing import Self

# class BankAccount:
#     def __init__(self, balance=0: int | float) -> None:
#         self._balance = balance

#     def get_balance(self) -> int | float:
#         """метод, возвращающий актуальный баланс счета"""
#         return self._balance

#     def deposit(self, amount: int | float):
#         """метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount"""
#         self._balance += amount

#     def withdraw(self, amount: int | float):
#         """метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением: На счете недостаточно средств"""
#         if self._balance > amount:
#             self._balance -= amount
#         else:
#             print('На счете недостаточно средств')
#             raise ValueError

#     # def transfer(self: Self, account: Self, amount: int) -> None:
#     def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
#         """метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: """
#         self.withdraw(amount)
#         self.account = account
#         self.account.deposit(amount)


# account1 = BankAccount(100)
# account2 = BankAccount(200)

# account1.transfer(account2, 50)
# print(account1.get_balance())
# print(account2.get_balance())
# ---------------------------------------------------------------
    # def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
    #     """метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: """
    #     self.withdraw(amount)
    #     self.account = account
    #     self.account.deposit(amount)
# ---------------------------------------------------------------


# Класс User
# 937
# Реализуйте класс User, описывающий интернет-пользователя. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя пользователя. Если name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     age — возраст пользователя. Если age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Экземпляр класса User должен иметь два атрибута:
#     _name — имя пользователя
#     _age — возраст пользователя
# Класс User должен иметь четыре метода экземпляра:
#     get_name() — метод, возвращающий имя пользователя
#     set_name() — метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     get_age() — метод, возвращающий возраст пользователя
#     set_age() — метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Примечание 1. Если при создании экземпляра класса User имя и возраст одновременно являются некорректными, должно быть возбуждено исключение, связанное с именем.
# ---------------------------------------------------------------
class User:
    def __init__(self, name: str, age: int) -> None:

        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже.
        self.set_name(name)
        self.set_age(age)

        self._name = name
        self._age = age

    def get_name(self):
        """метод, возвращающий имя пользователя"""
        return self._name

    def get_age(self):
        """метод, возвращающий возраст пользователя"""
        return self._age

    # Сеттер1

    def set_name(self, new_name: str):
        """метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом: """
        if isinstance(new_name, str) and new_name.isalpha():
            self._name = new_name
        else:
            raise ValueError('Некорректное имя')

    # Сеттер2
    def set_age(self, new_age: int):
        """метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом: """
        if isinstance(new_age, int) and 0 <= new_age <= 110:
            self._age = new_age
        else:
            raise ValueError('Некорректный возраст')
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 949
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь два свойства:
#     perimeter — свойство, доступное только для чтения, возвращающее периметр прямоугольника
#     area — свойство, доступное только для чтения, возвращающее площадь прямоугольника
# Примечание 1. При изменении сторон прямоугольника должны изменяться его периметр и площадь.
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length, width):
        self._length = length
        self._width = width

    # --------------------------------------------------------
    def get_length(self):
        """геттер - возвращает значение длины"""
        return self._length

    def set_length(self, length):
        """сеттер - меняет значение длины"""
        self._length = length

    # --------------------------------------------------------
    def get_width(self):
        """геттер -  возвращает значение ширины"""
        return self._width

    def set_width(self, width):
        """сеттер - меняет значение ширины"""
        self._width = width

    # --------------------------------------------------------
    def get_perimeter(self):
        """геттер - возвращает значение периметра"""
        return 2 * (self._length + self._width)

    # --------------------------------------------------------
    def get_area(self):
        """геттер -  возвращает значение площади"""
        return self._length * self._width
    # --------------------------------------------------------

    length = property(get_length, set_length)
    width = property(get_width, set_width)
    perimeter = property(get_perimeter)
    area = property(get_area)


rectangle = Rectangle(4, 5)

print(rectangle.length)
print(rectangle.width)
print(rectangle.perimeter)
print(rectangle.area)

# ---------------------------------------------------------------


class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def get_perimeter(self):
        return 2*(self.length + self.width)

    def get_area(self):
        return self.length * self.width

    perimeter = property(get_perimeter)
    area = property(get_area)
# ---------------------------------------------------------------


# Класс HourClock
# 958
# Реализуйте класс HourClock, описывающий часы с одной лишь часовой стрелкой. При создании экземпляра класс должен принимать один аргумент:
#     hours — количество часов. Если hours не является целым числом, принадлежащим диапазону [1; 12], должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Класс HourClock должен иметь одно свойство:
#     hours — свойство, доступное для чтения и записи, возвращающее текущее количество часов. При изменении свойство должно проверять, что новое значение является целым числом, принадлежащим диапазону [1; 12], в противном случае должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Примечание 1. Никаких ограничений касательно реализации класса HourClock нет, она может быть произвольной.
# ---------------------------------------------------------------
class HourClock:
    def __init__(self, hours: int) -> None:

        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже.
        self.set_hours(hours)

    def get_hours(self) -> int:
        """геттер возвращает текущее количество часов"""

        return self._hours

    def set_hours(self, hours: int) -> None:
        """cеттер изменяет и проверяет на корректность новое количество часов"""

        if not (isinstance(hours, int) and 1 <= hours <= 12):
            raise ValueError('Некорректное время')
        self._hours = hours

    hours = property(get_hours, set_hours)


time = HourClock(7)

print(time.hours)
time.hours = 9
print(time.hours)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Person
# 962
# Реализуйте класс Person, описывающий человека. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person должен иметь два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person должен иметь одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self.set_person(name, surname)

    def get_name(self) -> str:
        """геттер возвращает имя"""
        return self._name

    def get_surname(self) -> str:
        """геттер возвращает фамилию"""
        return self._surname

    def set_name(self, name) -> None:
        """сеттер изменяет имя"""
        self._name = name

    def set_surname(self, surname: str) -> None:
        """сеттер изменяет фамилию"""
        self._surname = surname

    def get_person(self) -> str:
        """возвращающее полное имя человека в виде строки"""
        return f"{self.get_name()} {self.get_surname()}"

    def set_person(self, *args: str) -> None:
        if len(args) == 1:
            l1 = args[0].split()
            self._name = l1[0]
            self._surname = l1[1]
        else:
            self._name, self._surname = args

    name = property(get_name, set_name)
    surname = property(get_surname, set_surname)
    fullname = property(get_person, set_person)


person = Person('Джон', 'Маккарти')

person.fullname = 'Алан Тьюринг'
print(person.name)
print(person.surname)

# -----------короче---------------------------------------


class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def get_fullname(self):
        return self.name + ' ' + self.surname

    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()

    fullname = property(get_fullname, set_fullname)
# ---------------------------------------------------------------


#  Person
#
# Вам доступен класс Person, описывающий человека. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person имеет два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person имеет одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Реализуйте свойство fullname класса Person с помощью декоратора @property.
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self._name = name
        self._surname = surname

    @property
    def fullname(self):
        return "{} {}".format(self.name, self.surname)

    @fullname.setter
    def fullname(self, fullname):
        self.name, self.surname = fullname.split()

# БЕЗ ДЕКОРАТОРА


class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def get_fullname(self):
        return self.name + ' ' + self.surname

    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()

    fullname = property(get_fullname, set_fullname)


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Account
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Account нет, она может быть произвольной.
# ---------------------------------------------------------------


class Account:
    def __init__(self, login, password) -> None:
        self._login = login
        self._password = hash_function(password)

    # ---------------------------------------------------------------

    @property
    def login(self):        # свойство доступно только для чтения (сеттер выдаст ошибку при попытке изменить логин)
        return self._login

    @login.setter
    def login(self, login):
        raise AttributeError('Изменение логина невозможно')
    # ---------------------------------------------------------------

    @property
    def password(self):        # свойство доступно для чтения и записи
        return self._password

    @password.setter
    def password(self, password):
        self._password = hash_function(password)


def hash_function(password):
    """ф-я принимает в качестве аргумента пароль и возвращает его хеш-значение."""
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10**9


account = Account('timyr-guev', 'lovebeegeek')

print(account.password)
account.password = 'verylovebeegeek'
print(account.password)

# ------------------препод-------------------------------------


def hash_function(password):
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10 ** 9


class Account:
    def __init__(self, login, password):
        self._login = login
        self.password = password

    @property
    def login(self):
        return self._login

    @login.setter
    def login(self, login):
        raise AttributeError('Изменение логина невозможно')

    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, password):
        self._password = hash_function(password)
# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------


# from typing import Tuple

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @property
    def x1(self) -> float | None:
        """ свойство, доступное только для чтения, возвращающее корень1 квадратного трехчлена,"""
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b - descriminant**0.5) / (2 * self.a)

    @property
    def x2(self) -> float | None:
        """ свойство, доступное только для чтения, возвращающее корень2 квадратного трехчлена"""
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b + descriminant**0.5) / (2 * self.a)

    @property
    def view(self) -> str:
        """ свойство, доступное только для чтения, возвращающее строку вида ax^2 + bx + c"""
        signs = ''
        for i in self.coefficients:
            if i >= 0:
                signs += '+'
            else:
                signs += '-'
        signs = signs[1:]

        res = '{a}x^2 {} {b}x {} {c}'.format(
            *signs, a=self.a, b=abs(self.b), c=abs(self.c))
        return res

    @property
    def coefficients(self) -> Tuple[int | float]:
        """геттер, доступ для чтения, возвращающее кортеж вида: (a, b, c)"""
        return (self.a, self.b, self.c)

    @coefficients.setter
    def coefficients(self, coefficients1) -> Tuple[int | float]:
        """сеттер изменяющий коэффициенты"""
        self.a, self.b, self.c = coefficients1


polynom = QuadraticPolynomial(1, 2, -3)

polynom.coefficients = (1, -5, 6)
print(polynom.x1)
print(polynom.x2)
print(polynom.view)
# -----------------препод---------------------------------------


class QuadraticPolynomial:
    def __init__(self, a, b, c):
        self.a, self.b, self.c = a, b, c

    @property
    def d(self):
        return self.b ** 2 - 4 * self.a * self.c

    @property
    def x1(self):
        # короткая запись if else
        return (-self.b - self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def x2(self):
        return (-self.b + self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def view(self):
        b, sign_b = abs(self.b), '-' if self.b < 0 else '+'
        c, sign_c = abs(self.c), '-' if self.c < 0 else '+'
        return f'{self.a}x^2 {sign_b} {b}x {sign_c} {c}'

    @property
    def coefficients(self):
        return self.a, self.b, self.c

    @coefficients.setter
    def coefficients(self, coeff):
        a, b, c = coeff
        self.a, self.b, self.c = a, b, c
# ---------------------------------------------------------------


# Класс Color
# 873
# Для кодирования цвета часто используется шестнадцатеричное значение цвета. Оно записывается в формате #RRGGBB, где RR (красный), GG (зеленый) и BB (синий) являются шестнадцатеричными целыми числами в диапазоне [00; FF] (или [0; 255] в десятичной системе счисления), которые указывают интенсивность соответствующих цветов. Например, #0000FF представляет чистый синий цвет, так как синий компонент имеет наивысшее значение (FF), а остальные — 00.
# Реализуйте класс Color, описывающий цвет. При создании экземпляра класс должен принимать один аргумент:
#     hexcode — шестнадцатеричное значение цвета
# Экземпляр класса Color должен иметь три атрибута:
#     r — интенсивность красного компонента цвета в виде десятичного числа
#     g — интенсивность зеленого компонента цвета в виде десятичного числа
#     b — интенсивность синего компонента цвета в виде десятичного числа
# Класс Color должен иметь одно свойство:
#     hexcode — свойство, доступное для чтения и записи, возвращающее шестнадцатеричное значение цвета
# Примечание 1. При изменении шестнадцатеричного значения цвета значения атрибутов r, g и b также должны изменяться.
# Примечание 2. Гарантируется, что для записи шестнадцатеричных чисел используются только заглавные латинские буквы.
# ---------------------------------------------------------------


class Color:
    def __init__(self, hexcode: str) -> None:
        self._hexcode = hexcode
        self.r = hex_to_ten(self._hexcode[:2])
        self.g = hex_to_ten(self._hexcode[2:4])
        self.b = hex_to_ten(self._hexcode[4:])

    # ---------------------------------------------------------------
    @property
    def hexcode(self) -> str:
        """геттер, возвращает шестнадцатеричное значение цвета"""
        return self._hexcode

    @hexcode.setter
    def hexcode(self, hexcode: str) -> None:
        """сеттер, для изменения цвета"""
        self._hexcode = hexcode
        self.r = hex_to_ten(hexcode[:2])
        self.g = hex_to_ten(hexcode[2:4])
        self.b = hex_to_ten(hexcode[4:])
    # ---------------------------------------------------------------


# оказывается :) функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое
def hex_to_ten(hex_num: str) -> int:
    """ф-я принимает шестнадцатеричное значение цвета и возвращает цвет в виде десятичного числа"""
    dict_hex = {'0': 0,
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                '6': 6,
                '7': 7,
                '8': 8,
                '9': 9,
                "A": 10,
                "B": 11,
                "C": 12,
                "D": 13,
                "E": 14,
                "F": 15}

    return sum((dict_hex[num_hex]) * 16**pow_index for pow_index, num_hex in enumerate(reversed(hex_num)))


color = Color('0000FF')

color.hexcode = 'A782E3'
print(color.hexcode)
print(color.r)
print(color.g)
print(color.b)
# -----------------препод--------------------------------------


class Color:
    def __init__(self, hexcode):
        self.hexcode = hexcode

    @property
    def hexcode(self):
        return self._hexcode

    @hexcode.setter
    def hexcode(self, hexcode):
        self._hexcode = hexcode

        # функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое
        self.r = int(hexcode[0:2], 16)
        self.g = int(hexcode[2:4], 16)
        self.b = int(hexcode[4:6], 16)
# ---------------------------------------------------------------


# Класс Circle
# 950
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь один атрибут:
#     radius — радиус круга
# Класс Circle должен иметь один метод класса:
#     from_diameter() — метод, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра
# ---------------------------------------------------------------
class Circle:
    def __init__(self, radius: int | float) -> None:
        self.radius = radius

    @classmethod
    def from_diameter(cls, diametr: int | float) -> int | float:
        """метод класса, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра"""

        return cls(diametr / 2)


circle = Circle.from_diameter(10)
print(circle.radius)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 965
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь один метод класса:
#     square() — метод, принимающий в качестве аргумента число side и возвращающий экземпляр класса Rectangle c длиной и шириной, равными side
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length: int | float, width: int | float) -> None:
        self.length = length
        self.width = width

    @classmethod
    def square(cls, side: int | float) -> 'Rectangle':
        """ метод класса, принимающий в качестве аргумента число side и возвращающий экземпляр класса """
        return cls(side, side)


rectangle = Rectangle.square(5)

print(rectangle.length)
print(rectangle.width)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 916
# вадратный трехчлен — это многочлен вида ax2+bx+cax2+bx+c, где a≠0a=0. Например:
# x2+1x2−5x+6Реализуйте класс QuadraticPolynomial, описывающий квадратный трехчлен. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Экземпляр класса QuadraticPolynomial должен иметь три атрибута:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Класс QuadraticPolynomial должен иметь два метода класса:
#     from_iterable() — метод, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов
#     from_str() — метод, принимающий в качестве аргумента строку, которая содержит коэффициенты a, b и c квадратного трехчлена, записанные через пробел. Метод должен возвращать экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов, предварительно преобразованных в экземпляры класса float
# ---------------------------------------------------------------

# from typing import TypeVar

# TMyClass = TypeVar("TMyClass", bound="MyClass")

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @classmethod
    def from_iterable(cls, iterable) -> 'QuadraticPolynomial':
        """метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов"""
        return cls(*iterable)

    @classmethod
    def from_str(cls, string) -> 'QuadraticPolynomial':
        """метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов"""
        iterable = map(float, string.split())
        return cls(iterable)
# ---------------------------------------------------------------


# Класс Pet
# 926
# Реализуйте класс Pet, описывающий домашнее животное. При создании экземпляра класс должен принимать один аргумент:
#     name — имя домашнего животного
# Экземпляр класса Pet должен иметь один атрибут:
#     name — имя домашнего животного
# Класс Pet должен иметь три метода класса:
#     first_pet() — метод, возвращающий самый первый созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     last_pet() — метод, возвращающий самый последний созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     num_of_pets() — метод, возвращающий количество созданных экземпляров класса Pet
# ---------------------------------------------------------------
class Pet:

    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)   # передаём весь экземпляр

    @classmethod
    def first_pet(cls):  # в методах класса нужно брать его из списка
        if cls.pets:
            return cls.pets[0]

    @classmethod
    def last_pet(cls):
        if cls.pets:
            return cls.pets[-1]

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)

# ----------------------------------------


class Pet:
    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)

    @classmethod
    def first_pet(cls):
        return cls.pets[0] if cls.pets else None

    @classmethod
    def last_pet(cls):
        return cls.pets[-1] if cls.pets else None

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)
# ---------------------------------------------------------------


# Класс StrExtension
#
# Реализуйте класс StrExtension, описывающий набор функций для работы со строками. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс StrExtension должен иметь три статических метода:
#     remove_vowels() — метод, который принимает в качестве аргумента строку, удаляет из нее все гласные латинские буквы без учета регистра и возвращает полученный результат
#     leave_alpha() — метод, который принимает в качестве аргумента строку, удаляет из нее все символы, не являющиеся латинскими буквами, и возвращает полученный результат
#     replace_all() — метод, который принимает три строковых аргумента string, chars и char, заменяет в строке string все символы из chars на char с учетом регистра и возвращает полученный результат.
# Примечание 1. Гарантируется, что все буквенные символы относятся к латинскому алфавиту.
# Примечание 2. Латинские гласные буквы: a, e, i, o, u, y.
# ---------------------------------------------------------------


class StrExtension:

    @staticmethod
    def remove_vowels(string1):
        vowels = ('a', 'e', 'i', 'o', 'u', 'y')
        str_off_vowels = (
            char for char in string1 if char.lower() not in vowels)
        return ''.join(str_off_vowels)

    @staticmethod
    def leave_alpha(string1):
        symbols = (char for char in string1 if char.lower()
                   not in string.ascii_lowercase)
        return ''.join(symbols)

    @staticmethod
    def replace_all(string1: str, chars, char):

        for char_old in chars:
            string1 = string1.replace(char_old, char)

        return string1


# -----------------c регулярками-------------------------------


class StrExtension:
    __VOWELS = re.compile(r'[aeiouy]', flags=re.I)
    __ALPHABET = re.compile(r'[^a-zA-Z]')

    @staticmethod
    def remove_vowels(string):
        return StrExtension.__VOWELS.sub('', string)

    @staticmethod
    def leave_alpha(string):
        return StrExtension.__ALPHABET.sub('', string)

    @staticmethod
    def replace_all(string, chars, char):
        return re.sub(fr'[{chars}]', char, string)
# ---------------------------------------------------------------


# Класс CaseHelper 🌶️
# 783
# Snake Case — стиль написания составных слов, при котором несколько слов разделяются символом нижнего подчеркивания (_) и не имеют пробелов в записи, причём каждое слово пишется с маленькой буквы. Например, bee_geek и hello_world.
# Upper Camel Case — стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с заглавной буквы. Например, BeeGeek и HelloWorld.
# Реализуйте класс CaseHelper, описывающий набор функций для работы со строками в стилях Snake Case и Upper Camel Case. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс CaseHelper должен иметь четыре статических метода:
#     is_snake() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Snake Case, или False в противном случае
#     is_upper_camel() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Upper Camel Case, или False в противном случае
#     to_snake() — метод, который принимает в качестве аргумента строку в стиле Upper Camel Case, записывает ее в стиле Snake Case и возвращает полученный результат
#     to_upper_camel() — метод, который принимает в качестве аргумента строку в стиле Snake Case, записывает ее в стиле Upper Camel Case и возвращает полученный результат
# ---------------------------------------------------------------

# class CaseHelper:


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Processor
# 937
# Вам доступен класс Processor. При создании экземпляра класс не принимает никаких аргументов.
# Класс Processor имеет один статический метод:
#     process() — метод, который принимает в качестве аргумента произвольный объект, преобразует его в зависимости от его типа и возвращает полученный результат. Если тип переданного объекта не поддерживается методом, возбуждается исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Перепишите метод process() класса Processor с использованием декоратора @singledispatchmethod, чтобы он выполнял ту же задачу.
# Примечание 1. Примеры преобразования объектов всех поддерживаемых типов показаны в методе process() класса Processor.
# # ---------------------------------------------------------------
# class Processor:
#     @staticmethod
#     def process(data):
#         if isinstance(data, (int, float)):
#             return data * 2
#         elif isinstance(data, str):
#             return data.upper()
#         elif isinstance(data, list):
#             return sorted(data)
#         elif isinstance(data, tuple):
#             return tuple(sorted(data))
#         raise TypeError('Аргумент переданного типа не поддерживается')
# ---------------------------------------------------------------


class Processor:
    @singledispatchmethod
    @staticmethod
    def process(data):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @process.register(tuple)
    @staticmethod
    def _tuple_process(data):
        return tuple(sorted(data))

    @process.register(list)
    @staticmethod
    def _list_process(data):
        return sorted(data)

    @process.register(str)
    @staticmethod
    def _str_process(data):
        return data.upper()

    @process.register(int)
    # @process.register(int | float)    # В Python 3.11 можно так
    @process.register(float)
    @staticmethod
    def _numeric_process(data):
        return data * 2
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Negator
# 953
# Реализуйте класс Negator. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Negator должен иметь один статический метод:
#     neg() — метод, принимающий в качестве аргумента объект и возвращающий его противоположное значение. Если методу передается целое или вещественное число, он должен возвращать это число, взятое с противоположным знаком. Если методу в качестве аргумента передается булево значение, он должен возвращать булево значение, противоположное переданному. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------


class Negator:
    @singledispatchmethod
    @staticmethod
    def neg(object):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @neg.register(int)
    @neg.register(float)
    @staticmethod
    def _str_neg(object):
        return object * (-1)

    @neg.register(bool)
    @staticmethod
    def _str_neg(object):
        return not object
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Formatter
# 917
# Реализуйте класс Formatter. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Formatter должен иметь один статический метод:
#     format() — метод, принимающий в качестве аргумента объект типа int, float, tuple, list или dict и выводящий информацию о переданном объекте в формате, зависящем от его типа. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Примеры форматирования объектов всех типов показаны в тестовых данных.
# Примечание 2. Обратите внимание, что метод format() должен обрамлять апострофами строковые элементы коллекций.
# ---------------------------------------------------------------


class Formatter:

    @singledispatchmethod
    @staticmethod
    def format(arg):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @format.register(int)
    def _(arg):
        print(f"Целое число: {arg}")

    @format.register(float)
    def _(arg):
        print(f"Вещественное число: {arg}")

    @format.register(tuple)
    def _(arg):
        print("Элементы кортежа: ", end='')
        print(*arg, sep=', ')

    @format.register(list)
    def _(arg):
        # print(f'Элементы списка: {", ".join([str(obj) for obj in data])}')
        print("Элементы списка: ", end='')
        print(*arg, sep=', ')

    @format.register(dict)
    def _(arg):
        # print(f'Пары словаря: {", ".join([str(pair) for pair in data.items()])}')
        print("Пары словаря: ", end='')
        print(*arg.items(), sep=', ')
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BirthInfo 🌶️
# 782
# Реализуйте класс BirthInfo, описывающий данные о дате рождения. При создании экземпляра класс должен принимать один аргумент:
#     birth_date — дата рождения, представленная в одном из следующих вариантов:
#     экземпляр класса date
#     строка с датой в ISO формате
#     список или кортеж из трех целых чисел: года, месяца и дня
# Если дата рождения является некорректной или представлена в каком-либо другом формате, должно быть возбуждено исключение TypeError с текстом:
# Аргумент переданного типа не поддерживается
# Экземпляр класса BirthInfo должен иметь один атрибут:
#     birth_date — дата рождения в виде экземпляра класса date
# Класс BirthInfo должен иметь одно свойство:
#     age — свойство, доступное только для чтения, возвращающее текущий возраст в годах, то есть количество полных лет, прошедших с даты рождения на сегодняшний день
# Примечание 1. Возраст в годах должен вычисляться так же, как и обычный возраст человека, то есть в день рождения его возраст увеличивается на один год.
# ---------------------------------------------------------------


class BirthInfo:

    @singledispatchmethod
    def __init__(self, birth_date) -> None:
        raise TypeError('Аргумент переданного типа не поддерживается')

    @__init__.register(date)
    def _(self, birth_date):
        self.birth_date = birth_date

    @__init__.register(str)
    def _(self, birth_date):
        # try:
        #     self.birth_date = date.fromisoformat(birth_date)
        # except:
        #     raise TypeError('Аргумент переданного типа не поддерживается')

        if not re.fullmatch(r'\d{4}-\d{2}-\d{2}', birth_date):
            raise TypeError('Аргумент переданного типа не поддерживается')
        self.birth_date = date.fromisoformat(birth_date)

    @__init__.register(list)
    @__init__.register(tuple)
    def _(self, birth_date):
        self.birth_date = date(*birth_date)

    @property
    def age(self):
        age = date.today().year - self.birth_date.year - 1
        age += (date.today().month,
                date.today().day) >= (self.birth_date.month, self.birth_date.day)
        return age
# ---------------------------------------------------------------


relativedelta(date1, date2).years
# ---------------------------------------------------------------


# Класс Config
#
# Реализуйте класс Config, который соответствует шаблону синглтон и описывает конфигурационный объект с фиксированными параметрами. При создании экземпляра класс не должен принимать никаких аргументов.
# При первом вызове класса Config должен создаваться и возвращаться экземпляр этого класса, а при последующих вызовах должен возвращаться экземпляр, созданный при первом вызове.
# Экземпляр класса Config должен иметь четыре атрибута:
#     program_name — атрибут со строковым значением GenerationPy
#     environment — атрибут со строковым значением release
#     loglevel — атрибут со строковым значением verbose
#     version — атрибут со строковым значением 1.0.0
# ---------------------------------------------------------------

class Config:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        self.program_name = 'GenerationPy'
        self.environment = 'release'
        self.loglevel = 'verbose'
        self.version = '1.0.0'


config = Config()

print(config.program_name)
print(config.environment)
print(config.loglevel)
print(config.version)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Book
# 949
# Требовалось реализовать класс Book, описывающий книгу. При создании экземпляра класс должен был принимать три аргумента в следующем порядке:
#     title — название книги
#     author — автор книги
#     year — год выпуска книги
# Предполагалось, что экземпляры класса Book будут иметь следующее формальное строковое представление:
# Book('<название книги>', '<автор книги>', <год выпуска книги>)
# И следующее неформальное строковое представление:
# <название книги> (<автор книги>, <год выпуска книги>)
# Программист торопился и решил задачу неправильно. Исправьте приведенный ниже код и реализуйте класс Book правильно.
# ---------------------------------------------------------------

class Book:
    def __init__(self, title, author, year) -> None:
        self.title = title
        self.author = author
        self.year = year

    def __str__(self):
        return f'{self.title} ({self.author}, {self.year})'

    def __repr__(self) -> str:
        return f"Book('{self.title}', '{self.author}', {self.year})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 972
# Вам доступен класс Rectangle, описывающий прямоугольник. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Реализуйте для экземпляров класса Rectangle следующее формальное и неформальное строковое представление:
# Rectangle(<длина прямоугольника>, <ширина прямоугольника>)
# ---------------------------------------------------------------

class Rectangle:
    def __init__(self, length, width) -> None:
        self.length = length
        self.width = width

    def __repr__(self) -> str:
        return f"Rectangle({self.length}, {self.width})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 966
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# И следующее неформальное строковое представление:
# Вектор на плоскости с координатами (<координата x>, <координата y>)
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x, y) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __str__(self) -> str:
        return f"Вектор на плоскости с координатами ({self.x}, {self.y})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс IPAddress
# 950
# IP-адрес — это уникальный адрес, идентифицирующий устройство в интернете или локальной сети. IP-адреса представляют собой набор из четырех целых чисел, разделенных точками. Например, 192.158.1.38. Каждое число в наборе принадлежит интервалу от 0 до 255. Таким образом, полный диапазон IP-адресации — это адреса от 0.0.0.0 до 255.255.255.255.
# Реализуйте класс IPAddress, описывающий IP-адрес. При создании экземпляра класс должен принимать один аргумент:
#     ipaddress — IP-адрес, представленный в одном из следующих вариантов:
#     строка из четырех целых чисел, разделенных точками
#     список или кортеж из четырех целых чисел
# Экземпляр класса IPAddress должен иметь следующее формальное строковое представление:
# IPAddress('<IP-адрес в виде четырех целых чисел, разделенных точками>')
# И следующее неформальное строковое представление:
# <IP-адрес в виде четырех целых чисел, разделенных точками>
# ---------------------------------------------------------------


class IPAddress:

    @singledispatchmethod
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ipaddress

    @__init__.register(tuple)
    @__init__.register(list)
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ''.join(ipaddress)

    def __repr__(self) -> str:
        return f"IPAddress('{self.ipaddress}')"

    def __str__(self) -> str:
        return f"{self.ipaddress}"

# ----------------if else------------------------------------------


class IPAddress:
    def __init__(self, ipadress):
        if isinstance(ipadress, str):
            self.ipadress = ipadress
        elif isinstance(ipadress, (list, tuple)):
            self.ipadress = '.'.join(map(str, ipadress))

    def __str__(self):
        return self.ipadress

    def __repr__(self):
        return f"{self.__class__.__name__}('{self.ipadress}')"

# -------------------property-------------------------------------


class IPAddress:
    def __init__(self, ipaddress: str | tuple):
        self.ipaddress = ipaddress

    @property
    def ipaddress(self):
        return self._ipaddress

    @ipaddress.setter
    def ipaddress(self, data: str | tuple | list):
        self._ipaddress = data if isinstance(
            data, str) else '.'.join(map(str, data))

    def __str__(self):
        return self._ipaddress

    def __repr__(self):
        return f"{type(self).__name__}('{self._ipaddress}')"


# Класс PhoneNumber
# 932
# ализуйте класс PhoneNumber, описывающий телефонный номер. При создании экземпляра класс должен принимать один аргумент:
#     phone_number — телефонный номер, представляющий строку из десяти цифр в одном из следующих форматов:
#     dddddddddd
#     ddd ddd dddd
# Экземпляр класса PhoneNumber должен иметь следующее формальное строковое представление:
# PhoneNumber('<телефонный номер в формате dddddddddd>')
# И следующее неформальное строковое представление:
# <телефонный номер в формате (ddd) ddd-dddd>
# ---------------------------------------------------------------


class PhoneNumber:
    def __init__(self, phone_number: str) -> None:
        self.tel_number = re.findall(
            '(\d{3})\s*(\d{3})\s*(\d{4})', phone_number)[0]

    def __repr__(self) -> str:
        return f"PhoneNumber('{''.join(self.tel_number)}')"

    def __str__(self) -> str:
        return "({}) {}-{}".format(*self.tel_number)


phone = PhoneNumber('9173963385')

print(str(phone))
print(repr(phone))
# -------------------replace-----------------------------------


class PhoneNumber:
    def __init__(self, phone_number):
        self.phone_number = phone_number.replace(' ', '')

    def __str__(self):
        return f'({self.phone_number[:3]}) {self.phone_number[3:6]}-{self.phone_number[6:]}'

    def __repr__(self):
        return f"PhoneNumber('{self.phone_number}')"


# ---------------------------------------------------------------


# Класс AnyClass
# 867
# Реализуйте класс AnyClass. При создании экземпляра класс должен принимать произвольное количество именованных аргументов и устанавливать их в качестве атрибутов создаваемому экземпляру.
# Экземпляр класса AnyClass должен иметь следующее формальное строковое представление:
# AnyClass(<имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...)
# И следующее неформальное строковое представление:
# AnyClass: <имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...
# Примечание 1. Обратите внимание, что значения атрибутов, которые принадлежат типу str, должны быть обрамлены апострофами.
# ---------------------------------------------------------------
class AnyClass:
    def __init__(self, **kwargs) -> None:
        self.kwargs = kwargs

        for key, value in self.kwargs.items():
            if isinstance(value, str):

                 '{}={!r}'.format(key, value)

        self.l1 = ((f"{key}='{value}'") for key, value in self.kwargs.items() if isinstance(value, str)))

    def __repr__(self) -> str:
        s=f"AnyClass({('{}, ' * len(self.l1))[:-2]})"
        return s.format(*self.l1)

        return "AnyClass({})".format(*self.l1)

    def __str__(self) -> str:
        s=f"AnyClass: {('{}, ' * len(self.l1))[:-2]}"
        return s.format(*self.l1)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 939
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# Также экземпляры класса Vector должны поддерживать операции сравнения с помощью операторов == и!=. Два вектора считаются равными, если их координаты по обеим осям совпадают. Методы, реализующие операции сравнения, должны уметь сравнивать как два вектора между собой, так и вектор с кортежем из двух чисел, представляющих координаты xx и yy.
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int | float, y: int | float) -> None:
        self.x=x
        self.y=y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __eq__(self, __o: object | tuple) -> bool:
        if isinstance(__o, Vector):
            return self.x == __o.x and self.y == __o.y
        elif isinstance(__o, tuple) == __o and len(__o) == 2:
            return (self.x, self.y) == __o
        return NotImplemented
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Word
# 956
# Будем называть словом любую последовательность из одной или более латинских букв.
# Реализуйте класс Word, описывающий слово. При создании экземпляра класс должен принимать один аргумент:
#     word — слово
# Экземпляр класса Word должен иметь следующее формальное строковое представление:
# Word('<слово в исходном виде>')
# И следующее неформальное строковое представление:
# <слово, в котором первая буква заглавная, а все остальные строчные>
# Также экземпляры класса Word должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два слова считаются равными, если их длины совпадают. Слово считается больше другого слова, если его длина больше.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

from functools import total_ordering

@ total_ordering
class Word:
    def __init__(self, word: str) -> None:
        self.word=word

    def __repr__(self) -> str:
        return "Word('{}')".format(self.word)

    def __str__(self) -> str:
        return self.word.title()

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Word):
            return len(self.word) == len(__o.word)
        return NotImplemented

    def __lt__(self, __o: object) -> bool:
        if isinstance(__o, Word):
            return len(self.word) < len(__o.word)
        return NotImplemented



# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Month
# 938
# Реализуйте класс Month, описывающий месяц. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     year — год
#     month — порядковый номер месяца
# Экземпляр класса Month должен иметь следующее формальное строковое представление:
# Month(<год>, <порядковый номер месяца>)
# И следующее неформальное строковое представление:
# <год>-<порядковый номер месяца>
# Также экземпляры класса Month должны поддерживать все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два Month объекта считаются равными, если их годы и порядковые номера месяцев совпадают. Month объект считается больше другого Month объекта, если его год больше. В случае если два Month объекта имеют равные года, большим считается тот, чей месяц больше. Методы, реализующие операции сравнения, должны уметь сравнивать как два Month объекта между собой, так и Month объект с кортежем из двух чисел, представляющих год и месяц.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
from functools import total_ordering
from typing import Tuple

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Version
# 886
# Реализуйте класс Version, описывающий версию программного обеспечения. При создании экземпляра класс должен принимать один аргумент:
#     version — строка из трех целых чисел, разделенных точками и описывающих версию ПО. Например, 2.8.1. Если одно из чисел не указано, оно считается равным нулю. Например, версия 2 равнозначна версии 2.0.0, а версия 2.8 равнозначна версии 2.8.0
# Экземпляр класса Version должен иметь следующее формальное строковое представление:
# Version('<версия ПО в виде трех целых чисел, разделенных точками>')
# И следующее неформальное строковое представление:
# <версия ПО в виде трех целых чисел, разделенных точками>
# Также экземпляры класса Version должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два Version объекта считаются равными, если все три числа в их версиях совпадают. Version объект считается больше другогоVersion объекта, если первое число в его версии больше. Или если второе число в его версии больше, если первые числа совпадают. Или если третье число в его версии больше, если первые и вторые числа совпадают.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from functools import total_ordering
from itertools import zip_longest


@ total_ordering
class Version:
    def __init__(self, version: str) -> None:

        nums_version=map(int, version.split('.'))
        index_elem=range(3)

        # заполняю недостающие цифры нулями и добавляю только первые элементы кортежей
        gen1=(i[0] for i in zip_longest(nums_version, index_elem, fillvalue=0))

        self.write_full_version='.'.join(map(str, gen1))
        self.num1, self.num2, self.num3=(
            int(char) for char in self.write_full_version.split('.'))




    def __repr__(self) -> str:
        return f"Version('{self.write_full_version}')"

    def __str__(self) -> str:
        return self.write_full_version

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Version):
            return (self.num1, self.num2, self.num3) == (__o.num1, __o.num2, __o.num3)
        return NotImplemented

    def __lt__(self, __o: object) -> bool:
        if isinstance(__o, Version):
            return (self.num1, self.num2, self.num3) < (__o.num1, __o.num2, __o.num3)
        return NotImplemented



versions=[Version('2'), Version('2.1'), Version('1.9.1')]

print(sorted(versions))
print(min(versions))
print(max(versions))


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ReversibleString
# 
# Реализуйте класс ReversibleString, описывающий строку. При создании экземпляра класс должен принимать один аргумент:
#     string — значение строки
# Экземпляр класса ReversibleString должен иметь следующее неформальное строковое представление:
# <значение строки>
# Также экземпляр класса ReversibleString должен поддерживать унарный оператор -, результатом которого должен являться новый экземпляр класса ReversibleString со значением строки в обратном порядке.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# --------------------------------------------------------------
class ReversibleString:
    def __init__(self, string: str) -> None:
        self.string = string

    def __str__(self) -> str:
        return f'{self.string}'


    def __neg__(self):        
        return ReversibleString(''.join(reversed(self.string)))

string = ReversibleString('python')

print(string)
print(-string)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Money
# 972
# Реализуйте класс Money, описывающий денежную сумму в рублях. При создании экземпляра класс должен принимать один аргумент:
#     amount — количество денег
# Экземпляр класса Money должен иметь следующее неформальное строковое представление:
# <количество денег> руб.
# Также экземпляр класса Money должен поддерживать унарные операторы + и -:
#     результатом унарного + должен являться новый экземпляр класса Money с неотрицательным количеством денег
#     результатом унарного - должен являться новый экземпляр класса Money с отрицательным количеством денег
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class Money:
    def __init__(self, amount: int | float) -> None:
        self.amount = amount

    def __str__(self) -> str:
        return f'{self.amount} руб.'

    def __neg__(self):        
        return Money(-abs(self.amount))

    def __pos__(self):
        return Money(abs(self.amount))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 959
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# И следующее неформальное строковое представление:
# (<координата вектора по оси x>, <координата вектора по оси y>)
# Также экземпляр класса Vector должен поддерживать унарные операторы + и -:
#     результатом унарного + должен являться новый экземпляр класса Vector с исходными координатами
#     результатом унарного - должен являться новый экземпляр класса Vector с координатами, взятыми с противоположным знаком
# Наконец, при передаче экземпляра класса Vector в функцию abs() должен возвращаться его модуль.
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x, y) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __str__(self) -> str:
        return f'({self.x}, {self.y})'


    def __pos__(self):
        return Vector(self.x, self.y)

    def __neg__(self):        
        return Vector(-self.x, -self.y)


    def __abs__(self):
        return (self.x**2 + self.y**2)**0.5

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ColoredPoint
# 939
# Реализуйте класс ColoredPoint, описывающий цветную точку на плоскости. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     color — цвет в формате RGB, представленный кортежем из трех целых чисел в диапазоне [0; 255], по умолчанию имеет значение (0, 0, 0)
# Экземпляр класса ColoredPoint должен иметь три атрибута:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     color — цвет в формате RGB, представленный кортежем из трех целых чисел от 0 до 255
# Также экземпляр класса ColoredPoint должен иметь следующее формальное строковое представление:
# ColoredPoint(<координата x>, <координата y>, <цвет точки в виде трехэлементного кортежа>)
# И следующее неформальное строковое представление:
# (<координата x>, <координата y>)
# Наконец, экземпляр класса ColoredPoint должен поддерживать унарные операторы +, - и ~:
#     результатом унарного + должен являться новый экземпляр класса ColoredPoint c исходными координатами и цветом
#     результатом унарного - должен являться новый экземпляр класса ColoredPoint c координатами, умноженными на минус единицу, и исходным цветом
#     результатом унарного ~ должен являться новый экземпляр класса ColoredPoint c координатами, переставленными местами, и инвертированным цветом: значение каждой компоненты цвета отнимается от 255
# ---------------------------------------------------------------
class ColoredPoint:
    def __init__(self, x, y, color=(0, 0, 0)) -> None:
        self.x, self.y, self.color = x, y, color

    def __repr__(self) -> str:
        return f"ColoredPoint({self.x}, {self.y}, {self.color})"

    def __str__(self) -> str:
        return f"({self.x}, {self.y})"

    def __pos__(self):
        return ColoredPoint(self.x, self.y, self.color)

    def __neg__(self):        
        return ColoredPoint(-self.x, -self.y, self.color)

    def __invert__(self):
        a, b, c = self.color
        return ColoredPoint(self.y, self.x, (255 - a, 255 - b, 255 - c))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Matrix 🌶️🌶️
#
# Реализуйте класс Matrix, описывающий двумерную матрицу. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     rows — количество строк в матрице
#     cols — количество столбцов в матрице
#     value — начальное значение для элементов матрицы, по умолчанию имеет значение 0
# Экземпляр класса Matrix должен иметь два атрибута:
#     rows — количество строк в матрице
#     cols — количество столбцов в матрице
# Класс Matrix должен иметь два метода экземпляра:
#     get_value() — метод, принимающий в качестве аргументов строку row и столбец col и возвращающий элемент матрицы со строкой row и столбцом col
#     set_value() — метод, принимающий в качестве аргументов строку row, столбец col и значение value и устанавливающий в качестве значения элемента матрицы со строкой row и столбцом col значение value
# Экземпляр класса Matrix должен иметь следующее формальное строковое представление:
# Matrix(<количество строк в матрице>, <количество столбцов в матрице>)
# Неформальным строковым представлением должна быть строка, в которой перечислены все элементы матрицы. Элементы строки матрицы должны быть разделены пробелом, строки матрицы должны быть разделены символом переноса строки \n. Например, для объекта Matrix(2, 3) неформальным строковым представлением должна быть строка 0 0 0\n0 0 0, которая при выводе будет отображаться следующим образом:
# 0 0 0
# 0 0 0
# Также экземпляр класса Matrix должен поддерживать унарные операторы +, - и ~:
#     результатом унарного + должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с исходными элементами
#     результатом унарного - должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с элементами, взятыми с противоположным знаком
#     результатом унарного ~ должен являться новый экземпляр класса Matrix, представляющий транспонированную матрицу
# Наконец, при передаче экземпляра класса Matrix в функцию round() должен возвращаться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с элементами, округленными с помощью функции round(). Во время передачи в функцию round() должна быть возможность в качестве второго необязательного аргумента указать целое число, определяющее количество знаков после запятой при округлении.
# Примечание 1. Индексация строк и столбцов в матрице начинается с нуля.
# ---------------------------------------------------------------

class Matrix:
    def __init__(self, rows: int, cols: int, value=0) -> None:
        self.rows = rows
        self.cols = cols
       
        self.matrix = [[value] * cols  for _ in range(rows)]        
    
    
    def get_value(self, row, col) -> int | float:
        """метод, принимающий в качестве аргументов строку row и столбец col и возвращающий элемент матрицы со строкой row и столбцом col"""
        return self.matrix[row][col]

    def set_value(self, row, col, value) -> None:
        """метод, принимающий в качестве аргументов строку row, столбец col и значение value и устанавливающий в качестве значения элемента матрицы со строкой row и столбцом col значение value"""
        self.matrix[row][col] = value        



    def __repr__(self) -> str:
        return f"Matrix({self.rows}, {self.cols})"

    def __str__(self) -> str:
        l1 = [' '.join(map(str, rows)) for rows in self.matrix]            
        return '\n'.join(l1)



    def __pos__(self) -> "Matrix":
        new_intance = Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                new_intance.set_value(i, j, self.get_value(i, j))  # используем сеттер и геттер

        return new_intance


    def __neg__(self)-> "Matrix":        
        new_intance = Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                new_intance.set_value(i, j, -self.get_value(i, j)) # используем сеттер и геттер

        return new_intance


    def __invert__(self) -> "Matrix":
        new_intance1 = Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                new_intance1.set_value(i, j, self.get_value(i, j))   # используем сеттер и геттер

        new_intance2 = Matrix(new_intance1.cols, new_intance1.rows)
        
        transponse = zip(*new_intance1.matrix)  # транспонируем new_intance1
        new_intance2.matrix = transponse    
        
        return new_intance2        
   
    
    def __round__(self, n=None) -> "Matrix":                
        new_intance = Matrix(self.rows, self.cols)
        
        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                if n is None:
                    new_intance.set_value(i, j, round(self.get_value(i, j)))
                new_intance.set_value(i, j, round(self.get_value(i, j), n))

        return new_intance


#------тест---
matrix = Matrix(5, 10)

floats = [[7125.900408, 633.354471, -9237.8575119, 2865.3825158, 5509.2609336, 8712.260779, 8317.523947, 2512.4736075,
           -3087.5496014, 3861.68814],
          [-7852.451832, 376.465911, -8142.7867326, -6921.8371407, 3735.7516227, -3322.8019034, 7115.79968,
           -8949.9313078, -7032.4347679, -5217.8236385],
          [-7817.9657992, -4319.716346, -1038.6294521, -2959.8970273, -9263.5713405, 9358.607686, 1429.6576196,
           -9484.68116, 639.6343972, 3444.9938213],
          [-2844.2405153, -2078.2441427, 6812.1367017, 112.3910618, -1116.8662449, 5042.7026276, -5981.6930342,
           4370.9173164, -8851.7648474, 8990.6896422],
          [90.8102435, 5256.6137481, -9743.8477321, -131.5501688, -5920.5976176, 4963.8336619, -4907.3622526,
           8531.2015615, -244.3630074, 3421.8817151]]

for r in range(5):
    for c in range(10):
        matrix.set_value(r, c, floats[r][c])

print('НАЧАЛЬНАЯ')
print(matrix)
print()
print('+++++')
print(+matrix)
print()
print('-------')
print(-matrix)
print()
print('ТРАНСПОНИРОВАНАЯ')
print(~matrix)
print()
print('ОКРУГЛЕНИЕ')
print(round(matrix, 2))
# ---------------------------------------------------------------

# ---------------------------------------------------------------

   
# Класс FoodInfo
# 943
# Реализуйте класс FoodInfo, описывающий пищевую ценность продуктов. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     proteins — количество белков в граммах
#     fats — количество жиров в граммах
#     carbohydrates — количество углеводов в граммах
# Экземпляр класса FoodInfo должен иметь три атрибута:
#     proteins — количество белков в граммах
#     fats — количество жиров в граммах
#     carbohydrates — количество углеводов в граммах
# И следующее формальное строковое представление:
# FoodInfo(<количество белков>, <количество жиров>, <количество углеводов>)
# Также экземпляры класса FoodInfo должны поддерживать между собой операцию сложения с помощью оператора +, результатом которой должен являться новый экземпляр класса FoodInfo с суммарным количеством белков, жиров и углеводов исходных экземпляров.
# Наконец, экземпляр класса FoodInfo должен поддерживать операции умножения, деления и деления нацело на число n с помощью операторов *, / и // соответственно:
#     результатом умножения должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого умножены на n
#     результатом деления должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого поделены на n
#     результатом деления нацело должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого поделены нацело на n
# Примечание 1. Числами будем считать экземпляры классов int и float. Также будем гарантировать, что экземпляр класса FoodInfo всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import TypeVar

Self = TypeVar("Self", bound="FoodInfo")



class FoodInfo:
    def __init__(self, proteins: int | float, fats: int | float, carbohydrates: int | float) -> None:
        self.proteins = proteins
        self.fats = fats
        self.carbohydrates = carbohydrates


    def __repr__(self) -> str:
        return f"FoodInfo({self.proteins}, {self.fats}, {self.carbohydrates})"

    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, FoodInfo):
            return FoodInfo(self.proteins + other.proteins, self.fats + other.fats, self.carbohydrates + other.carbohydrates)
        return NotImplemented

    def __mul__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins * other, self.fats * other, self.carbohydrates * other)
        return NotImplemented
   
    def __truediv__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins / other, self.fats / other, self.carbohydrates / other)
        return NotImplemented

    def __floordiv__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins // other, self.fats // other, self.carbohydrates // other)
        return NotImplemented

#--------tests----------
pfc = [(751.26, 778.77, 947.51), (597.41, 508.5, 532.96), (800.55, 617.5, 525.14), (741.99, 785.53, 664.71),
       (525.69, 892.41, 541.41), (888.8, 802.56, 868.78), (609.65, 855.43, 949.44), (705.25, 592.28, 738.72),
       (514.88, 617.22, 557.5), (948.62, 938.7, 817.17), (783.98, 628.32, 686.38), (894.9, 815.81, 715.19),
       (586.79, 826.68, 637.5), (670.53, 683.69, 841.56), (583.9, 607.34, 853.35), (954.67, 950.76, 822.19),
       (718.94, 658.12, 537.2), (556.53, 686.17, 622.61), (699.8, 872.49, 908.3), (622.3, 920.97, 801.17)]

FoodInfo.__round__ = lambda instance: FoodInfo(
    round(instance.proteins, 2),
    round(instance.fats, 2),
    round(instance.carbohydrates, 2)
)

food1 = FoodInfo(1000, 2000, 3000)
for p, f, c in pfc:
    food2 = FoodInfo(p, f, c)
    add_food = food1 + food2
    mul_food = food1 * p
    truediv_food = food1 // c
    print(round(add_food), round(mul_food), round(truediv_food))

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
#
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# Также экземпляры класса Vector должны поддерживать между собой операции сложения и вычитания с помощью операторов + и - соответственно:
#     результатом сложения должен являться новый экземпляр класса Vector, координата по оси xx которого равна сумме координат по оси xx исходных векторов, координата по оси yy — сумме координат по оси yy исходных векторов
#     результатом вычитания должен являться новый экземпляр класса Vector координата по оси xx которого равна разности координат по оси xx исходных векторов с учетом порядка, координата по оси yy — разности координат по оси yy исходных векторов с учетом порядка
# Наконец, экземпляр класса Vector должен поддерживать операции умножения и деления на число n с помощью операторов * и / соответственно:
#     результатом умножения должен являться новый экземпляр класса Vector, координаты которого умножены на n
#     результатом деления должен являться новый экземпляр класса Vector, координаты которого поделены на n
# Операция умножения должна быть выполнима независимо от порядка операндов, то есть должна быть возможность умножить как вектор на число, так и число на вектор.
# Примечание 1. Числами будем считать экземпляры классов int и float. Также будем гарантировать, что экземпляр класса Vector всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int, y: int) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented

    
    
    def __truediv__(self, n):
        if isinstance(n, (int, float)):
            return Vector(self.x / n, self.y / n)
        return NotImplemented
    
    def __rtruediv__(self, n):
        if isinstance(n, (int, float)):
            return Vector(n / self.x, n / self.y)
        return NotImplemented


    def __mul__(self, n):
        if isinstance(n, (int, float)):
            return Vector(self.x * n, self.y * n)
        return NotImplemented
    
    def __rmul__(self, n):
        if isinstance(n, (int, float)):
            return Vector(n * self.x, n * self.y)
        return NotImplemented


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс SuperString
# 893
# Реализуйте класс SuperString, описывающий строку. При создании экземпляра класс должен принимать один аргумент:
#     string — значение строки
# Экземпляр класса SuperString должен иметь следующее неформальное строковое представление:
# <значение строки>
# Помимо этого, экземпляры класса SuperString должны поддерживать между собой операцию сложения с помощью оператора +, результатом которой должен являться новый экземпляр класса SuperString, представляющий конкатенацию исходных.
# Также экземпляр класса SuperString должен поддерживать операции умножения, деления, побитового сдвига влево и побитового сдвига вправо на целое число n с помощью операторов *, /, << и >> соответственно:
#     результатом умножения должен являться новый экземпляр класса SuperString, представляющий исходную строку, умноженную на n
#     результатом деления должен являться новый экземпляр класса SuperString, представляющий строку из первых m символов исходной строки, где m — длина исходной строки, поделенная нацело на n
#     результатом побитового сдвига влево должен являться новый экземпляр класса SuperString, представляющий исходную строку без последних n символов. Если n больше или равно длине исходной строки, результатом должен являться экземпляр класса SuperString, представляющий пустую строку
#     результатом побитового сдвига вправо должен являться новый экземпляр класса SuperString, представляющий исходную строку без первых n символов. Если n больше или равно длине исходной строки, результатом должен являться экземпляр класса SuperString, представляющий пустую строку
# Операция умножения должна быть выполнима независимо от порядка операндов, то есть должна быть возможность умножить как строку на число, так и число на строку.
# Примечание 1. Будем гарантировать, что экземпляр класса SuperString всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class SuperString:
    def __init__(self, string: str) -> None:
        self.string = string

    def __str__(self) -> str:
        return self.string

    def __add__(self, other):
        if isinstance(other, SuperString):
            return SuperString(self.string + other.string) 
        return NotImplemented

    
    def __mul__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            return SuperString(self.string * n)
        return NotImplemented

    def __rmul__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            return SuperString(n * self.string)
        return NotImplemented

    def __truediv__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            s = len(self.string) // n
            return SuperString(self.string[:s])
        return NotImplemented

    
    
    def __lshift__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            if n <= len(self.string):
                if n == 0:
                    return SuperString(self.string)
                return SuperString(self.string[:-n])
            else:
                return SuperString('')
        return NotImplemented

    def __rshift__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            if n <= len(self.string):
                return SuperString(self.string[n:])
            else:
                return SuperString('')
        return NotImplemented

# ---------------------------------------------------------------


# Класс Time
# 880
# Реализуйте класс Time, описывающий время на цифровых часах. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     hours — количество часов; каждые 24 часа должны преобразовываться в 0 часов
#     minutes — количество минут; каждые 60 минут должны преобразовываться в 1 час
# Экземпляр класса Time должен иметь следующее неформальное строковое представление:
# <количество часов в формате HH>:<количество минут в формате MM>
# Также экземпляры класса Time должны поддерживать между собой операцию сложения с помощью операторов + и +=:
#     результатом сложения с помощью оператора + должен являться новый экземпляр класса Time, количество часов которого равно сумме часов исходных экземпляров класса Time, количество минут — сумме минут исходных экземпляров класса Time
#     результатом сложения с помощью оператора += должен являться левый экземпляр класса Time, количество часов которого увеличено на количество часов правого экземпляра класса Time, количество минут — на количество минут правого экземпляра класса Time
# Примечание 1. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import TypeVar

Self = TypeVar("Self", bound="Time")

class Time:
    def __init__(self, hours: int, minutes: int) -> None:
        # устанавливаем корректное время сеттером
        self.set_correct_hours(hours)
        self.set_correct_minutes(minutes)
        
    
    def get_correct_hours(self):
        """получить кол-во часов"""        
        return self.hours
    
    def set_correct_hours(self, hours):
        """сеттер, устанавливает корректное кол-во часов"""
        self.hours = hours % 24
        


    def get_correct_minutes(self):
        """получить кол-во минут"""
        return self.minutes

    def set_correct_min(self, minutes):
        """сеттер, устанавливает корректное кол-во минут"""     
        time_min = divmod(minutes, 60)        
        self.minutes = time_min[1]
        self.hours += time_min[0]
    
    
    
    def __str__(self) -> str:
        return f"{str(self.hours).zfill(2)}:{str(self.minutes).zfill(2)}"

    
    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, Time):
            return Time(self.hours + other.hours, self.minutes + other.minutes)
        return NotImplemented

    def __radd__(self, other: Self) -> Self:
        if isinstance(other, Time):
            return Time(other.hours + self.hours, other.minutes + self.minutes)
        return NotImplemented

    def __iadd__(self, other: Self) -> Self:
        if isinstance(other, Time):
            self.hours += other.hours
            self.minutes += other.minutes
            
            # устанавливаем корректное время
            self.set_correct_hours(self.get_correct_hours())
            self.set_correct_minutes(self.get_correct_minutes())            
            return self
        
        return NotImplemented
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# ---------------------------------------------------------------
